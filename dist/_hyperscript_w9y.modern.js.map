{"version":3,"file":"_hyperscript_w9y.modern.js","sources":["../src/lib/utils.js","../src/lib/core.js","../src/lib/plugin/socket.js","../src/lib/plugin/template.js","../src/lib/web.js","../src/web/_hyperscript_w9y.js","../src/lib/plugin/worker.js","../src/lib/plugin/eventsource.js","../src/lib/plugin/hdb.js"],"sourcesContent":["\n/**\n * mergeObjects combines the keys from obj2 into obj2, then returns obj1\n *\n * @param {object} obj1\n * @param {object} obj2\n * @returns object\n */\nexport function mergeObjects(obj1, obj2) {\n\tfor (var key in obj2) {\n\t\tif (obj2.hasOwnProperty(key)) {\n\t\t\tobj1[key] = obj2[key];\n\t\t}\n\t}\n\treturn obj1;\n}\n\nexport function getOrInitObject(root, prop) {\n\tvar value = root[prop];\n\tif (value) {\n\t\treturn value;\n\t} else {\n\t\tvar newObj = {};\n\t\troot[prop] = newObj;\n\t\treturn newObj;\n\t}\n}\n\n/**\n * parseJSON parses a JSON string into a corresponding value.  If the\n * value passed in is not valid JSON, then it logs an error and returns `null`.\n *\n * @param {string} jString\n * @returns any\n */\nexport function parseJSON(jString) {\n\ttry {\n\t\treturn JSON.parse(jString);\n\t} catch (error) {\n\t\tlogError(error);\n\t\treturn null;\n\t}\n}\n\n/**\n * logError writes an error message to the Javascript console.  It can take any\n * value, but msg should commonly be a simple string.\n * @param {*} msg\n */\nexport function logError(msg) {\n\tif (console.error) {\n\t\tconsole.error(msg);\n\t} else if (console.log) {\n\t\tconsole.log(\"ERROR: \", msg);\n\t}\n}\n\n// TODO: JSDoc description of what's happening here\nexport function varargConstructor(Cls, args) {\n\treturn new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n}\n","///=========================================================================\n/// This module provides the core runtime and grammar for hyperscript\n///=========================================================================\n\nimport {getOrInitObject, mergeObjects, parseJSON, varargConstructor} from \"./utils.js\";\n\n\n/**\n * @type {HyperscriptObject}\n */\nlet _hyperscript\n\nvar globalScope = globalThis;\n\n//====================================================================\n// Standard library\n//====================================================================\n\nclass ElementCollection {\n\tconstructor(css, relativeToElement, escape) {\n\t\tthis._css = css;\n\t\tthis.relativeToElement = relativeToElement;\n\t\tthis.escape = escape;\n\t}\n\n\tget css() {\n\t\tif (this.escape) {\n\t\t\treturn _runtime.escapeSelector(this._css);\n\t\t} else {\n\t\t\treturn this._css;\n\t\t}\n\t}\n\n\tget className() {\n\t\treturn this._css.substr(1);\n\t}\n\n\tget id() {\n\t\treturn this.className();\n\t}\n\n\tcontains(elt) {\n\t\tfor (let element of this) {\n\t\t\tif (element.contains(elt)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tget length() {\n\t\treturn this.selectMatches().length;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet query = this.selectMatches();\n\t\treturn query [Symbol.iterator]();\n\t}\n\n\tselectMatches() {\n\t\tlet query = _runtime.getRootNode(this.relativeToElement).querySelectorAll(this.css);\n\t\treturn query;\n\t}\n}\n\n//====================================================================\n// Lexer\n//====================================================================\n\n/** @type LexerObject */\nvar _lexer = (function () {\n\tvar OP_TABLE = {\n\t\t\"+\": \"PLUS\",\n\t\t\"-\": \"MINUS\",\n\t\t\"*\": \"MULTIPLY\",\n\t\t\"/\": \"DIVIDE\",\n\t\t\".\": \"PERIOD\",\n\t\t\"..\": \"ELLIPSIS\",\n\t\t\"\\\\\": \"BACKSLASH\",\n\t\t\":\": \"COLON\",\n\t\t\"%\": \"PERCENT\",\n\t\t\"|\": \"PIPE\",\n\t\t\"!\": \"EXCLAMATION\",\n\t\t\"?\": \"QUESTION\",\n\t\t\"#\": \"POUND\",\n\t\t\"&\": \"AMPERSAND\",\n\t\t$: \"DOLLAR\",\n\t\t\";\": \"SEMI\",\n\t\t\",\": \"COMMA\",\n\t\t\"(\": \"L_PAREN\",\n\t\t\")\": \"R_PAREN\",\n\t\t\"<\": \"L_ANG\",\n\t\t\">\": \"R_ANG\",\n\t\t\"<=\": \"LTE_ANG\",\n\t\t\">=\": \"GTE_ANG\",\n\t\t\"==\": \"EQ\",\n\t\t\"===\": \"EQQ\",\n\t\t\"!=\": \"NEQ\",\n\t\t\"!==\": \"NEQQ\",\n\t\t\"{\": \"L_BRACE\",\n\t\t\"}\": \"R_BRACE\",\n\t\t\"[\": \"L_BRACKET\",\n\t\t\"]\": \"R_BRACKET\",\n\t\t\"=\": \"EQUALS\",\n\t};\n\n\t/**\n\t * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSClassChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSIDChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isWhitespace returns `true` if the provided character is whitespace.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isWhitespace(c) {\n\t\treturn c === \" \" || c === \"\\t\" || isNewline(c);\n\t}\n\n\t/**\n\t * positionString returns a string representation of a Token's line and column details.\n\t * @param {Token} token\n\t * @returns string\n\t */\n\tfunction positionString(token) {\n\t\treturn \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n\t}\n\n\t/**\n\t * isNewline returns `true` if the provided character is a carrage return or newline\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNewline(c) {\n\t\treturn c === \"\\r\" || c === \"\\n\";\n\t}\n\n\t/**\n\t * isNumeric returns `true` if the provided character is a number (0-9)\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNumeric(c) {\n\t\treturn c >= \"0\" && c <= \"9\";\n\t}\n\n\t/**\n\t * isAlpha returns `true` if the provided character is a letter in the alphabet\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isAlpha(c) {\n\t\treturn (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @param {boolean} [dollarIsOp]\n\t * @returns boolean\n\t */\n\tfunction isIdentifierChar(c, dollarIsOp) {\n\t\treturn c === \"_\" || c === \"$\";\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isReservedChar(c) {\n\t\treturn c === \"`\" || c === \"^\";\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @param {Token[]} consumed\n\t * @param {string} source\n\t * @returns {TokensObject}\n\t */\n\tfunction makeTokensObject(tokens, consumed, source) {\n\t\tconsumeWhitespace(); // consume initial whitespace\n\n\t\t/** @type Token | null */\n\t\tvar _lastConsumed = null;\n\n\t\tfunction consumeWhitespace() {\n\t\t\twhile (token(0, true).type === \"WHITESPACE\") {\n\t\t\t\tconsumed.push(tokens.shift());\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {TokensObject} tokens\n\t\t * @param {*} error\n\t\t */\n\t\tfunction raiseError(tokens, error) {\n\t\t\t_parser.raiseParseError(tokens, error);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireOpToken(value) {\n\t\t\tvar token = matchOpToken(value);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyOpToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchOpToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchOpToken(value) {\n\t\t\tif (currentToken() && currentToken().op && currentToken().value === value) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireTokenType(type1, type2, type3, type4) {\n\t\t\tvar token = matchTokenType(type1, type2, type3, type4);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchTokenType(type1, type2, type3, type4) {\n\t\t\tif (\n\t\t\t\tcurrentToken() &&\n\t\t\t\tcurrentToken().type &&\n\t\t\t\t[type1, type2, type3, type4].indexOf(currentToken().type) >= 0\n\t\t\t) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireToken(value, type) {\n\t\t\tvar token = matchToken(value, type);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchToken(value, type) {\n\t\t\tif (follows.indexOf(value) !== -1) {\n\t\t\t\treturn; // disallowed token here\n\t\t\t}\n\t\t\tvar type = type || \"IDENTIFIER\";\n\t\t\tif (currentToken() && currentToken().value === value && currentToken().type === type) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction consumeToken() {\n\t\t\tvar match = tokens.shift();\n\t\t\tconsumed.push(match);\n\t\t\t_lastConsumed = match;\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn match;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token[]}\n\t\t */\n\t\tfunction consumeUntil(value, type) {\n\t\t\t/** @type Token[] */\n\t\t\tvar tokenList = [];\n\t\t\tvar currentToken = token(0, true);\n\n\t\t\twhile (\n\t\t\t\t(type == null || currentToken.type !== type) &&\n\t\t\t\t(value == null || currentToken.value !== value) &&\n\t\t\t\tcurrentToken.type !== \"EOF\"\n\t\t\t) {\n\t\t\t\tvar match = tokens.shift();\n\t\t\t\tconsumed.push(match);\n\t\t\t\ttokenList.push(currentToken);\n\t\t\t\tcurrentToken = token(0, true);\n\t\t\t}\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn tokenList;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lastWhitespace() {\n\t\t\tif (consumed[consumed.length - 1] && consumed[consumed.length - 1].type === \"WHITESPACE\") {\n\t\t\t\treturn consumed[consumed.length - 1].value;\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tfunction consumeUntilWhitespace() {\n\t\t\treturn consumeUntil(null, \"WHITESPACE\");\n\t\t}\n\n\t\t/**\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction hasMore() {\n\t\t\treturn tokens.length > 0;\n\t\t}\n\n\t\t/**\n\t\t * @param {number} n\n\t\t * @param {boolean} [dontIgnoreWhitespace]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction token(n, dontIgnoreWhitespace) {\n\t\t\tvar /**@type {Token}*/ token;\n\t\t\tvar i = 0;\n\t\t\tdo {\n\t\t\t\tif (!dontIgnoreWhitespace) {\n\t\t\t\t\twhile (tokens[i] && tokens[i].type === \"WHITESPACE\") {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoken = tokens[i];\n\t\t\t\tn--;\n\t\t\t\ti++;\n\t\t\t} while (n > -1);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"EOF\",\n\t\t\t\t\tvalue: \"<<<EOF>>>\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction currentToken() {\n\t\t\treturn token(0);\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token | null}\n\t\t */\n\t\tfunction lastMatch() {\n\t\t\treturn _lastConsumed;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction sourceFor() {\n\t\t\treturn source.substring(this.startToken.start, this.endToken.end);\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lineFor() {\n\t\t\treturn source.split(\"\\n\")[this.startToken.line - 1];\n\t\t}\n\n\t\tvar follows = [];\n\n\t\tfunction pushFollow(str) {\n\t\t\tfollows.push(str);\n\t\t}\n\n\t\tfunction popFollow() {\n\t\t\tfollows.pop();\n\t\t}\n\n\t\tfunction clearFollows() {\n\t\t\tvar tmp = follows;\n\t\t\tfollows = [];\n\t\t\treturn tmp;\n\t\t}\n\n\t\tfunction restoreFollows(f) {\n\t\t\tfollows = f;\n\t\t}\n\n\t\t/** @type {TokensObject} */\n\t\treturn {\n\t\t\tpushFollow: pushFollow,\n\t\t\tpopFollow: popFollow,\n\t\t\tclearFollow: clearFollows,\n\t\t\trestoreFollow: restoreFollows,\n\t\t\tmatchAnyToken: matchAnyToken,\n\t\t\tmatchAnyOpToken: matchAnyOpToken,\n\t\t\tmatchOpToken: matchOpToken,\n\t\t\trequireOpToken: requireOpToken,\n\t\t\tmatchTokenType: matchTokenType,\n\t\t\trequireTokenType: requireTokenType,\n\t\t\tconsumeToken: consumeToken,\n\t\t\tmatchToken: matchToken,\n\t\t\trequireToken: requireToken,\n\t\t\tlist: tokens,\n\t\t\tconsumed: consumed,\n\t\t\tsource: source,\n\t\t\thasMore: hasMore,\n\t\t\tcurrentToken: currentToken,\n\t\t\tlastMatch: lastMatch,\n\t\t\ttoken: token,\n\t\t\tconsumeUntil: consumeUntil,\n\t\t\tconsumeUntilWhitespace: consumeUntilWhitespace,\n\t\t\tlastWhitespace: lastWhitespace,\n\t\t\tsourceFor: sourceFor,\n\t\t\tlineFor: lineFor,\n\t\t};\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @returns {boolean}\n\t */\n\tfunction isValidSingleQuoteStringStart(tokens) {\n\t\tif (tokens.length > 0) {\n\t\t\tvar previousToken = tokens[tokens.length - 1];\n\t\t\tif (\n\t\t\t\tpreviousToken.type === \"IDENTIFIER\" ||\n\t\t\t\tpreviousToken.type === \"CLASS_REF\" ||\n\t\t\t\tpreviousToken.type === \"ID_REF\"\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} string\n\t * @param {boolean} [template]\n\t * @returns {TokensObject}\n\t */\n\tfunction tokenize(string, template) {\n\t\tvar tokens = /** @type {Token[]}*/ [];\n\t\tvar source = string;\n\t\tvar position = 0;\n\t\tvar column = 0;\n\t\tvar line = 1;\n\t\tvar lastToken = \"<START>\";\n\t\tvar templateBraceCount = 0;\n\n\t\tfunction inTemplate() {\n\t\t\treturn template && templateBraceCount === 0;\n\t\t}\n\n\t\twhile (position < source.length) {\n\t\t\tif (currentChar() === \"-\" && nextChar() === \"-\" && (isWhitespace(charAfterThat()) || charAfterThat() === \"\")) {\n\t\t\t\tconsumeComment();\n\t\t\t} else {\n\t\t\t\tif (isWhitespace(currentChar())) {\n\t\t\t\t\ttokens.push(consumeWhitespace());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \".\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeClassReference());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \"#\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeIdReference());\n\t\t\t\t} else if (currentChar() === \"[\" && nextChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeAttributeReference());\n\t\t\t\t} else if (currentChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeShortAttributeReference());\n\t\t\t\t} else if (currentChar() === \"*\" && isAlpha(nextChar())) {\n\t\t\t\t\ttokens.push(consumeStyleReference());\n\t\t\t\t} else if (isAlpha(currentChar()) || (!inTemplate() && isIdentifierChar(currentChar()))) {\n\t\t\t\t\ttokens.push(consumeIdentifier());\n\t\t\t\t} else if (isNumeric(currentChar())) {\n\t\t\t\t\ttokens.push(consumeNumber());\n\t\t\t\t} else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t} else if (!inTemplate() && currentChar() === \"'\") {\n\t\t\t\t\tif (isValidSingleQuoteStringStart(tokens)) {\n\t\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t\t}\n\t\t\t\t} else if (OP_TABLE[currentChar()]) {\n\t\t\t\t\tif (lastToken === \"$\" && currentChar() === \"{\") {\n\t\t\t\t\t\ttemplateBraceCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentChar() === \"}\") {\n\t\t\t\t\t\ttemplateBraceCount--;\n\t\t\t\t\t}\n\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t} else if (inTemplate() || isReservedChar(currentChar())) {\n\t\t\t\t\ttokens.push(makeToken(\"RESERVED\", consumeChar()));\n\t\t\t\t} else {\n\t\t\t\t\tif (position < source.length) {\n\t\t\t\t\t\tthrow Error(\"Unknown token: \" + currentChar() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn makeTokensObject(tokens, [], source);\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeOpToken(type, value) {\n\t\t\tvar token = makeToken(type, value);\n\t\t\ttoken.op = true;\n\t\t\treturn token;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeToken(type, value) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: value,\n\t\t\t\tstart: position,\n\t\t\t\tend: position + 1,\n\t\t\t\tcolumn: column,\n\t\t\t\tline: line,\n\t\t\t};\n\t\t}\n\n\t\tfunction consumeComment() {\n\t\t\twhile (currentChar() && !isNewline(currentChar())) {\n\t\t\t\tconsumeChar();\n\t\t\t}\n\t\t\tconsumeChar();\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeClassReference() {\n\t\t\tvar classRef = makeToken(\"CLASS_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tclassRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated class reference\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue += consumeChar(); // consume final curly\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSClassChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tclassRef.value = value;\n\t\t\tclassRef.end = position;\n\t\t\treturn classRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (position < source.length && currentChar() !== \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\tfunction consumeShortAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\tfunction consumeStyleReference() {\n\t\t\tvar styleRef = makeToken(\"STYLE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isAlpha(currentChar()) || currentChar() === \"-\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tstyleRef.value = value;\n\t\t\tstyleRef.end = position;\n\t\t\treturn styleRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdReference() {\n\t\t\tvar idRef = makeToken(\"ID_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tidRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated id reference\");\n\t\t\t\t} else {\n\t\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tidRef.value = value;\n\t\t\tidRef.end = position;\n\t\t\treturn idRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdentifier() {\n\t\t\tvar identifier = makeToken(\"IDENTIFIER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isAlpha(currentChar()) ||\n\t\t\t       isNumeric(currentChar()) ||\n\t\t\t       isIdentifierChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tidentifier.value = value;\n\t\t\tidentifier.end = position;\n\t\t\treturn identifier;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeNumber() {\n\t\t\tvar number = makeToken(\"NUMBER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \".\" && isNumeric(nextChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tnumber.value = value;\n\t\t\tnumber.end = position;\n\t\t\treturn number;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeOp() {\n\t\t\tvar op = makeOpToken();\n\t\t\tvar value = consumeChar(); // consume leading char\n\t\t\twhile (currentChar() && OP_TABLE[value + currentChar()]) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\top.type = OP_TABLE[value];\n\t\t\top.value = value;\n\t\t\top.end = position;\n\t\t\treturn op;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeString() {\n\t\t\tvar string = makeToken(\"STRING\");\n\t\t\tvar startChar = consumeChar(); // consume leading quote\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && currentChar() !== startChar) {\n\t\t\t\tif (currentChar() === \"\\\\\") {\n\t\t\t\t\tconsumeChar(); // consume escape char and move on\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() !== startChar) {\n\t\t\t\tthrow Error(\"Unterminated string at \" + positionString(string));\n\t\t\t} else {\n\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t}\n\t\t\tstring.value = value;\n\t\t\tstring.end = position;\n\t\t\tstring.template = startChar === \"`\";\n\t\t\treturn string;\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction currentChar() {\n\t\t\treturn source.charAt(position);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction nextChar() {\n\t\t\treturn source.charAt(position + 1);\n\t\t}\n\n\t\tfunction charAfterThat() {\n\t\t\treturn source.charAt(position + 2);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction consumeChar() {\n\t\t\tlastToken = currentChar();\n\t\t\tposition++;\n\t\t\tcolumn++;\n\t\t\treturn lastToken;\n\t\t}\n\n\t\t/**\n\t\t * @returns boolean\n\t\t */\n\t\tfunction possiblePrecedingSymbol() {\n\t\t\treturn (\n\t\t\t\tisAlpha(lastToken) ||\n\t\t\t\tisNumeric(lastToken) ||\n\t\t\t\tlastToken === \")\" ||\n\t\t\t\tlastToken === \"\\\"\" ||\n\t\t\t\tlastToken === \"'\" ||\n\t\t\t\tlastToken === \"`\" ||\n\t\t\t\tlastToken === \"}\" ||\n\t\t\t\tlastToken === \"]\"\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeWhitespace() {\n\t\t\tvar whitespace = makeToken(\"WHITESPACE\");\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && isWhitespace(currentChar())) {\n\t\t\t\tif (isNewline(currentChar())) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhitespace.value = value;\n\t\t\twhitespace.end = position;\n\t\t\treturn whitespace;\n\t\t}\n\t}\n\n\treturn {\n\t\ttokenize: tokenize,\n\t\tmakeTokensObject: makeTokensObject,\n\t};\n})();\n\n//====================================================================\n// Parser\n//====================================================================\n\n/** @type ParserObject */\nvar _parser = (function () {\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar GRAMMAR = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar COMMANDS = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar FEATURES = {};\n\n\tvar LEAF_EXPRESSIONS = [];\n\tvar INDIRECT_EXPRESSIONS = [];\n\n\t/**\n\t * @param {*} parseElement\n\t * @param {*} start\n\t * @param {TokensObject} tokens\n\t */\n\tfunction initElt(parseElement, start, tokens) {\n\t\tparseElement.startToken = start;\n\t\tparseElement.sourceFor = tokens.sourceFor;\n\t\tparseElement.lineFor = tokens.lineFor;\n\t\tparseElement.programSource = tokens.source;\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {GrammarElement?} root\n\t * @returns GrammarElement\n\t */\n\tfunction parseElement(type, tokens, root = undefined) {\n\t\tvar elementDefinition = GRAMMAR[type];\n\t\tif (elementDefinition) {\n\t\t\tvar start = tokens.currentToken();\n\t\t\tvar parseElement = elementDefinition(_parser, _runtime, tokens, root);\n\t\t\tif (parseElement) {\n\t\t\t\tinitElt(parseElement, start, tokens);\n\t\t\t\tparseElement.endToken = parseElement.endToken || tokens.lastMatch();\n\t\t\t\tvar root = parseElement.root;\n\t\t\t\twhile (root != null) {\n\t\t\t\t\tinitElt(root, start, tokens);\n\t\t\t\t\troot = root.root;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parseElement;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t * @param {*} [root]\n\t * @returns {GrammarElement}\n\t */\n\tfunction requireElement(type, tokens, message, root) {\n\t\tvar result = parseElement(type, tokens, root);\n\t\tif (!result) raiseParseError(tokens, message || \"Expected \" + type);\n\t\t// @ts-ignore\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {string[]} types\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseAnyOf(types, tokens) {\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar type = types[i];\n\t\t\tvar expression = parseElement(type, tokens);\n\t\t\tif (expression) {\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addGrammarElement(name, definition) {\n\t\tGRAMMAR[name] = definition;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addCommand(keyword, definition) {\n\t\tvar commandGrammarType = keyword + \"Command\";\n\t\tvar commandDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tconst commandElement = definition(parser, runtime, tokens);\n\t\t\tif (commandElement) {\n\t\t\t\tcommandElement.type = commandGrammarType;\n\t\t\t\tcommandElement.execute = function (context) {\n\t\t\t\t\tcontext.meta.command = commandElement;\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t};\n\t\t\t\treturn commandElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n\t\tCOMMANDS[keyword] = commandDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addFeature(keyword, definition) {\n\t\tvar featureGrammarType = keyword + \"Feature\";\n\n\t\t/** @type {GrammarDefinition} */\n\t\tvar featureDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tvar featureElement = definition(parser, runtime, tokens);\n\t\t\tif (featureElement) {\n\t\t\t\tfeatureElement.isFeature = true;\n\t\t\t\tfeatureElement.keyword = keyword;\n\t\t\t\tfeatureElement.type = featureGrammarType;\n\t\t\t\treturn featureElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n\t\tFEATURES[keyword] = featureDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addLeafExpression(name, definition) {\n\t\tLEAF_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addIndirectExpression(name, definition) {\n\t\tINDIRECT_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/* ============================================================================================ */\n\t/* Core hyperscript Grammar Elements                                                            */\n\t/* ============================================================================================ */\n\taddGrammarElement(\"feature\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar featureElement = parser.requireElement(\"feature\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn featureElement;\n\t\t}\n\n\t\tvar featureDefinition = FEATURES[tokens.currentToken().value];\n\t\tif (featureDefinition) {\n\t\t\treturn featureDefinition(parser, runtime, tokens);\n\t\t}\n\t});\n\n\taddGrammarElement(\"command\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tconst commandElement = parser.requireElement(\"command\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn commandElement;\n\t\t}\n\n\t\tvar commandDefinition = COMMANDS[tokens.currentToken().value];\n\t\tlet commandElement;\n\t\tif (commandDefinition) {\n\t\t\tcommandElement = commandDefinition(parser, runtime, tokens);\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\") {\n\t\t\tcommandElement = parser.parseElement(\"pseudoCommand\", tokens);\n\t\t}\n\t\tif (commandElement) {\n\t\t\treturn parser.parseElement(\"indirectStatement\", tokens, commandElement);\n\t\t}\n\n\t\treturn commandElement;\n\t});\n\n\taddGrammarElement(\"commandList\", function (parser, runtime, tokens) {\n\t\tvar cmd = parser.parseElement(\"command\", tokens);\n\t\tif (cmd) {\n\t\t\ttokens.matchToken(\"then\");\n\t\t\tconst next = parser.parseElement(\"commandList\", tokens);\n\t\t\tif (next) cmd.next = next;\n\t\t\treturn cmd;\n\t\t}\n\t});\n\n\taddGrammarElement(\"leaf\", function (parser, runtime, tokens) {\n\t\tvar result = parseAnyOf(LEAF_EXPRESSIONS, tokens);\n\t\t// symbol is last so it doesn't consume any constants\n\t\tif (result == null) {\n\t\t\treturn parseElement(\"symbol\", tokens);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\taddGrammarElement(\"indirectExpression\", function (parser, runtime, tokens, root) {\n\t\tfor (var i = 0; i < INDIRECT_EXPRESSIONS.length; i++) {\n\t\t\tvar indirect = INDIRECT_EXPRESSIONS[i];\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar result = parser.parseElement(indirect, tokens, root);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"indirectStatement\", function (parser, runtime, tokens, root) {\n\t\tif (tokens.matchToken(\"unless\")) {\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar conditional = parser.requireElement(\"expression\", tokens);\n\t\t\tvar unless = {\n\t\t\t\ttype: \"unlessStatementModifier\",\n\t\t\t\targs: [conditional],\n\t\t\t\top: function (context, conditional) {\n\t\t\t\t\tif (conditional) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.parent = unless;\n\t\t\treturn unless;\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"primaryExpression\", function (parser, runtime, tokens) {\n\t\tvar leaf = parser.parseElement(\"leaf\", tokens);\n\t\tif (leaf) {\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, leaf);\n\t\t}\n\t\tparser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n\t});\n\n\t/* ============================================================================================ */\n\t/* END Core hyperscript Grammar Elements                                                        */\n\n\t/* ============================================================================================ */\n\n\t/**\n\t *\n\t * @param {TokensObject} tokens\n\t * @returns string\n\t */\n\tfunction createParserContext(tokens) {\n\t\tvar currentToken = tokens.currentToken();\n\t\tvar source = tokens.source;\n\t\tvar lines = source.split(\"\\n\");\n\t\tvar line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n\t\tvar contextLine = lines[line];\n\t\tvar offset = currentToken && currentToken.line ? currentToken.column : contextLine.length - 1;\n\t\treturn contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t */\n\tfunction raiseParseError(tokens, message) {\n\t\tmessage =\n\t\t\t(message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + createParserContext(tokens);\n\t\tvar error = new Error(message);\n\t\terror[\"tokens\"] = tokens;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseHyperScript(tokens) {\n\t\tvar result = parseElement(\"hyperscript\", tokens);\n\t\tif (tokens.hasMore()) raiseParseError(tokens);\n\t\tif (result) return result;\n\t}\n\n\t/**\n\t * @param {GrammarElement} elt\n\t * @param {GrammarElement} parent\n\t */\n\tfunction setParent(elt, parent) {\n\t\tif (typeof elt === 'object') {\n\t\t\telt.parent = parent;\n\t\t\tif (typeof parent === 'object') {\n\t\t\t\tparent.children = (parent.children || new Set());\n\t\t\t\tparent.children.add(elt)\n\t\t\t}\n\t\t\tsetParent(elt.next, parent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction commandStart(token) {\n\t\treturn COMMANDS[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction featureStart(token) {\n\t\treturn FEATURES[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {boolean}\n\t */\n\tfunction commandBoundary(token) {\n\t\tif (\n\t\t\ttoken.value == \"end\" ||\n\t\t\ttoken.value == \"then\" ||\n\t\t\ttoken.value == \"else\" ||\n\t\t\ttoken.value == \"otherwise\" ||\n\t\t\ttoken.value == \")\" ||\n\t\t\tcommandStart(token) ||\n\t\t\tfeatureStart(token) ||\n\t\t\ttoken.type == \"EOF\"\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {(string | GrammarElement)[]}\n\t */\n\tfunction parseStringTemplate(tokens) {\n\t\t/** @type {(string | GrammarElement)[]} */\n\t\tvar returnArr = [\"\"];\n\t\tdo {\n\t\t\treturnArr.push(tokens.lastWhitespace());\n\t\t\tif (tokens.currentToken().value === \"$\") {\n\t\t\t\ttokens.consumeToken();\n\t\t\t\tvar startingBrace = tokens.matchOpToken(\"{\");\n\t\t\t\treturnArr.push(requireElement(\"expression\", tokens));\n\t\t\t\tif (startingBrace) {\n\t\t\t\t\ttokens.requireOpToken(\"}\");\n\t\t\t\t}\n\t\t\t\treturnArr.push(\"\");\n\t\t\t} else if (tokens.currentToken().value === \"\\\\\") {\n\t\t\t\ttokens.consumeToken(); // skip next\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else {\n\t\t\t\tvar token = tokens.consumeToken();\n\t\t\t\treturnArr[returnArr.length - 1] += token ? token.value : \"\";\n\t\t\t}\n\t\t} while (tokens.hasMore());\n\t\treturnArr.push(tokens.lastWhitespace());\n\t\treturn returnArr;\n\t}\n\n\t/**\n\t * @param {GrammarElement} commandList\n\t */\n\tfunction ensureTerminated(commandList) {\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tif (context.meta.resolve) {\n\t\t\t\t\tcontext.meta.resolve();\n\t\t\t\t}\n\t\t\t\treturn _runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (ctx) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\n\t\tvar end = commandList;\n\t\twhile (end.next) {\n\t\t\tend = end.next;\n\t\t}\n\t\tend.next = implicitReturn;\n\t}\n\n\n\t// parser API\n\treturn {\n\t\tsetParent,\n\t\trequireElement,\n\t\tparseElement,\n\t\tfeatureStart,\n\t\tcommandStart,\n\t\tcommandBoundary,\n\t\tparseAnyOf,\n\t\tparseHyperScript,\n\t\traiseParseError,\n\t\taddGrammarElement,\n\t\taddCommand,\n\t\taddFeature,\n\t\taddLeafExpression,\n\t\taddIndirectExpression,\n\t\tparseStringTemplate,\n\t\tensureTerminated,\n\t};\n})();\n\n//====================================================================\n// Runtime\n//====================================================================\n\nvar CONVERSIONS = {\n\tdynamicResolvers: /** @type DynamicConversionFunction[] */ [\n\t\tfunction(str, value){\n\t\t\tif (str === \"Fixed\") {\n\t\t\t\treturn Number(value).toFixed();\n\t\t\t} else if (str.indexOf(\"Fixed:\") === 0) {\n\t\t\t\tlet num = str.split(\":\")[1];\n\t\t\t\treturn Number(value).toFixed(parseInt(num));\n\t\t\t}\n\t\t}\n\t],\n\tString: function (val) {\n\t\tif (val.toString) {\n\t\t\treturn val.toString();\n\t\t} else {\n\t\t\treturn \"\" + val;\n\t\t}\n\t},\n\tInt: function (val) {\n\t\treturn parseInt(val);\n\t},\n\tFloat: function (val) {\n\t\treturn parseFloat(val);\n\t},\n\tNumber: function (val) {\n\t\treturn Number(val);\n\t},\n\tDate: function (val) {\n\t\treturn new Date(val);\n\t},\n\tArray: function (val) {\n\t\treturn Array.from(val);\n\t},\n\tJSON: function (val) {\n\t\treturn JSON.stringify(val);\n\t},\n\tObject: function (val) {\n\t\tif (val instanceof String) {\n\t\t\tval = val.toString();\n\t\t}\n\t\tif (typeof val === \"string\") {\n\t\t\treturn JSON.parse(val);\n\t\t} else {\n\t\t\treturn mergeObjects({}, val);\n\t\t}\n\t},\n};\n\n/********************************************\n * RUNTIME OBJECT\n ********************************************/\n\n/** @type {RuntimeObject} */\nvar _runtime = (function () {\n\t/**\n\t * @param {HTMLElement} elt\n\t * @param {string} selector\n\t * @returns boolean\n\t */\n\tfunction matchesSelector(elt, selector) {\n\t\t// noinspection JSUnresolvedVariable\n\t\tvar matchesFunction =\n\t\t\t// @ts-ignore\n\t\t\telt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n\t\treturn matchesFunction && matchesFunction.call(elt, selector);\n\t}\n\n\t/**\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @returns {Event}\n\t */\n\tfunction makeEvent(eventName, detail) {\n\t\tvar evt;\n\t\tif (globalScope.Event && typeof globalScope.Event === \"function\") {\n\t\t\tevt = new Event(eventName, {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true,\n\t\t\t});\n\t\t\tevt['detail'] = detail;\n\t\t} else {\n\t\t\tevt = document.createEvent(\"CustomEvent\");\n\t\t\tevt.initCustomEvent(eventName, true, true, detail);\n\t\t}\n\t\treturn evt;\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @param {Element} [sender]\n\t * @returns {boolean}\n\t */\n\tfunction triggerEvent(elt, eventName, detail, sender) {\n\t\tdetail = detail || {};\n\t\tdetail[\"sender\"] = sender;\n\t\tvar event = makeEvent(eventName, detail);\n\t\tvar eventResult = elt.dispatchEvent(event);\n\t\treturn eventResult;\n\t}\n\n\t/**\n\t * isArrayLike returns `true` if the provided value is an array or\n\t * a NodeList (which is close enough to being an array for our purposes).\n\t *\n\t * @param {any} value\n\t * @returns {value is Array | NodeList}\n\t */\n\tfunction isArrayLike(value) {\n\t\treturn Array.isArray(value) ||\n\t\t\t(typeof NodeList !== 'undefined' && (value instanceof NodeList || value instanceof HTMLCollection));\n\t}\n\n\t/**\n\t * isIterable returns `true` if the provided value supports the\n\t * iterator protocol.\n\t *\n\t * @param {any} value\n\t * @returns {value is Iterable}\n\t */\n\tfunction isIterable(value) {\n\t\treturn typeof value === 'object'\n\t\t\t&& Symbol.iterator in value\n\t\t\t&& typeof value[Symbol.iterator] === 'function';\n\t}\n\n\t/**\n\t * shouldAutoIterate returns `true` if the provided value\n\t * should be implicitly iterated over when accessing properties,\n\t * and as the target of some commands.\n\t *\n\t * Currently, this is when the value is an {ElementCollection}\n\t * or {isArrayLike} returns true.\n\t *\n\t * @param {any} value\n\t * @returns {value is any[] | NodeList | ElementCollection}\n\t */\n\tfunction shouldAutoIterate(value) {\n\t\treturn  value instanceof ElementCollection ||\n\t\t\t   isArrayLike(value);\n\t}\n\n\t/**\n\t * forEach executes the provided `func` on every item in the `value` array.\n\t * if `value` is a single item (and not an array) then `func` is simply called\n\t * once.  If `value` is null, then no further actions are taken.\n\t *\n\t * @template T\n\t * @param {T | Iterable<T>} value\n\t * @param {(item: T) => void} func\n\t */\n\tfunction forEach(value, func) {\n\t\tif (value == null) {\n\t\t\t// do nothing\n\t\t} else if (isIterable(value)) {\n\t\t\tfor (const nth of value) {\n\t\t\t\tfunc(nth);\n\t\t\t}\n\t\t} else if (isArrayLike(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tfunc(value[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\t/**\n\t * implicitLoop executes the provided `func` on:\n\t * - every item of {value}, if {value} should be auto-iterated\n\t *   (see {shouldAutoIterate})\n\t * - {value} otherwise\n\t *\n\t * @template T\n\t * @param {NodeList | T | T[]} value\n\t * @param {(item:Node | T) => void} func\n\t */\n\tfunction implicitLoop(value, func) {\n\t\tif (shouldAutoIterate(value)) {\n\t\t\tfor (const x of value) func(x);\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\tfunction wrapArrays(args) {\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tvar arg = args[i];\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\tarr.push(Promise.all(arg));\n\t\t\t} else {\n\t\t\t\tarr.push(arg);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction unwrapAsyncs(values) {\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar value = values[i];\n\t\t\tif (value.asyncWrapper) {\n\t\t\t\tvalues[i] = value.value;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar valueElement = value[j];\n\t\t\t\t\tif (valueElement.asyncWrapper) {\n\t\t\t\t\t\tvalue[j] = valueElement.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar HALT = {};\n\n\t/**\n\t * @param {GrammarElement} command\n\t * @param {Context} ctx\n\t */\n\tfunction unifiedExec(command, ctx) {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tvar next = unifiedEval(command, ctx);\n\t\t\t} catch (e) {\n\t\t\t\tif (ctx.meta.handlingFinally) {\n\t\t\t\t\tconsole.error(\" Exception in finally block: \", e);\n\t\t\t\t\tnext = HALT;\n\t\t\t\t} else {\n\t\t\t\t\t_runtime.registerHyperTrace(ctx, e);\n\t\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\t\tctx[ctx.meta.errorSymbol] = e;\n\t\t\t\t\t\tcommand = ctx.meta.errorHandler;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else  {\n\t\t\t\t\t\tctx.meta.currentException = e;\n\t\t\t\t\t\tnext = HALT;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tconsole.error(command, \" did not return a next element to execute! context: \", ctx);\n\t\t\t\treturn;\n\t\t\t} else if (next.then) {\n\t\t\t\tnext.then(function (resolvedNext) {\n\t\t\t\t\tunifiedExec(resolvedNext, ctx);\n\t\t\t\t}).catch(function (reason) {\n\t\t\t\t\tunifiedExec({ // Anonymous command to simply throw the exception\n\t\t\t\t\t\top: function(){\n\t\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, ctx);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else if (next === HALT) {\n\t\t\t\tif (ctx.meta.finallyHandler && !ctx.meta.handlingFinally) {\n\t\t\t\t\tctx.meta.handlingFinally = true;\n\t\t\t\t\tcommand = ctx.meta.finallyHandler;\n\t\t\t\t} else {\n\t\t\t\t\tif (ctx.meta.onHalt) {\n\t\t\t\t\t\tctx.meta.onHalt();\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx.meta.currentException) {\n\t\t\t\t\t\tif (ctx.meta.reject) {\n\t\t\t\t\t\t\tctx.meta.reject(ctx.meta.currentException);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow ctx.meta.currentException;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcommand = next; // move to the next command\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {*} parseElement\n\t* @param {Context} ctx\n\t* @returns {*}\n\t*/\n\tfunction unifiedEval(parseElement, ctx) {\n\t\t/** @type any[] */\n\t\tvar args = [ctx];\n\t\tvar async = false;\n\t\tvar wrappedAsyncs = false;\n\n\t\tif (parseElement.args) {\n\t\t\tfor (var i = 0; i < parseElement.args.length; i++) {\n\t\t\t\tvar argument = parseElement.args[i];\n\t\t\t\tif (argument == null) {\n\t\t\t\t\targs.push(null);\n\t\t\t\t} else if (Array.isArray(argument)) {\n\t\t\t\t\tvar arr = [];\n\t\t\t\t\tfor (var j = 0; j < argument.length; j++) {\n\t\t\t\t\t\tvar element = argument[j];\n\t\t\t\t\t\tvar value = element ? element.evaluate(ctx) : null; // OK\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarr.push(value);\n\t\t\t\t\t}\n\t\t\t\t\targs.push(arr);\n\t\t\t\t} else if (argument.evaluate) {\n\t\t\t\t\tvar value = argument.evaluate(ctx); // OK\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\targs.push(value);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(argument);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (async) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\targs = wrapArrays(args);\n\t\t\t\tPromise.all(args)\n\t\t\t\t\t.then(function (values) {\n\t\t\t\t\t\tif (wrappedAsyncs) {\n\t\t\t\t\t\t\tunwrapAsyncs(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar apply = parseElement.op.apply(parseElement, values);\n\t\t\t\t\t\t\tresolve(apply);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\treject(reason);\n\t\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tif (wrappedAsyncs) {\n\t\t\t\tunwrapAsyncs(args);\n\t\t\t}\n\t\t\treturn parseElement.op.apply(parseElement, args);\n\t\t}\n\t}\n\n\tlet _scriptAttrs = null;\n\n\t/**\n\t* getAttributes returns the attribute name(s) to use when\n\t* locating hyperscript scripts in a DOM element.  If no value\n\t* has been configured, it defaults to _hyperscript.config.attributes\n\t* @returns string[]\n\t*/\n\tfunction getScriptAttributes() {\n\t\tif (_scriptAttrs == null) {\n\t\t\t_scriptAttrs = _hyperscript.config.attributes.replace(/ /g, \"\").split(\",\");\n\t\t}\n\t\treturn _scriptAttrs;\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @returns {string | null}\n\t*/\n\tfunction getScript(elt) {\n\t\tfor (var i = 0; i < getScriptAttributes().length; i++) {\n\t\t\tvar scriptAttribute = getScriptAttributes()[i];\n\t\t\tif (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n\t\t\t\treturn elt.getAttribute(scriptAttribute);\n\t\t\t}\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\treturn elt.innerText;\n\t\t}\n\t\treturn null;\n\t}\n\n\tvar hyperscriptFeaturesMap = new WeakMap\n\n\t/**\n\t* @param {*} elt\n\t* @returns {Object}\n\t*/\n\tfunction getHyperscriptFeatures(elt) {\n\t\tvar hyperscriptFeatures = hyperscriptFeaturesMap.get(elt);\n\t\tif (typeof hyperscriptFeatures === 'undefined') {\n\t\t\thyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n\t\t}\n\t\treturn hyperscriptFeatures;\n\t}\n\n\t/**\n\t* @param {Object} owner\n\t* @param {Context} ctx\n\t*/\n\tfunction addFeatures(owner, ctx) {\n\t\tif (owner) {\n\t\t\tmergeObjects(ctx, getHyperscriptFeatures(owner));\n\t\t\taddFeatures(owner.parentElement, ctx);\n\t\t}\n\t}\n\n\t/**\n\t* @param {*} owner\n\t* @param {*} feature\n\t* @param {*} hyperscriptTarget\n\t* @param {*} event\n\t* @returns {Context}\n\t*/\n\tfunction makeContext(owner, feature, hyperscriptTarget, event) {\n\t\t/** @type {Context} */\n\t\tvar ctx = {\n\t\t\tmeta: {\n\t\t\t\tparser: _parser,\n\t\t\t\tlexer: _lexer,\n\t\t\t\truntime: _runtime,\n\t\t\t\towner: owner,\n\t\t\t\tfeature: feature,\n\t\t\t\titerators: {},\n\t\t\t},\n\t\t\tme: hyperscriptTarget,\n\t\t\tevent: event,\n\t\t\ttarget: event ? event.target : null,\n\t\t\tdetail: event ? event.detail : null,\n\t\t\tsender: event ? event.detail ? event.detail.sender : null : null,\n\t\t\tbody: \"document\" in globalScope ? document.body : null,\n\t\t};\n\t\tctx.meta.ctx = ctx;\n\t\taddFeatures(owner, ctx);\n\t\treturn ctx;\n\t}\n\n\t/**\n\t* @returns string\n\t*/\n\tfunction getScriptSelector() {\n\t\treturn getScriptAttributes()\n\t\t\t.map(function (attribute) {\n\t\t\t\treturn \"[\" + attribute + \"]\";\n\t\t\t})\n\t\t\t.join(\", \");\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {string} type\n\t* @returns {any}\n\t*/\n\tfunction convertValue(value, type) {\n\t\tvar dynamicResolvers = CONVERSIONS.dynamicResolvers;\n\t\tfor (var i = 0; i < dynamicResolvers.length; i++) {\n\t\t\tvar dynamicResolver = dynamicResolvers[i];\n\t\t\tvar converted = dynamicResolver(type, value);\n\t\t\tif (converted !== undefined) {\n\t\t\t\treturn converted;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar converter = CONVERSIONS[type];\n\t\tif (converter) {\n\t\t\treturn converter(value);\n\t\t}\n\n\t\tthrow \"Unknown conversion : \" + type;\n\t}\n\n\t// TODO: There do not seem to be any references to this function.\n\t// Is it still in use, or can it be removed?\n\tfunction isType(o, type) {\n\t\treturn Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n\t}\n\n\t/**\n\t* @param {string} src\n\t* @returns {GrammarElement}\n\t*/\n\tfunction parse(src) {\n\t\tvar tokens = _lexer.tokenize(src);\n\t\tif (_parser.commandStart(tokens.currentToken())) {\n\t\t\tvar commandList = _parser.requireElement(\"commandList\", tokens);\n\t\t\tif (tokens.hasMore()) _parser.raiseParseError(tokens);\n\t\t\t_parser.ensureTerminated(commandList);\n\t\t\treturn commandList;\n\t\t} else if (_parser.featureStart(tokens.currentToken())) {\n\t\t\tvar hyperscript = _parser.requireElement(\"hyperscript\", tokens);\n\t\t\tif (tokens.hasMore()) _parser.raiseParseError(tokens);\n\t\t\treturn hyperscript;\n\t\t} else {\n\t\t\tvar expression = _parser.requireElement(\"expression\", tokens);\n\t\t\tif (tokens.hasMore()) _parser.raiseParseError(tokens);\n\t\t\treturn expression;\n\t\t}\n\t}\n\n\t/**\n\t *\n\t * @param {GrammarElement} elt\n\t * @param {Context} ctx\n\t * @returns {any}\n\t */\n\tfunction evaluateNoPromise(elt, ctx) {\n\t\tlet result = elt.evaluate(ctx);\n\t\tif (result.next) {\n\t\t\tthrow new Error(elt.sourceFor() + \" returned a Promise in a context that they are not allowed.\");\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t* @param {string} src\n\t* @param {Context} [ctx]\n\t* @param {Object} [args]\n\t* @returns {any}\n\t*/\n\tfunction evaluate(src, ctx, args) {\n\t\tclass HyperscriptModule extends EventTarget {\n\t\t\tconstructor(mod) {\n\t\t\t\tsuper();\n\t\t\t\tthis.module = mod;\n\t\t\t}\n\t\t\ttoString() {\n\t\t\t\treturn this.module.id;\n\t\t\t}\n\t\t}\n\n\t\tvar body = 'document' in globalScope\n\t\t\t? globalScope.document.body\n\t\t\t: new HyperscriptModule(args && args.module);\n\t\tctx = mergeObjects(makeContext(body, null, body, null), ctx || {});\n\t\tvar element = parse(src);\n\t\tif (element.execute) {\n\t\t\telement.execute(ctx);\n\t\t\treturn ctx.result;\n\t\t} else if (element.apply) {\n\t\t\telement.apply(body, body, args);\n\t\t\treturn getHyperscriptFeatures(body);\n\t\t} else {\n\t\t\treturn element.evaluate(ctx);\n\t\t}\n\n\t\tfunction makeModule() {\n\t\t\treturn {}\n\t\t}\n\t}\n\n\t/**\n\t* @param {HTMLElement} elt\n\t*/\n\tfunction processNode(elt) {\n\t\tvar selector = _runtime.getScriptSelector();\n\t\tif (matchesSelector(elt, selector)) {\n\t\t\tinitElement(elt, elt);\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\tinitElement(elt, document.body);\n\t\t}\n\t\tif (elt.querySelectorAll) {\n\t\t\tforEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), function (elt) {\n\t\t\t\tinitElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @param {Element} [target]\n\t*/\n\tfunction initElement(elt, target) {\n\t\tif (elt.closest && elt.closest(_hyperscript.config.disableSelector)) {\n\t\t\treturn;\n\t\t}\n\t\tvar internalData = getInternalData(elt);\n\t\tif (!internalData.initialized) {\n\t\t\tvar src = getScript(elt);\n\t\t\tif (src) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalData.initialized = true;\n\t\t\t\t\tinternalData.script = src;\n\t\t\t\t\tvar tokens = _lexer.tokenize(src);\n\t\t\t\t\tvar hyperScript = _parser.parseHyperScript(tokens);\n\t\t\t\t\tif (!hyperScript) return;\n\t\t\t\t\thyperScript.apply(target || elt, elt);\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\ttriggerEvent(target || elt, \"load\", {\n\t\t\t\t\t\t\thyperscript: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 1);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_runtime.triggerEvent(elt, \"exception\", {\n\t\t\t\t\t\terror: e,\n\t\t\t\t\t});\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\"hyperscript errors were found on the following element:\",\n\t\t\t\t\t\telt,\n\t\t\t\t\t\t\"\\n\\n\",\n\t\t\t\t\t\te.message,\n\t\t\t\t\t\te.stack\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalDataMap = new WeakMap\n\n\t/**\n\t* @param {Element} elt\n\t* @returns {Object}\n\t*/\n\tfunction getInternalData(elt) {\n\t\tvar internalData = internalDataMap.get(elt);\n\t\tif (typeof internalData === 'undefined') {\n\t\t\tinternalDataMap.set(elt, internalData = {});\n\t\t}\n\t\treturn internalData;\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {string} typeString\n\t* @param {boolean} [nullOk]\n\t* @returns {boolean}\n\t*/\n\tfunction typeCheck(value, typeString, nullOk) {\n\t\tif (value == null && nullOk) {\n\t\t\treturn true;\n\t\t}\n\t\tvar typeName = Object.prototype.toString.call(value).slice(8, -1);\n\t\treturn typeName === typeString;\n\t}\n\n\tfunction getElementScope(context) {\n\t\tvar elt = context.meta && context.meta.owner;\n\t\tif (elt) {\n\t\t\tvar internalData = getInternalData(elt);\n\t\t\tvar scopeName = \"elementScope\";\n\t\t\tif (context.meta.feature && context.meta.feature.behavior) {\n\t\t\t\tscopeName = context.meta.feature.behavior + \"Scope\";\n\t\t\t}\n\t\t\tvar elementScope = getOrInitObject(internalData, scopeName);\n\t\t\treturn elementScope;\n\t\t} else {\n\t\t\treturn {}; // no element, return empty scope\n\t\t}\n\t}\n\n\t/**\n\t* @param {string} str\n\t* @param {Context} context\n\t* @returns {any}\n\t*/\n\tfunction resolveSymbol(str, context, type) {\n\t\tif (str === \"me\" || str === \"my\" || str === \"I\") {\n\t\t\treturn context[\"me\"];\n\t\t}\n\t\tif (str === \"it\" || str === \"its\") {\n\t\t\treturn context[\"result\"];\n\t\t}\n\t\tif (str === \"you\" || str === \"your\" || str === \"yourself\") {\n\t\t\treturn context[\"beingTold\"];\n\t\t} else {\n\t\t\tif (type === \"global\") {\n\t\t\t\treturn globalScope[str];\n\t\t\t} else if (type === \"element\") {\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\treturn elementScope[str];\n\t\t\t} else if (type === \"local\") {\n\t\t\t\treturn context[str];\n\t\t\t} else {\n\t\t\t\t// meta scope (used for event conditionals)\n\t\t\t\tif (context.meta && context.meta.context) {\n\t\t\t\t\tvar fromMetaContext = context.meta.context[str];\n\t\t\t\t\tif (typeof fromMetaContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromMetaContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// local scope\n\t\t\t\tvar fromContext = context[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\treturn fromContext;\n\t\t\t\t} else {\n\t\t\t\t\t// element scope\n\t\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\t\tfromContext = elementScope[str];\n\t\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromContext;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// global scope\n\t\t\t\t\t\treturn globalScope[str];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSymbol(str, context, type, value) {\n\t\tif (type === \"global\") {\n\t\t\tglobalScope[str] = value;\n\t\t} else if (type === \"element\") {\n\t\t\tvar elementScope = getElementScope(context);\n\t\t\telementScope[str] = value;\n\t\t} else if (type === \"local\") {\n\t\t\tcontext[str] = value;\n\t\t} else {\n\t\t\t// local scope\n\t\t\tvar fromContext = context[str];\n\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\tcontext[str] = value;\n\t\t\t} else {\n\t\t\t\t// element scope\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\tfromContext = elementScope[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\telementScope[str] = value;\n\t\t\t\t} else {\n\t\t\t\t\tcontext[str] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {GrammarElement | void} command\n\t* @param {Context} context\n\t* @returns {undefined | GrammarElement}\n\t*/\n\tfunction findNext(command, context) {\n\t\tif (command) {\n\t\t\tif (command.resolveNext) {\n\t\t\t\treturn command.resolveNext(context);\n\t\t\t} else if (command.next) {\n\t\t\t\treturn command.next;\n\t\t\t} else {\n\t\t\t\treturn findNext(command.parent, context);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* @param {Object<string,any>} root\n\t* @param {string} property\n\t* @param {(Object, string) => any} getter\n\t* @returns {any}\n\t*/\n\tfunction flatGet(root, property, getter) {\n\t\tif (root != null) {\n\t\t\tvar val = getter(root, property);\n\t\t\tif (typeof val !== \"undefined\") {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif (shouldAutoIterate(root)) {\n\t\t\t\t// flat map\n\t\t\t\tvar result = [];\n\t\t\t\tfor (var component of root) {\n\t\t\t\t\tvar componentValue = getter(component, property);\n\t\t\t\t\tif (componentValue) {\n\t\t\t\t\t\tresult.push(componentValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction resolveProperty(root, property) {\n\t\treturn flatGet(root, property, (root, property) => root[property] )\n\t}\n\n\tfunction resolveAttribute(root, property) {\n\t\treturn flatGet(root, property, (root, property) => root.getAttribute && root.getAttribute(property) )\n\t}\n\n\t/**\n\t *\n\t * @param {Object<string, any>} root\n\t * @param {string} property\n\t * @returns {string}\n\t */\n\tfunction resolveStyle(root, property) {\n\t\treturn flatGet(root, property, (root, property) => root.style && root.style[property] )\n\t}\n\n\t/**\n\t *\n\t * @param {Object<string, any>} root\n\t * @param {string} property\n\t * @returns {string}\n\t */\n\tfunction resolveComputedStyle(root, property) {\n\t\treturn flatGet(root, property, (root, property) => getComputedStyle(root).getPropertyValue(property) )\n\t}\n\n\t/**\n\t* @param {Element} elt\n\t* @param {string[]} nameSpace\n\t* @param {string} name\n\t* @param {any} value\n\t*/\n\tfunction assignToNamespace(elt, nameSpace, name, value) {\n\t\tlet root\n\t\tif (typeof document !== \"undefined\" && elt === document.body) {\n\t\t\troot = globalScope;\n\t\t} else {\n\t\t\troot = getHyperscriptFeatures(elt);\n\t\t}\n\t\twhile (nameSpace.length > 0) {\n\t\t\tvar propertyName = nameSpace.shift();\n\t\t\tvar newRoot = root[propertyName];\n\t\t\tif (newRoot == null) {\n\t\t\t\tnewRoot = {};\n\t\t\t\troot[propertyName] = newRoot;\n\t\t\t}\n\t\t\troot = newRoot;\n\t\t}\n\n\t\troot[name] = value;\n\t}\n\n\tfunction getHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = ctx;\n\t\twhile (root.meta.caller) {\n\t\t\troot = root.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap) {\n\t\t\treturn root.meta.traceMap.get(thrown, trace);\n\t\t}\n\t}\n\n\tfunction registerHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = null;\n\t\twhile (ctx != null) {\n\t\t\ttrace.push(ctx);\n\t\t\troot = ctx;\n\t\t\tctx = ctx.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap == null) {\n\t\t\troot.meta.traceMap = new Map(); // TODO - WeakMap?\n\t\t}\n\t\tif (!root.meta.traceMap.get(thrown)) {\n\t\t\tvar traceEntry = {\n\t\t\t\ttrace: trace,\n\t\t\t\tprint: function (logger) {\n\t\t\t\t\tlogger = logger || console.error;\n\t\t\t\t\tlogger(\"hypertrace /// \");\n\t\t\t\t\tvar maxLen = 0;\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tmaxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tvar traceElt = trace[i];\n\t\t\t\t\t\tlogger(\n\t\t\t\t\t\t\t\"  ->\",\n\t\t\t\t\t\t\ttraceElt.meta.feature.displayName.padEnd(maxLen + 2),\n\t\t\t\t\t\t\t\"-\",\n\t\t\t\t\t\t\ttraceElt.meta.owner\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.meta.traceMap.set(thrown, traceEntry);\n\t\t}\n\t}\n\n\t/**\n\t* @param {string} str\n\t* @returns {string}\n\t*/\n\tfunction escapeSelector(str) {\n\t\treturn str.replace(/:/g, function (str) {\n\t\t\treturn \"\\\\\" + str;\n\t\t});\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @param {*} elt\n\t*/\n\tfunction nullCheck(value, elt) {\n\t\tif (value == null) {\n\t\t\tthrow new Error(\"'\" + elt.sourceFor() + \"' is null\");\n\t\t}\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @returns {boolean}\n\t*/\n\tfunction isEmpty(value) {\n\t\treturn value == undefined || value.length === 0;\n\t}\n\n\t/**\n\t* @param {any} value\n\t* @returns {boolean}\n\t*/\n\tfunction doesExist(value) {\n\t\tif(value == null){\n\t\t\treturn false;\n\t\t}\n\t\tif (shouldAutoIterate(value)) {\n\t\t\tfor (const elt of value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t* @param {Node} node\n\t* @returns {Document|ShadowRoot}\n\t*/\n\tfunction getRootNode(node) {\n\t\tif (node && node instanceof Node) {\n\t\t\tvar rv = node.getRootNode();\n\t\t\tif (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n\t\t}\n\t\treturn document;\n\t}\n\n\t/**\n\t *\n\t * @param {Element} elt\n\t * @param {GrammarElement} onFeature\n\t * @returns {EventQueue}\n\t */\n\tfunction getEventQueueFor(elt, onFeature) {\n\t\tlet internalData = getInternalData(elt);\n\t\tvar eventQueuesForElt = internalData.eventQueues;\n\t\tif (eventQueuesForElt == null) {\n\t\t\teventQueuesForElt = new Map();\n\t\t\tinternalData.eventQueues = eventQueuesForElt;\n\t\t}\n\t\tvar eventQueueForFeature = eventQueuesForElt.get(onFeature);\n\t\tif (eventQueueForFeature == null) {\n\t\t\teventQueueForFeature = {queue:[], executing:false};\n\t\t\teventQueuesForElt.set(onFeature, eventQueueForFeature);\n\t\t}\n\t\treturn eventQueueForFeature;\n\t}\n\n\t/** @type string | null */\n\t// @ts-ignore\n\tvar hyperscriptUrl = \"document\" in globalScope ? import.meta.url : null;\n\n\t/** @type {RuntimeObject} */\n\treturn {\n\t\ttypeCheck,\n\t\tforEach,\n\t\timplicitLoop,\n\t\ttriggerEvent,\n\t\tmatchesSelector,\n\t\tgetScript,\n\t\tprocessNode,\n\t\tevaluate,\n\t\tevaluateNoPromise,\n\t\tparse,\n\t\tgetScriptSelector,\n\t\tresolveSymbol,\n\t\tsetSymbol,\n\t\tmakeContext,\n\t\tfindNext,\n\t\tunifiedEval,\n\t\tconvertValue,\n\t\tunifiedExec,\n\t\tresolveProperty,\n\t\tresolveAttribute,\n\t\tresolveStyle,\n\t\tresolveComputedStyle,\n\t\tassignToNamespace,\n\t\tregisterHyperTrace,\n\t\tgetHyperTrace,\n\t\tgetInternalData,\n\t\tgetHyperscriptFeatures,\n\t\tescapeSelector,\n\t\tnullCheck,\n\t\tisEmpty,\n\t\tdoesExist,\n\t\tgetRootNode,\n\t\tgetEventQueueFor,\n\t\thyperscriptUrl,\n\t\tHALT,\n\t};\n})();\n\n//====================================================================\n// Grammar\n//====================================================================\n{\n\t_parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar follows = tokens.clearFollow();\n\t\t\ttry {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.restoreFollow(follows);\n\t\t\t}\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn expr;\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n\t\tvar stringToken = tokens.matchTokenType(\"STRING\");\n\t\tif (!stringToken) return;\n\t\tvar rawValue = stringToken.value;\n\t\t/** @type {any[]} */\n\t\tvar args;\n\t\tif (stringToken.template) {\n\t\t\tvar innerTokens = _lexer.tokenize(rawValue, true);\n\t\t\targs = parser.parseStringTemplate(innerTokens);\n\t\t} else {\n\t\t\targs = [];\n\t\t}\n\t\treturn {\n\t\t\ttype: \"string\",\n\t\t\ttoken: stringToken,\n\t\t\targs: args,\n\t\t\top: function (context) {\n\t\t\t\tvar returnStr = \"\";\n\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\tvar val = arguments[i];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\treturnStr += val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnStr;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\tif (args.length === 0) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n\t\tif (tokens.hasMore()) {\n\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\treturn {\n\t\t\t\ttype: \"nakedString\",\n\t\t\t\ttokens: tokenArr,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn tokenArr\n\t\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join(\"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n\t\tvar number = tokens.matchTokenType(\"NUMBER\");\n\t\tif (!number) return;\n\t\tvar numberToken = number;\n\t\tvar value = parseFloat(number.value);\n\t\treturn {\n\t\t\ttype: \"number\",\n\t\t\tvalue: value,\n\t\t\tnumberToken: numberToken,\n\t\t\tevaluate: function () {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n\t\tvar elementId = tokens.matchTokenType(\"ID_REF\");\n\t\tif (!elementId) return;\n\t\t// TODO - unify these two expression types\n\t\tif (elementId.template) {\n\t\t\tvar templateValue = elementId.value.substr(2, elementId.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"idRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn runtime.getRootNode(context.me).getElementById(arg);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst value = elementId.value.substr(1);\n\t\t\treturn {\n\t\t\t\ttype: \"idRef\",\n\t\t\t\tcss: elementId.value,\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\truntime.getRootNode(context.me).getElementById(value)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n\t\tvar classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n\t\tif (!classRef) return;\n\n\t\t// TODO - unify these two expression types\n\t\tif (classRef.template) {\n\t\t\tvar templateValue = classRef.value.substr(2, classRef.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"classRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn new ElementCollection(\".\" + arg, context.me, true)\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst css = classRef.value;\n\t\t\treturn {\n\t\t\t\ttype: \"classRef\",\n\t\t\t\tcss: css,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn new ElementCollection(css, context.me, true)\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\tclass TemplatedQueryElementCollection extends ElementCollection {\n\t\tconstructor(css, relativeToElement, templateParts) {\n\t\t\tsuper(css, relativeToElement);\n\t\t\tthis.templateParts = templateParts;\n\t\t\tthis.elements = templateParts.filter(elt => elt instanceof Element);\n\t\t}\n\n\t\tget css() {\n\t\t\tlet rv = \"\", i = 0\n\t\t\tfor (const val of this.templateParts) {\n\t\t\t\tif (val instanceof Element) {\n\t\t\t\t\trv += \"[data-hs-query-id='\" + i++ + \"']\";\n\t\t\t\t} else rv += val;\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\tthis.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n\t\t\tconst rv = super[Symbol.iterator]();\n\t\t\tthis.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n\t\t\treturn rv;\n\t\t}\n\t}\n\n\t_parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n\t\tvar queryStart = tokens.matchOpToken(\"<\");\n\t\tif (!queryStart) return;\n\t\tvar queryTokens = tokens.consumeUntil(\"/\");\n\t\ttokens.requireOpToken(\"/\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar queryValue = queryTokens\n\t\t\t.map(function (t) {\n\t\t\t\tif (t.type === \"STRING\") {\n\t\t\t\t\treturn '\"' + t.value + '\"';\n\t\t\t\t} else {\n\t\t\t\t\treturn t.value;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\n\t\tif (queryValue.indexOf(\"$\") >= 0) {\n\t\t\tvar template = true;\n\t\t\tvar innerTokens = _lexer.tokenize(queryValue, true);\n\t\t\tvar args = parser.parseStringTemplate(innerTokens);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"queryRef\",\n\t\t\tcss: queryValue,\n\t\t\targs: args,\n\t\t\top: function (context, ...args) {\n\t\t\t\tif (template) {\n\t\t\t\t\treturn new TemplatedQueryElementCollection(queryValue, context.me, args)\n\t\t\t\t} else {\n\t\t\t\t\treturn new ElementCollection(queryValue, context.me)\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n\t\tvar attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n\t\tif (!attributeRef) return;\n\t\tvar outerVal = attributeRef.value;\n\t\tif (outerVal.indexOf(\"[\") === 0) {\n\t\t\tvar innerValue = outerVal.substring(2, outerVal.length - 1);\n\t\t} else {\n\t\t\tvar innerValue = outerVal.substring(1);\n\t\t}\n\t\tvar css = \"[\" + innerValue + \"]\";\n\t\tvar split = innerValue.split(\"=\");\n\t\tvar name = split[0];\n\t\tvar value = split[1];\n\t\tif (value) {\n\t\t\t// strip quotes\n\t\t\tif (value.indexOf('\"') === 0) {\n\t\t\t\tvalue = value.substring(1, value.length - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"attributeRef\",\n\t\t\tname: name,\n\t\t\tcss: css,\n\t\t\tvalue: value,\n\t\t\top: function (context) {\n\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\tif (target) {\n\t\t\t\t\treturn target.getAttribute(name);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"styleRef\", function (parser, runtime, tokens) {\n\t\tvar styleRef = tokens.matchTokenType(\"STYLE_REF\");\n\t\tif (!styleRef) return;\n\t\tvar styleProp = styleRef.value.substr(1);\n\t\tif (styleProp.startsWith(\"computed-\")) {\n\t\t\tstyleProp = styleProp.substr(\"computed-\".length);\n\t\t\treturn {\n\t\t\t\ttype: \"computedStyleRef\",\n\t\t\t\tname: styleProp,\n\t\t\t\top: function (context) {\n\t\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\treturn runtime.resolveComputedStyle(target, styleProp);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"styleRef\",\n\t\t\t\tname: styleProp,\n\t\t\t\top: function (context) {\n\t\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\t\tif (target) {\n\t\t\t\t\t\treturn runtime.resolveStyle(target, styleProp);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: token.value,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t} else if (tokens.matchOpToken(\"[\")) {\n\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\texpr: expr,\n\t\t\t\targs: [expr],\n\t\t\t\top: function (ctx, expr) {\n\t\t\t\t\treturn expr;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar key = \"\";\n\t\t\tdo {\n\t\t\t\ttoken = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n\t\t\t\tif (token) key += token.value;\n\t\t\t} while (token);\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: key,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn key;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\t\tvar keyExpressions = [];\n\t\tvar valueExpressions = [];\n\t\tif (!tokens.matchOpToken(\"}\")) {\n\t\t\tdo {\n\t\t\t\tvar name = parser.requireElement(\"objectKey\", tokens);\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tkeyExpressions.push(name);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"}\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"objectLiteral\",\n\t\t\targs: [keyExpressions, valueExpressions],\n\t\t\top: function (context, keys, values) {\n\t\t\t\tvar returnVal = {};\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\treturnVal[keys[i]] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedNamedArgumentList\", function (parser, runtime, tokens) {\n\t\tvar fields = [];\n\t\tvar valueExpressions = [];\n\t\tif (tokens.currentToken().type === \"IDENTIFIER\") {\n\t\t\tdo {\n\t\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tfields.push({ name: name, value: value });\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\t\treturn {\n\t\t\ttype: \"namedArgumentList\",\n\t\t\tfields: fields,\n\t\t\targs: [valueExpressions],\n\t\t\top: function (context, values) {\n\t\t\t\tvar returnVal = { _namedArgList_: true };\n\t\t\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\t\t\tvar field = fields[i];\n\t\t\t\t\treturnVal[field.name.value] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar elt = parser.requireElement(\"nakedNamedArgumentList\", tokens);\n\t\ttokens.requireOpToken(\")\");\n\t\treturn elt;\n\t});\n\n\t_parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n\t\t/** @type {SymbolScope} */\n\t\tvar scope = \"default\";\n\t\tif (tokens.matchToken(\"global\")) {\n\t\t\tscope = \"global\";\n\t\t} else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n\t\t\tscope = \"element\";\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.matchToken(\"local\")) {\n\t\t\tscope = \"local\";\n\t\t}\n\n\t\t// TODO better look ahead here\n\t\tlet eltPrefix = tokens.matchOpToken(\":\");\n\t\tlet identifier = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (identifier) {\n\t\t\tvar name = identifier.value;\n\t\t\tif (eltPrefix) {\n\t\t\t\tname = \":\" + name;\n\t\t\t}\n\t\t\tif (scope === \"default\") {\n\t\t\t\tif (name.indexOf(\"$\") === 0) {\n\t\t\t\t\tscope = \"global\";\n\t\t\t\t}\n\t\t\t\tif (name.indexOf(\":\") === 0) {\n\t\t\t\t\tscope = \"element\";\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"symbol\",\n\t\t\t\ttoken: identifier,\n\t\t\t\tscope: scope,\n\t\t\t\tname: name,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(name, context, scope);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n\t\treturn {\n\t\t\ttype: \"implicitMeTarget\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn context.beingTold || context.me;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n\t\tvar booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n\t\tif (!booleanLiteral) return;\n\t\tconst value = booleanLiteral.value === \"true\";\n\t\treturn {\n\t\t\ttype: \"boolean\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"null\")) {\n\t\t\treturn {\n\t\t\t\ttype: \"null\",\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar values = [];\n\t\tif (!tokens.matchOpToken(\"]\")) {\n\t\t\tdo {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalues.push(expr);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"arrayLiteral\",\n\t\t\tvalues: values,\n\t\t\targs: [values],\n\t\t\top: function (context, values) {\n\t\t\t\treturn values;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"\\\\\")) return;\n\t\tvar args = [];\n\t\tvar arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (arg1) {\n\t\t\targs.push(arg1);\n\t\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t}\n\t\t}\n\t\t// TODO compound op token\n\t\ttokens.requireOpToken(\"-\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\treturn {\n\t\t\ttype: \"blockLiteral\",\n\t\t\targs: args,\n\t\t\texpr: expr,\n\t\t\tevaluate: function (ctx) {\n\t\t\t\tvar returnFunc = function () {\n\t\t\t\t\t//TODO - push scope\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tctx[args[i].value] = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn expr.evaluate(ctx); //OK\n\t\t\t\t};\n\t\t\t\treturn returnFunc;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\".\")) return;\n\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\tvar propertyAccess = {\n\t\t\ttype: \"propertyAccess\",\n\t\t\troot: root,\n\t\t\tprop: prop,\n\t\t\targs: [root],\n\t\t\top: function (_context, rootVal) {\n\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"of\")) return;\n\t\tvar newRoot = parser.requireElement(\"expression\", tokens);\n\t\t// find the urroot\n\t\tvar childOfUrRoot = null;\n\t\tvar urRoot = root;\n\t\twhile (urRoot.root) {\n\t\t\tchildOfUrRoot = urRoot;\n\t\t\turRoot = urRoot.root;\n\t\t}\n\t\tif (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\" && urRoot.type !== \"styleRef\" && urRoot.type !== \"computedStyleRef\") {\n\t\t\tparser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n\t\t}\n\t\tvar attribute = urRoot.type === \"attributeRef\";\n\t\tvar style = urRoot.type === \"styleRef\" || urRoot.type === \"computedStyleRef\";\n\t\tif (attribute || style) {\n\t\t\tvar attributeElt = urRoot\n\t\t}\n\t\tvar prop = urRoot.name;\n\n\t\tvar propertyAccess = {\n\t\t\ttype: \"ofExpression\",\n\t\t\tprop: urRoot.token,\n\t\t\troot: newRoot,\n\t\t\tattribute: attributeElt,\n\t\t\texpression: root,\n\t\t\targs: [newRoot],\n\t\t\top: function (context, rootVal) {\n\t\t\t\tif (attribute) {\n\t\t\t\t\treturn runtime.resolveAttribute(rootVal, prop);\n\t\t\t\t} else if (style) {\n\t\t\t\t\tif (urRoot.type === \"computedStyleRef\") {\n\t\t\t\t\t\treturn runtime.resolveComputedStyle(rootVal, prop);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn runtime.resolveStyle(rootVal, prop);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.resolveProperty(rootVal, prop);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\tif (urRoot.type === \"attributeRef\") {\n\t\t\tpropertyAccess.attribute = urRoot;\n\t\t}\n\t\tif (childOfUrRoot) {\n\t\t\tchildOfUrRoot.root = propertyAccess;\n\t\t\tchildOfUrRoot.args = [propertyAccess];\n\t\t} else {\n\t\t\troot = propertyAccess;\n\t\t}\n\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, root);\n\t});\n\n\t_parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n\t\tif (parser.possessivesDisabled) {\n\t\t\treturn;\n\t\t}\n\t\tvar apostrophe = tokens.matchOpToken(\"'\");\n\t\tif (\n\t\t\tapostrophe ||\n\t\t\t(root.type === \"symbol\" &&\n\t\t\t\t(root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n\t\t\t\t(tokens.currentToken().type === \"IDENTIFIER\" || tokens.currentToken().type === \"ATTRIBUTE_REF\" || tokens.currentToken().type === \"STYLE_REF\"))\n\t\t) {\n\t\t\tif (apostrophe) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\t\tif (attribute == null) {\n\t\t\t\tvar style = parser.parseElement(\"styleRef\", tokens);\n\t\t\t\tif (style == null) {\n\t\t\t\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar propertyAccess = {\n\t\t\t\ttype: \"possessive\",\n\t\t\t\troot: root,\n\t\t\t\tattribute: attribute || style,\n\t\t\t\tprop: prop,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, rootVal) {\n\t\t\t\t\t/** @type {any} */\n\t\t\t\t\tlet value;\n\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalue = runtime.resolveAttribute(rootVal, attribute.name);\n\t\t\t\t\t} else if (style) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tif (style.type === 'computedStyleRef') {\n\t\t\t\t\t\t\tvalue = runtime.resolveComputedStyle(rootVal, style.name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = runtime.resolveStyle(rootVal, style.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvalue = runtime.resolveProperty(rootVal, prop.value);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t\t}\n\t});\n\n\t_parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"in\")) return;\n\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\tvar propertyAccess = {\n\t\t\ttype: \"inExpression\",\n\t\t\troot: root,\n\t\t\targs: [root, target],\n\t\t\top: function (context, rootVal, target) {\n\t\t\t\tvar returnArr = [];\n\t\t\t\tif (rootVal.css) {\n\t\t\t\t\truntime.implicitLoop(target, function (targetElt) {\n\t\t\t\t\t\tvar results = targetElt.querySelectorAll(rootVal.css);\n\t\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\treturnArr.push(results[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else if (rootVal instanceof Element) {\n\t\t\t\t\tvar within = false;\n\t\t\t\t\truntime.implicitLoop(target, function (targetElt) {\n\t\t\t\t\t\tif (targetElt.contains(rootVal)) {\n\t\t\t\t\t\t\twithin = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif(within) {\n\t\t\t\t\t\treturn rootVal;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\truntime.implicitLoop(rootVal, function (rootElt) {\n\t\t\t\t\t\truntime.implicitLoop(target, function (targetElt) {\n\t\t\t\t\t\t\tif (rootElt === targetElt) {\n\t\t\t\t\t\t\t\treturnArr.push(rootElt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (returnArr.length > 0) {\n\t\t\t\t\treturn returnArr;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"as\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\t\tvar conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n\t\tvar propertyAccess = {\n\t\t\ttype: \"asExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, rootVal) {\n\t\t\t\treturn runtime.convertValue(rootVal, conversion);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar args = [];\n\t\tif (!tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\n\t\tif (root.root) {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root.root, args],\n\t\t\t\top: function (context, rootRoot, args) {\n\t\t\t\t\truntime.nullCheck(rootRoot, root.root);\n\t\t\t\t\tvar func = rootRoot[root.prop.value];\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targs.push(context);\n\t\t\t\t\t}\n\t\t\t\t\treturn func.apply(rootRoot, args);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root, args],\n\t\t\t\top: function (context, func, argVals) {\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targVals.push(context);\n\t\t\t\t\t}\n\t\t\t\t\tvar apply = func.apply(null, argVals);\n\t\t\t\t\treturn apply;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, functionCall);\n\t});\n\n\t_parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\tif (!attribute) return;\n\t\tvar attributeAccess = {\n\t\t\ttype: \"attributeRefAccess\",\n\t\t\troot: root,\n\t\t\tattribute: attribute,\n\t\t\targs: [root],\n\t\t\top: function (_ctx, rootVal) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar value = runtime.resolveAttribute(rootVal, attribute.name);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn attributeAccess;\n\t});\n\n\t_parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar andBefore = false;\n\t\tvar andAfter = false;\n\t\tvar firstIndex = null;\n\t\tvar secondIndex = null;\n\n\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\tandBefore = true;\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\n\t\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\t\tandAfter = true;\n\t\t\t\tvar current = tokens.currentToken();\n\t\t\t\tif (current.type !== \"R_BRACKET\") {\n\t\t\t\t\tsecondIndex = parser.parseElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttokens.requireOpToken(\"]\");\n\n\t\tvar arrayIndex = {\n\t\t\ttype: \"arrayIndex\",\n\t\t\troot: root,\n\t\t\tfirstIndex: firstIndex,\n\t\t\tsecondIndex: secondIndex,\n\t\t\targs: [root, firstIndex, secondIndex],\n\t\t\top: function (_ctx, root, firstIndex, secondIndex) {\n\t\t\t\tif (andBefore) {\n\t\t\t\t\treturn root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n\t\t\t\t} else if (andAfter) {\n\t\t\t\t\tif (secondIndex != null) {\n\t\t\t\t\t\treturn root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root.slice(firstIndex); // returns from firstIndex to end of array\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn root[firstIndex];\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\treturn _parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n\t});\n\n\t// taken from https://drafts.csswg.org/css-values-4/#relative-length\n\t//        and https://drafts.csswg.org/css-values-4/#absolute-length\n\t//        (NB: we do not support `in` dues to conflicts w/ the hyperscript grammar)\n\tvar STRING_POSTFIXES = [\n\t\t'em', 'ex', 'cap', 'ch', 'ic', 'rem', 'lh', 'rlh', 'vw', 'vh', 'vi', 'vb', 'vmin', 'vmax',\n\t\t'cm', 'mm', 'Q', 'pc', 'pt', 'px'\n\t];\n\t_parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n\t\tvar root = parser.parseElement(\"primaryExpression\", tokens);\n\n\t\tlet stringPosfix = tokens.matchAnyToken.apply(tokens, STRING_POSTFIXES) || tokens.matchOpToken(\"%\");\n\t\tif (stringPosfix) {\n\t\t\treturn {\n\t\t\t\ttype: \"stringPostfix\",\n\t\t\t\tpostfix: stringPosfix.value,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, val) {\n\t\t\t\t\treturn \"\" + val + stringPosfix.value;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tvar timeFactor = null;\n\t\tif (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n\t\t\ttimeFactor = 1000;\n\t\t} else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n\t\t\ttimeFactor = 1;\n\t\t}\n\t\tif (timeFactor) {\n\t\t\treturn {\n\t\t\t\ttype: \"timeExpression\",\n\t\t\t\ttime: root,\n\t\t\t\tfactor: timeFactor,\n\t\t\t\targs: [root],\n\t\t\t\top: function (_context, val) {\n\t\t\t\t\treturn val * timeFactor;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\treturn {\n\t\t\t\ttype: \"typeCheck\",\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, val) {\n\t\t\t\t\tvar passed = runtime.typeCheck(val, typeName.value, nullOk);\n\t\t\t\t\tif (passed) {\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn root;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"not\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"logicalNot\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, val) {\n\t\t\t\treturn !val;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"no\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"noExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn runtime.isEmpty(val);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"some\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"some\")) return;\n\t\tvar root = parser.requireElement(\"expression\", tokens);\n\t\treturn {\n\t\t\ttype: \"noExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn !runtime.isEmpty(val);\n\t\t\t},\n\t\t\tevaluate(context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"-\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"negativeNumber\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, value) {\n\t\t\t\treturn -1 * value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf(\n\t\t\t[\"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n\t\t\ttokens\n\t\t);\n\t});\n\n\tvar scanForwardQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[0];\n\t\t}\n\t}\n\n\tvar scanBackwardsQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = results.length - 1; i >= 0; i--) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[results.length - 1];\n\t\t}\n\t}\n\n\tvar scanForwardArray = function(start, array, match, wrap) {\n\t\tvar matches = [];\n\t\t_runtime.forEach(array, function(elt){\n\t\t\tif (elt.matches(match) || elt === start) {\n\t\t\t\tmatches.push(elt);\n\t\t\t}\n\t\t})\n\t\tfor (var i = 0; i < matches.length - 1; i++) {\n\t\t\tvar elt = matches[i];\n\t\t\tif (elt === start) {\n\t\t\t\treturn matches[i + 1];\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\tvar first = matches[0];\n\t\t\tif (first && first.matches(match)) {\n\t\t\t\treturn first;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar scanBackwardsArray = function(start, array, match, wrap) {\n\t\treturn scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n\t}\n\n\t_parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"next\", \"previous\");\n\t\tif (!op) return;\n\t\tif (op.value === \"next\") {\n\t\t\tvar forwardSearch = true;\n\t\t}\n\n\t\tvar thing = parser.parseElement(\"expression\", tokens);\n\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\ttokens.pushFollow(\"in\");\n\t\t\ttry {\n\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.popFollow();\n\t\t\t}\n\t\t} else {\n\t\t\tvar from = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar inSearch = false;\n\t\tvar withinElt;\n\t\tif (tokens.matchToken(\"in\")) {\n\t\t\tinSearch = true;\n\t\t\tvar inElt = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"within\")) {\n\t\t\twithinElt = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\twithinElt = document.body;\n\t\t}\n\n\t\tvar wrapping = false;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\ttokens.requireToken(\"wrapping\")\n\t\t\twrapping = true;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"relativePositionalExpression\",\n\t\t\tfrom: from,\n\t\t\tforwardSearch: forwardSearch,\n\t\t\tinSearch: inSearch,\n\t\t\twrapping: wrapping,\n\t\t\tinElt: inElt,\n\t\t\twithinElt: withinElt,\n\t\t\toperator: op.value,\n\t\t\targs: [thing, from, inElt, withinElt],\n\t\t\top: function (context, thing, from, inElt, withinElt) {\n\n\t\t\t\tvar css = thing.css;\n\t\t\t\tif (css == null) {\n\t\t\t\t\tthrow \"Expected a CSS value\";\n\t\t\t\t}\n\n\t\t\t\tif(inSearch) {\n\t\t\t\t\tif (inElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (withinElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t}\n\n\t});\n\n\t_parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n\t\tif (!op) return;\n\t\ttokens.matchAnyToken(\"in\", \"from\", \"of\");\n\t\tvar rhs = parser.requireElement(\"unaryExpression\", tokens);\n\t\tconst operator = op.value;\n\t\treturn {\n\t\t\ttype: \"positionalExpression\",\n\t\t\trhs: rhs,\n\t\t\toperator: op.value,\n\t\t\targs: [rhs],\n\t\t\top: function (context, rhsVal) {\n\t\t\t\tif (rhsVal && !Array.isArray(rhsVal)) {\n\t\t\t\t\tif (rhsVal.children) {\n\t\t\t\t\t\trhsVal = rhsVal.children;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trhsVal = Array.from(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rhsVal) {\n\t\t\t\t\tif (operator === \"first\") {\n\t\t\t\t\t\treturn rhsVal[0];\n\t\t\t\t\t} else if (operator === \"last\") {\n\t\t\t\t\t\treturn rhsVal[rhsVal.length - 1];\n\t\t\t\t\t} else if (operator === \"random\") {\n\t\t\t\t\t\treturn rhsVal[Math.floor(Math.random() * rhsVal.length)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"unaryExpression\", tokens);\n\t\tvar mathOp,\n\t\t\tinitialMathOp = null;\n\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\twhile (mathOp) {\n\t\t\tinitialMathOp = initialMathOp || mathOp;\n\t\t\tvar operator = mathOp.value;\n\t\t\tif (initialMathOp.value !== operator) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.parseElement(\"unaryExpression\", tokens);\n\t\t\texpr = {\n\t\t\t\ttype: \"mathOperator\",\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\toperator: operator,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"+\") {\n\t\t\t\t\t\treturn lhsVal + rhsVal;\n\t\t\t\t\t} else if (operator === \"-\") {\n\t\t\t\t\t\treturn lhsVal - rhsVal;\n\t\t\t\t\t} else if (operator === \"*\") {\n\t\t\t\t\t\treturn lhsVal * rhsVal;\n\t\t\t\t\t} else if (operator === \"/\") {\n\t\t\t\t\t\treturn lhsVal / rhsVal;\n\t\t\t\t\t} else if (operator === \"%\") {\n\t\t\t\t\t\treturn lhsVal % rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n\t});\n\n\tfunction sloppyContains(src, container, value){\n\t\tif (container['contains']) {\n\t\t\treturn container.contains(value);\n\t\t} else if (container['includes']) {\n\t\t\treturn container.includes(value);\n\t\t} else {\n\t\t\tthrow Error(\"The value of \" + src.sourceFor() + \" does not have a contains or includes method on it\");\n\t\t}\n\t}\n\tfunction sloppyMatches(src, target, toMatch){\n\t\tif (target['match']) {\n\t\t\treturn !!target.match(toMatch);\n\t\t} else if (target['matches']) {\n\t\t\treturn target.matches(toMatch);\n\t\t} else {\n\t\t\tthrow Error(\"The value of \" + src.sourceFor() + \" does not have a match or matches method on it\");\n\t\t}\n\t}\n\n\t_parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"mathExpression\", tokens);\n\t\tvar comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n\t\tvar operator = comparisonToken ? comparisonToken.value : null;\n\t\tvar hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n\t\tvar typeCheck = false;\n\n\t\tif (operator == null) {\n\t\t\tif (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n\t\t\t\tif (tokens.matchToken(\"not\")) {\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\toperator = \"not in\";\n\t\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\t\toperator = \"not a\";\n\t\t\t\t\t\ttypeCheck = true;\n\t\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\t\toperator = \"not empty\";\n\t\t\t\t\t\thasRightValue = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"!=\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\t\t\toperator = \"in\";\n\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\toperator = \"a\";\n\t\t\t\t\ttypeCheck = true;\n\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\toperator = \"empty\";\n\t\t\t\t\thasRightValue = false;\n\t\t\t\t} else if (tokens.matchToken(\"less\")) {\n\t\t\t\t\ttokens.requireToken(\"than\");\n\t\t\t\t\tif (tokens.matchToken(\"or\")) {\n\t\t\t\t\t\ttokens.requireToken(\"equal\");\n\t\t\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\t\t\toperator = \"<=\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"<\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"greater\")) {\n\t\t\t\t\ttokens.requireToken(\"than\");\n\t\t\t\t\tif (tokens.matchToken(\"or\")) {\n\t\t\t\t\t\ttokens.requireToken(\"equal\");\n\t\t\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\t\t\toperator = \">=\";\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \">\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\toperator = \"==\";\n\t\t\t\t}\n\t\t\t} else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exists\")) {\n\t\t\t\toperator = \"exist\";\n\t\t\t\thasRightValue = false;\n\t\t\t} else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\toperator = \"match\";\n\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\toperator = \"contain\";\n\t\t\t} else if (tokens.matchToken(\"includes\") || tokens.matchToken(\"include\")) {\n\t\t\t\toperator = \"include\";\n\t\t\t} else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n\t\t\t\ttokens.requireToken(\"not\");\n\t\t\t\tif (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\t\toperator = \"not match\";\n\t\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\t\toperator = \"not contain\";\n\t\t\t\t} else if (tokens.matchToken(\"exist\") || tokens.matchToken(\"exist\")) {\n\t\t\t\t\toperator = \"not exist\";\n\t\t\t\t\thasRightValue = false;\n\t\t\t\t} else if (tokens.matchToken(\"include\")) {\n\t\t\t\t\toperator = \"not include\";\n\t\t\t\t} else {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected matches or contains\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (operator) {\n\t\t\t// Do not allow chained comparisons, which is dumb\n\t\t\tif (typeCheck) {\n\t\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\t} else if (hasRightValue) {\n\t\t\t\tvar rhs = parser.requireElement(\"mathExpression\", tokens);\n\t\t\t\tif (operator === \"match\" || operator === \"not match\") {\n\t\t\t\t\trhs = rhs.css ? rhs.css : rhs;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar lhs = expr;\n\t\t\texpr = {\n\t\t\t\ttype: \"comparisonOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"==\") {\n\t\t\t\t\t\treturn lhsVal == rhsVal;\n\t\t\t\t\t} else if (operator === \"!=\") {\n\t\t\t\t\t\treturn lhsVal != rhsVal;\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"match\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyMatches(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not match\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyMatches(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"in\") {\n\t\t\t\t\t\treturn rhsVal != null && sloppyContains(rhs, rhsVal, lhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not in\") {\n\t\t\t\t\t\treturn rhsVal == null || !sloppyContains(rhs, rhsVal, lhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"contain\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not contain\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"include\") {\n\t\t\t\t\t\treturn lhsVal != null && sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not include\") {\n\t\t\t\t\t\treturn lhsVal == null || !sloppyContains(lhs, lhsVal, rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"===\") {\n\t\t\t\t\t\treturn lhsVal === rhsVal;\n\t\t\t\t\t} else if (operator === \"!==\") {\n\t\t\t\t\t\treturn lhsVal !== rhsVal;\n\t\t\t\t\t} else if (operator === \"<\") {\n\t\t\t\t\t\treturn lhsVal < rhsVal;\n\t\t\t\t\t} else if (operator === \">\") {\n\t\t\t\t\t\treturn lhsVal > rhsVal;\n\t\t\t\t\t} else if (operator === \"<=\") {\n\t\t\t\t\t\treturn lhsVal <= rhsVal;\n\t\t\t\t\t} else if (operator === \">=\") {\n\t\t\t\t\t\treturn lhsVal >= rhsVal;\n\t\t\t\t\t} else if (operator === \"empty\") {\n\t\t\t\t\t\treturn runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"not empty\") {\n\t\t\t\t\t\treturn !runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"exist\") {\n\t\t\t\t\t\treturn runtime.doesExist(lhsVal);\n\t\t\t\t\t} else if (operator === \"not exist\") {\n\t\t\t\t\t\treturn !runtime.doesExist(lhsVal);\n\t\t\t\t\t} else if (operator === \"a\") {\n\t\t\t\t\t\treturn runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else if (operator === \"not a\") {\n\t\t\t\t\t\treturn !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Unknown comparison : \" + operator;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"comparisonExpression\", tokens);\n\t\tvar logicalOp,\n\t\t\tinitialLogicalOp = null;\n\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\twhile (logicalOp) {\n\t\t\tinitialLogicalOp = initialLogicalOp || logicalOp;\n\t\t\tif (initialLogicalOp.value !== logicalOp.value) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.requireElement(\"comparisonExpression\", tokens);\n\t\t\tconst operator = logicalOp.value;\n\t\t\texpr = {\n\t\t\t\ttype: \"logicalOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"and\") {\n\t\t\t\t\t\treturn lhsVal && rhsVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn lhsVal || rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"async\")) {\n\t\t\tvar value = parser.requireElement(\"logicalExpression\", tokens);\n\t\t\tvar expr = {\n\t\t\t\ttype: \"asyncExpression\",\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tasyncWrapper: true,\n\t\t\t\t\t\tvalue: this.value.evaluate(context), //OK\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn expr;\n\t\t} else {\n\t\t\treturn parser.parseElement(\"logicalExpression\", tokens);\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\t\treturn parser.parseElement(\"asyncExpression\", tokens);\n\t});\n\n\t_parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\n\t\t// TODO obviously we need to generalize this as a left hand side / targetable concept\n\t\tvar expr = parser.parseElement(\"primaryExpression\", tokens);\n\t\tif (expr && (\n\t\t\texpr.type === \"symbol\" ||\n\t\t\texpr.type === \"ofExpression\" ||\n\t\t\texpr.type === \"propertyAccess\" ||\n\t\t\texpr.type === \"attributeRefAccess\" ||\n\t\t\texpr.type === \"attributeRef\" ||\n\t\t\texpr.type === \"styleRef\" ||\n\t\t\texpr.type === \"possessive\")\n\t\t) {\n\t\t\treturn expr;\n\t\t} else {\n\t\t\t_parser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n\t\t\t);\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n\t\tvar features = [];\n\n\t\tif (tokens.hasMore()) {\n\t\t\twhile (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n\t\t\t\tvar feature = parser.requireElement(\"feature\", tokens);\n\t\t\t\tfeatures.push(feature);\n\t\t\t\ttokens.matchToken(\"end\"); // optional end\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"hyperscript\",\n\t\t\tfeatures: features,\n\t\t\tapply: function (target, source, args) {\n\t\t\t\t// no op\n\t\t\t\tfor (const feature of features) {\n\t\t\t\t\tfeature.install(target, source, args);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\tvar parseEventArgs = function (tokens) {\n\t\tvar args = [];\n\t\t// handle argument list (look ahead 3)\n\t\tif (\n\t\t\ttokens.token(0).value === \"(\" &&\n\t\t\t(tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n\t\t) {\n\t\t\ttokens.matchOpToken(\"(\");\n\t\t\tdo {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\treturn args;\n\t};\n\n\t_parser.addFeature(\"on\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"on\")) return;\n\t\tvar every = false;\n\t\tif (tokens.matchToken(\"every\")) {\n\t\t\tevery = true;\n\t\t}\n\t\tvar events = [];\n\t\tvar displayName = null;\n\t\tdo {\n\t\t\tvar on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n\t\t\tvar eventName = on.evaluate(); // OK No Promise\n\n\t\t\tif (displayName) {\n\t\t\t\tdisplayName = displayName + \" or \" + eventName;\n\t\t\t} else {\n\t\t\t\tdisplayName = \"on \" + eventName;\n\t\t\t}\n\t\t\tvar args = parseEventArgs(tokens);\n\n\t\t\tvar filter = null;\n\t\t\tif (tokens.matchOpToken(\"[\")) {\n\t\t\t\tfilter = parser.requireElement(\"expression\", tokens);\n\t\t\t\ttokens.requireOpToken(\"]\");\n\t\t\t}\n\n\t\t\tif (tokens.currentToken().type === \"NUMBER\") {\n\t\t\t\tvar startCountToken = tokens.consumeToken();\n\t\t\t\tvar startCount = parseInt(startCountToken.value);\n\t\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\t\tvar endCountToken = tokens.consumeToken();\n\t\t\t\t\tvar endCount = parseInt(endCountToken.value);\n\t\t\t\t} else if (tokens.matchToken(\"and\")) {\n\t\t\t\t\tvar unbounded = true;\n\t\t\t\t\ttokens.requireToken(\"on\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eventName === \"intersection\") {\n\t\t\t\tvar intersectionSpec = {};\n\t\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\t\tintersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t}\n\t\t\t\tif (tokens.matchToken(\"having\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"margin\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n\t\t\t\t\t\t} else if (tokens.matchToken(\"threshold\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown intersection config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"and\"));\n\t\t\t\t}\n\t\t\t} else if (eventName === \"mutation\") {\n\t\t\t\tvar mutationSpec = {};\n\t\t\t\tif (tokens.matchToken(\"of\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"anything\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"childList\")) {\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"attributes\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"attributeOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"subtree\")) {\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"characterData\")) {\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterDataOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\t\t\t\tvar attribute = tokens.consumeToken();\n\t\t\t\t\t\t\tif (mutationSpec[\"attributeFilter\"] == null) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (attribute.value.indexOf(\"@\") == 0) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\t\t\"Only shorthand attribute references are allowed here\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown mutation config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"or\"));\n\t\t\t\t} else {\n\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar from = null;\n\t\t\tvar elsewhere = false;\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tif (tokens.matchToken(\"elsewhere\")) {\n\t\t\t\t\telsewhere = true;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (!from) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// support both \"elsewhere\" and \"from elsewhere\"\n\t\t\tif (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n\t\t\t\telsewhere = true;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\tvar inExpr = parser.parseAnyOf([\"idRef\", \"queryRef\", \"classRef\"], tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"debounced\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t} else if (tokens.matchToken(\"throttled\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t}\n\n\t\t\tevents.push({\n\t\t\t\texecCount: 0,\n\t\t\t\tevery: every,\n\t\t\t\ton: eventName,\n\t\t\t\targs: args,\n\t\t\t\tfilter: filter,\n\t\t\t\tfrom: from,\n\t\t\t\tinExpr: inExpr,\n\t\t\t\telsewhere: elsewhere,\n\t\t\t\tstartCount: startCount,\n\t\t\t\tendCount: endCount,\n\t\t\t\tunbounded: unbounded,\n\t\t\t\tdebounceTime: debounceTime,\n\t\t\t\tthrottleTime: throttleTime,\n\t\t\t\tmutationSpec: mutationSpec,\n\t\t\t\tintersectionSpec: intersectionSpec,\n\t\t\t\tdebounced: undefined,\n\t\t\t\tlastExec: undefined,\n\t\t\t});\n\t\t} while (tokens.matchToken(\"or\"));\n\n\t\tvar queueLast = true;\n\t\tif (!every) {\n\t\t\tif (tokens.matchToken(\"queue\")) {\n\t\t\t\tif (tokens.matchToken(\"all\")) {\n\t\t\t\t\tvar queueAll = true;\n\t\t\t\t\tvar queueLast = false;\n\t\t\t\t} else if (tokens.matchToken(\"first\")) {\n\t\t\t\t\tvar queueFirst = true;\n\t\t\t\t} else if (tokens.matchToken(\"none\")) {\n\t\t\t\t\tvar queueNone = true;\n\t\t\t\t} else {\n\t\t\t\t\ttokens.requireToken(\"last\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\t\tparser.ensureTerminated(start);\n\n\t\tif (tokens.matchToken(\"catch\")) {\n\t\t\tvar errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\tvar errorHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tparser.ensureTerminated(errorHandler);\n\t\t}\n\n\t\tif (tokens.matchToken(\"finally\")) {\n\t\t\tvar finallyHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tparser.ensureTerminated(finallyHandler);\n\t\t}\n\n\t\tvar onFeature = {\n\t\t\tdisplayName: displayName,\n\t\t\tevents: events,\n\t\t\tstart: start,\n\t\t\tevery: every,\n\t\t\texecCount: 0,\n\t\t\terrorHandler: errorHandler,\n\t\t\terrorSymbol: errorSymbol,\n\t\t\texecute: function (/** @type {Context} */ ctx) {\n\t\t\t\tlet eventQueueInfo = runtime.getEventQueueFor(ctx.me, onFeature);\n\t\t\t\tif (eventQueueInfo.executing && every === false) {\n\t\t\t\t\tif (queueNone || (queueFirst && eventQueueInfo.queue.length > 0)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (queueLast) {\n\t\t\t\t\t\teventQueueInfo.queue.length = 0;\n\t\t\t\t\t}\n\t\t\t\t\teventQueueInfo.queue.push(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonFeature.execCount++;\n\t\t\t\teventQueueInfo.executing = true;\n\t\t\t\tctx.meta.onHalt = function () {\n\t\t\t\t\teventQueueInfo.executing = false;\n\t\t\t\t\tvar queued = eventQueueInfo.queue.shift();\n\t\t\t\t\tif (queued) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tonFeature.execute(queued);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tctx.meta.reject = function (err) {\n\t\t\t\t\tconsole.error(err.message ? err.message : err);\n\t\t\t\t\tvar hypertrace = runtime.getHyperTrace(ctx, err);\n\t\t\t\t\tif (hypertrace) {\n\t\t\t\t\t\thypertrace.print();\n\t\t\t\t\t}\n\t\t\t\t\truntime.triggerEvent(ctx.me, \"exception\", {\n\t\t\t\t\t\terror: err,\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tstart.execute(ctx);\n\t\t\t},\n\t\t\tinstall: function (elt, source) {\n\t\t\t\tfor (const eventSpec of onFeature.events) {\n\t\t\t\t\tvar targets;\n\t\t\t\t\tif (eventSpec.elsewhere) {\n\t\t\t\t\t\ttargets = [document];\n\t\t\t\t\t} else if (eventSpec.from) {\n\t\t\t\t\t\ttargets = eventSpec.from.evaluate(runtime.makeContext(elt, onFeature, elt, null));\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargets = [elt];\n\t\t\t\t\t}\n\t\t\t\t\truntime.implicitLoop(targets, function (target) {\n\t\t\t\t\t\t// OK NO PROMISE\n\n\t\t\t\t\t\tvar eventName = eventSpec.on;\n\t\t\t\t\t\tif (eventSpec.mutationSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:mutation\";\n\t\t\t\t\t\t\tconst observer = new MutationObserver(function (mutationList, observer) {\n\t\t\t\t\t\t\t\tif (!onFeature.executing) {\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, {\n\t\t\t\t\t\t\t\t\t\tmutationList: mutationList,\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tobserver.observe(target, eventSpec.mutationSpec);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eventSpec.intersectionSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:insersection\";\n\t\t\t\t\t\t\tconst observer = new IntersectionObserver(function (entries) {\n\t\t\t\t\t\t\t\tfor (const entry of entries) {\n\t\t\t\t\t\t\t\t\tvar detail = {\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tdetail = mergeObjects(detail, entry);\n\t\t\t\t\t\t\t\t\tdetail[\"intersecting\"] = entry.isIntersecting;\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, detail);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, eventSpec.intersectionSpec);\n\t\t\t\t\t\t\tobserver.observe(target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar addEventListener = target.addEventListener || target.on;\n\t\t\t\t\t\taddEventListener.call(target, eventName, function listener(evt) {\n\t\t\t\t\t\t\t// OK NO PROMISE\n\t\t\t\t\t\t\tif (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n\t\t\t\t\t\t\t\ttarget.removeEventListener(eventName, listener);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar ctx = runtime.makeContext(elt, onFeature, elt, evt);\n\t\t\t\t\t\t\tif (eventSpec.elsewhere && elt.contains(evt.target)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (eventSpec.from) {\n\t\t\t\t\t\t\t\tctx.result = target;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// establish context\n\t\t\t\t\t\t\tfor (const arg of eventSpec.args) {\n\t\t\t\t\t\t\t\tctx[arg.value] =\n\t\t\t\t\t\t\t\t\tctx.event[arg.value] || ('detail' in ctx.event ? ctx.event['detail'][arg.value] : null);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// install error handler if any\n\t\t\t\t\t\t\tctx.meta.errorHandler = errorHandler;\n\t\t\t\t\t\t\tctx.meta.errorSymbol = errorSymbol;\n\t\t\t\t\t\t\tctx.meta.finallyHandler = finallyHandler;\n\n\t\t\t\t\t\t\t// apply filter\n\t\t\t\t\t\t\tif (eventSpec.filter) {\n\t\t\t\t\t\t\t\tvar initialCtx = ctx.meta.context;\n\t\t\t\t\t\t\t\tctx.meta.context = ctx.event;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tvar value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n\t\t\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\t\t\t// match the javascript semantics for if statements\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tctx.meta.context = initialCtx;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (eventSpec.inExpr) {\n\t\t\t\t\t\t\t\tvar inElement = evt.target;\n\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\tif (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n\t\t\t\t\t\t\t\t\t\tctx.result = inElement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tinElement = inElement.parentElement;\n\t\t\t\t\t\t\t\t\t\tif (inElement == null) {\n\t\t\t\t\t\t\t\t\t\t\treturn; // no match found\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// verify counts\n\t\t\t\t\t\t\teventSpec.execCount++;\n\t\t\t\t\t\t\tif (eventSpec.startCount) {\n\t\t\t\t\t\t\t\tif (eventSpec.endCount) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount < eventSpec.startCount ||\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount > eventSpec.endCount\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.unbounded) {\n\t\t\t\t\t\t\t\t\tif (eventSpec.execCount < eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.execCount !== eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//debounce\n\t\t\t\t\t\t\tif (eventSpec.debounceTime) {\n\t\t\t\t\t\t\t\tif (eventSpec.debounced) {\n\t\t\t\t\t\t\t\t\tclearTimeout(eventSpec.debounced);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teventSpec.debounced = setTimeout(function () {\n\t\t\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t\t\t}, eventSpec.debounceTime);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// throttle\n\t\t\t\t\t\t\tif (eventSpec.throttleTime) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\teventSpec.lastExec &&\n\t\t\t\t\t\t\t\t\tDate.now() < eventSpec.lastExec + eventSpec.throttleTime\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teventSpec.lastExec = Date.now();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply execute\n\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(start, onFeature);\n\t\treturn onFeature;\n\t});\n\n\t_parser.addFeature(\"def\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"def\")) return;\n\t\tvar functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\tvar nameVal = functionName.evaluate(); // OK\n\t\tvar nameSpace = nameVal.split(\".\");\n\t\tvar funcName = nameSpace.pop();\n\n\t\tvar args = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// emtpy args list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\n\t\tif (tokens.matchToken(\"catch\")) {\n\t\t\tvar errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\tvar errorHandler = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\n\t\tif (tokens.matchToken(\"finally\")) {\n\t\t\tvar finallyHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tparser.ensureTerminated(finallyHandler);\n\t\t}\n\n\t\tvar functionFeature = {\n\t\t\tdisplayName:\n\t\t\t\tfuncName +\n\t\t\t\t\"(\" +\n\t\t\t\targs\n\t\t\t\t\t.map(function (arg) {\n\t\t\t\t\t\treturn arg.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\", \") +\n\t\t\t\t\")\",\n\t\t\tname: funcName,\n\t\t\targs: args,\n\t\t\tstart: start,\n\t\t\terrorHandler: errorHandler,\n\t\t\terrorSymbol: errorSymbol,\n\t\t\tfinallyHandler: finallyHandler,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tvar func = function () {\n\t\t\t\t\t// null, worker\n\t\t\t\t\tvar ctx = runtime.makeContext(source, functionFeature, target, null);\n\n\t\t\t\t\t// install error handler if any\n\t\t\t\t\tctx.meta.errorHandler = errorHandler;\n\t\t\t\t\tctx.meta.errorSymbol = errorSymbol;\n\t\t\t\t\tctx.meta.finallyHandler = finallyHandler;\n\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tvar name = args[i];\n\t\t\t\t\t\tvar argumentVal = arguments[i];\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tctx[name.value] = argumentVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.meta.caller = arguments[args.length];\n\t\t\t\t\tif (ctx.meta.caller) {\n\t\t\t\t\t\tctx.meta.callingCommand = ctx.meta.caller.meta.command;\n\t\t\t\t\t}\n\t\t\t\t\tvar resolve,\n\t\t\t\t\t\treject = null;\n\t\t\t\t\tvar promise = new Promise(function (theResolve, theReject) {\n\t\t\t\t\t\tresolve = theResolve;\n\t\t\t\t\t\treject = theReject;\n\t\t\t\t\t});\n\t\t\t\t\tstart.execute(ctx);\n\t\t\t\t\tif (ctx.meta.returned) {\n\t\t\t\t\t\treturn ctx.meta.returnValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.meta.resolve = resolve;\n\t\t\t\t\t\tctx.meta.reject = reject;\n\t\t\t\t\t\treturn promise;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfunc.hyperfunc = true;\n\t\t\t\tfunc.hypername = nameVal;\n\t\t\t\truntime.assignToNamespace(target, nameSpace, funcName, func);\n\t\t\t},\n\t\t};\n\n\t\tparser.ensureTerminated(start);\n\n\t\t// terminate error handler if any\n\t\tif (errorHandler) {\n\t\t\tparser.ensureTerminated(errorHandler);\n\t\t}\n\n\t\tparser.setParent(start, functionFeature);\n\t\treturn functionFeature;\n\t});\n\n\t_parser.addFeature(\"set\", function (parser, runtime, tokens) {\n\t\tlet setCmd = parser.parseElement(\"setCommand\", tokens);\n\t\tif (setCmd) {\n\t\t\tif (setCmd.target.scope !== \"element\") {\n\t\t\t\tparser.raiseParseError(tokens, \"variables declared at the feature level must be element scoped.\");\n\t\t\t}\n\t\t\tlet setFeature = {\n\t\t\t\tstart: setCmd,\n\t\t\t\tinstall: function (target, source) {\n\t\t\t\t\tsetCmd && setCmd.execute(runtime.makeContext(target, setFeature, target, null));\n\t\t\t\t},\n\t\t\t};\n\t\t\tparser.ensureTerminated(setCmd);\n\t\t\treturn setFeature;\n\t\t}\n\t});\n\n\t_parser.addFeature(\"init\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"init\")) return;\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\t\tvar initFeature = {\n\t\t\tstart: start,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tstart && start.execute(runtime.makeContext(target, initFeature, target, null));\n\t\t\t\t}, 0);\n\t\t\t},\n\t\t};\n\n\t\t// terminate body\n\t\tparser.ensureTerminated(start);\n\t\tparser.setParent(start, initFeature);\n\t\treturn initFeature;\n\t});\n\n\t_parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"worker\")) {\n\t\t\tparser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"In order to use the 'worker' feature, include \" +\n\t\t\t\t\t\"the _hyperscript worker plugin. See \" +\n\t\t\t\t\t\"https://hyperscript.org/features/worker/ for \" +\n\t\t\t\t\t\"more info.\"\n\t\t\t);\n\t\t}\n\t});\n\n\t_parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"behavior\")) return;\n\t\tvar path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar nameSpace = path.split(\".\");\n\t\tvar name = nameSpace.pop();\n\n\t\tvar formalParams = [];\n\t\tif (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\tformalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\tvar hs = parser.requireElement(\"hyperscript\", tokens);\n\t\tfor (var i = 0; i < hs.features.length; i++) {\n\t\t\tvar feature = hs.features[i];\n\t\t\tfeature.behavior = path;\n\t\t}\n\n\t\treturn {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.assignToNamespace(\n\t\t\t\t\tglobalScope.document && globalScope.document.body,\n\t\t\t\t\tnameSpace,\n\t\t\t\t\tname,\n\t\t\t\t\tfunction (target, source, innerArgs) {\n\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\tvar elementScope = getOrInitObject(internalData, path + \"Scope\");\n\t\t\t\t\t\tfor (var i = 0; i < formalParams.length; i++) {\n\t\t\t\t\t\t\telementScope[formalParams[i]] = innerArgs[formalParams[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ths.apply(target, source);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addFeature(\"install\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"install\")) return;\n\t\tvar behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar behaviorNamespace = behaviorPath.split(\".\");\n\t\tvar args = parser.parseElement(\"namedArgumentList\", tokens);\n\n\t\tvar installFeature;\n\t\treturn (installFeature = {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.unifiedEval(\n\t\t\t\t\t{\n\t\t\t\t\t\targs: [args],\n\t\t\t\t\t\top: function (ctx, args) {\n\t\t\t\t\t\t\tvar behavior = globalScope;\n\t\t\t\t\t\t\tfor (var i = 0; i < behaviorNamespace.length; i++) {\n\t\t\t\t\t\t\t\tbehavior = behavior[behaviorNamespace[i]];\n\t\t\t\t\t\t\t\tif (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n\t\t\t\t\t\t\t\t\tthrow new Error(\"No such behavior defined as \" + behaviorPath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!(behavior instanceof Function))\n\t\t\t\t\t\t\t\tthrow new Error(behaviorPath + \" is not a behavior\");\n\n\t\t\t\t\t\t\tbehavior(target, source, args);\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\truntime.makeContext(target, installFeature, target)\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t});\n\n\t_parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n\t\tvar jsSourceStart = tokens.currentToken().start;\n\t\tvar jsLastToken = tokens.currentToken();\n\n\t\tvar funcNames = [];\n\t\tvar funcName = \"\";\n\t\tvar expectFunctionDeclaration = false;\n\t\twhile (tokens.hasMore()) {\n\t\t\tjsLastToken = tokens.consumeToken();\n\t\t\tvar peek = tokens.token(0, true);\n\t\t\tif (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (expectFunctionDeclaration) {\n\t\t\t\tif (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n\t\t\t\t\tfuncName += jsLastToken.value;\n\t\t\t\t} else {\n\t\t\t\t\tif (funcName !== \"\") funcNames.push(funcName);\n\t\t\t\t\tfuncName = \"\";\n\t\t\t\t\texpectFunctionDeclaration = false;\n\t\t\t\t}\n\t\t\t} else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n\t\t\t\texpectFunctionDeclaration = true;\n\t\t\t}\n\t\t}\n\t\tvar jsSourceEnd = jsLastToken.end + 1;\n\n\t\treturn {\n\t\t\ttype: \"jsBody\",\n\t\t\texposedFunctionNames: funcNames,\n\t\t\tjsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n\t\t};\n\t});\n\n\t_parser.addFeature(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\n\t\tvar jsSource =\n\t\t\tjsBody.jsSource +\n\t\t\t\"\\nreturn { \" +\n\t\t\tjsBody.exposedFunctionNames\n\t\t\t\t.map(function (name) {\n\t\t\t\t\treturn name + \":\" + name;\n\t\t\t\t})\n\t\t\t\t.join(\",\") +\n\t\t\t\" } \";\n\t\tvar func = new Function(jsSource);\n\n\t\treturn {\n\t\t\tjsSource: jsSource,\n\t\t\tfunction: func,\n\t\t\texposedFunctionNames: jsBody.exposedFunctionNames,\n\t\t\tinstall: function () {\n\t\t\t\tmergeObjects(globalScope, func());\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addCommand(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\t// Parse inputs\n\t\tvar inputs = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// empty input list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tvar inp = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\t\tinputs.push(inp.value);\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\t\ttokens.matchToken(\"end\");\n\n\t\tvar func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n\t\tvar command = {\n\t\t\tjsSource: jsBody.jsSource,\n\t\t\tfunction: func,\n\t\t\tinputs: inputs,\n\t\t\top: function (context) {\n\t\t\t\tvar args = [];\n\t\t\t\tinputs.forEach(function (input) {\n\t\t\t\t\targs.push(runtime.resolveSymbol(input, context, 'default'));\n\t\t\t\t});\n\t\t\t\tvar result = func.apply(globalScope, args);\n\t\t\t\tif (result && typeof result.then === \"function\") {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tresult.then(function (actualResult) {\n\t\t\t\t\t\t\tcontext.result = actualResult;\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcontext.result = result;\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"async\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"async\")) return;\n\t\tif (tokens.matchToken(\"do\")) {\n\t\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\n\t\t\t// Append halt\n\t\t\tvar end = body;\n\t\t\twhile (end.next) end = end.next;\n\t\t\tend.next = runtime.HALT;\n\n\t\t\ttokens.requireToken(\"end\");\n\t\t} else {\n\t\t\tvar body = parser.requireElement(\"command\", tokens);\n\t\t}\n\t\tvar command = {\n\t\t\tbody: body,\n\t\t\top: function (context) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tbody.execute(context);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(body, command);\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n\t\tvar startToken = tokens.currentToken();\n\t\tif (!tokens.matchToken(\"tell\")) return;\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\t\tif (tokens.hasMore() && !parser.featureStart(tokens.currentToken())) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\t\tvar slot = \"tell_\" + startToken.start;\n\t\tvar tellCmd = {\n\t\t\tvalue: value,\n\t\t\tbody: body,\n\t\t\targs: [value],\n\t\t\tresolveNext: function (context) {\n\t\t\t\tvar iterator = context.meta.iterators[slot];\n\t\t\t\tif (iterator.index < iterator.value.length) {\n\t\t\t\t\tcontext.beingTold = iterator.value[iterator.index++];\n\t\t\t\t\treturn body;\n\t\t\t\t} else {\n\t\t\t\t\t// restore original me\n\t\t\t\t\tcontext.beingTold = iterator.originalBeingTold;\n\t\t\t\t\tif (this.next) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\top: function (context, value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t} else if (!(Array.isArray(value) || value instanceof NodeList)) {\n\t\t\t\t\tvalue = [value];\n\t\t\t\t}\n\t\t\t\tcontext.meta.iterators[slot] = {\n\t\t\t\t\toriginalBeingTold: context.beingTold,\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t\treturn this.resolveNext(context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(body, tellCmd);\n\t\treturn tellCmd;\n\t});\n\n\t_parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"wait\")) return;\n\t\tvar command;\n\n\t\t// wait on event\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\ttokens.matchToken(\"a\"); // optional \"a\"\n\t\t\tvar events = [];\n\t\t\tdo {\n\t\t\t\tvar lookahead = tokens.token(0);\n\t\t\t\tif (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\ttime: parser.requireElement('expression', tokens).evaluate() // TODO: do we want to allow async here?\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\tname: _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n\t\t\t\t\t\targs: parseEventArgs(tokens),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} while (tokens.matchToken(\"or\"));\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\t// wait on event\n\t\t\tcommand = {\n\t\t\t\tevent: events,\n\t\t\t\ton: on,\n\t\t\t\targs: [on],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\tvar target = on ? on : context.me;\n\t\t\t\t\tif (!(target instanceof EventTarget))\n\t\t\t\t\t\tthrow new Error(\"Not a valid event target: \" + this.on.sourceFor());\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tvar resolved = false;\n\t\t\t\t\t\tfor (const eventInfo of events) {\n\t\t\t\t\t\t\tvar listener = (event) => {\n\t\t\t\t\t\t\t\tcontext.result = event;\n\t\t\t\t\t\t\t\tif (eventInfo.args) {\n\t\t\t\t\t\t\t\t\tfor (const arg of eventInfo.args) {\n\t\t\t\t\t\t\t\t\t\tcontext[arg.value] =\n\t\t\t\t\t\t\t\t\t\t\tevent[arg.value] || (event.detail ? event.detail[arg.value] : null);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (eventInfo.name){\n\t\t\t\t\t\t\t\ttarget.addEventListener(eventInfo.name, listener, {once: true});\n\t\t\t\t\t\t\t} else if (eventInfo.time != null) {\n\t\t\t\t\t\t\t\tsetTimeout(listener(), eventInfo.time, eventInfo.time)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tvar time;\n\t\t\tif (tokens.matchToken(\"a\")) {\n\t\t\t\ttokens.requireToken(\"tick\");\n\t\t\t\ttime = 0;\n\t\t\t} else {\n\t\t\t\ttime = _parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tcommand = {\n\t\t\t\ttype: \"waitCmd\",\n\t\t\t\ttime: time,\n\t\t\t\targs: [time],\n\t\t\t\top: function (context, timeValue) {\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t}, timeValue);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t// TODO  - colon path needs to eventually become part of ruby-style symbols\n\t_parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n\t\tvar root = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (root) {\n\t\t\tvar path = [root.value];\n\n\t\t\tvar separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n\t\t\tif (separator) {\n\t\t\t\tdo {\n\t\t\t\t\tpath.push(tokens.requireTokenType(\"IDENTIFIER\", \"NUMBER\").value);\n\t\t\t\t} while (tokens.matchOpToken(separator.value));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: \"dotOrColonPath\",\n\t\t\t\tpath: path,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn path.join(separator ? separator.value : \"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\n\t_parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\tevaluate: function() {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn parser.parseElement(\"dotOrColonPath\", tokens);\n\t});\n\n\tfunction parseSendCmd(cmdType, parser, runtime, tokens) {\n\t\tvar eventName = parser.requireElement(\"eventName\", tokens);\n\n\t\tvar details = parser.parseElement(\"namedArgumentList\", tokens);\n\t\tif ((cmdType === \"send\" && tokens.matchToken(\"to\")) ||\n\t\t\t(cmdType === \"trigger\" && tokens.matchToken(\"on\"))) {\n\t\t\tvar toExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar sendCmd = {\n\t\t\teventName: eventName,\n\t\t\tdetails: details,\n\t\t\tto: toExpr,\n\t\t\targs: [toExpr, eventName, details],\n\t\t\top: function (context, to, eventName, details) {\n\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\truntime.triggerEvent(target, eventName, details, context.me);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(sendCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn sendCmd;\n\t}\n\n\t_parser.addCommand(\"trigger\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"trigger\")) {\n\t\t\treturn parseSendCmd(\"trigger\", parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"send\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"send\")) {\n\t\t\treturn parseSendCmd(\"send\", parser, runtime, tokens);\n\t\t}\n\t});\n\n\tvar parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n\t\tif (returnAValue) {\n\t\t\tif (parser.commandBoundary(tokens.currentToken())) {\n\t\t\t\tparser.raiseParseError(tokens, \"'return' commands must return a value.  If you do not wish to return a value, use 'exit' instead.\");\n\t\t\t} else {\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t}\n\n\t\tvar returnCmd = {\n\t\t\tvalue: value,\n\t\t\targs: [value],\n\t\t\top: function (context, value) {\n\t\t\t\tvar resolve = context.meta.resolve;\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tcontext.meta.returnValue = value;\n\t\t\t\tif (resolve) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t};\n\t\treturn returnCmd;\n\t};\n\n\t_parser.addCommand(\"return\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"return\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, true);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"exit\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"halt\")) {\n\t\t\tif (tokens.matchToken(\"the\")) {\n\t\t\t\ttokens.requireToken(\"event\");\n\t\t\t\t// optional possessive\n\t\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t\t}\n\t\t\t\tvar keepExecuting = true;\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"bubbling\")) {\n\t\t\t\tvar bubbling = true;\n\t\t\t} else if (tokens.matchToken(\"default\")) {\n\t\t\t\tvar haltDefault = true;\n\t\t\t}\n\t\t\tvar exit = parseReturnFunction(parser, runtime, tokens, false);\n\n\t\t\tvar haltCmd = {\n\t\t\t\tkeepExecuting: true,\n\t\t\t\tbubbling: bubbling,\n\t\t\t\thaltDefault: haltDefault,\n\t\t\t\texit: exit,\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tif (ctx.event) {\n\t\t\t\t\t\tif (bubbling) {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t} else if (haltDefault) {\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keepExecuting) {\n\t\t\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn haltCmd;\n\t\t}\n\t});\n\n\t_parser.addCommand(\"log\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"log\")) return;\n\t\tvar exprs = [parser.parseElement(\"expression\", tokens)];\n\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\texprs.push(parser.requireElement(\"expression\", tokens));\n\t\t}\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tvar withExpr = parser.requireElement(\"expression\", tokens);\n\t\t}\n\t\tvar logCmd = {\n\t\t\texprs: exprs,\n\t\t\twithExpr: withExpr,\n\t\t\targs: [withExpr, exprs],\n\t\t\top: function (ctx, withExpr, values) {\n\t\t\t\tif (withExpr) {\n\t\t\t\t\twithExpr.apply(null, values);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log.apply(null, values);\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t\treturn logCmd;\n\t});\n\n\t_parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"throw\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar throwCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (ctx, expr) {\n\t\t\t\truntime.registerHyperTrace(ctx, expr);\n\t\t\t\tthrow expr;\n\t\t\t},\n\t\t};\n\t\treturn throwCmd;\n\t});\n\n\tvar parseCallOrGet = function (parser, runtime, tokens) {\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar callCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (context, result) {\n\t\t\t\tcontext.result = result;\n\t\t\t\treturn runtime.findNext(callCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn callCmd;\n\t};\n\t_parser.addCommand(\"call\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"call\")) return;\n\t\tvar call = parseCallOrGet(parser, runtime, tokens);\n\t\tif (call.expr && call.expr.type !== \"functionCall\") {\n\t\t\tparser.raiseParseError(tokens, \"Must be a function invocation\");\n\t\t}\n\t\treturn call;\n\t});\n\t_parser.addCommand(\"get\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"get\")) {\n\t\t\treturn parseCallOrGet(parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"make\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"make\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\n\t\tvar args = [];\n\t\tif (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\n\t\tif (tokens.matchToken(\"called\")) {\n\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t}\n\n\t\tvar command;\n\t\tif (expr.type === \"queryRef\") {\n\t\t\tcommand = {\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tvar match,\n\t\t\t\t\t\ttagname = \"div\",\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tclasses = [];\n\t\t\t\t\tvar re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n\t\t\t\t\twhile ((match = re.exec(expr.css))) {\n\t\t\t\t\t\tif (match[1] === \"\") tagname = match[2].trim();\n\t\t\t\t\t\telse if (match[1] === \"#\") id = match[2].trim();\n\t\t\t\t\t\telse classes.push(match[2].trim());\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = document.createElement(tagname);\n\t\t\t\t\tif (id !== undefined) result.id = id;\n\t\t\t\t\tfor (var i = 0; i < classes.length; i++) {\n\t\t\t\t\t\tvar cls = classes[i];\n\t\t\t\t\t\tresult.classList.add(cls)\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.result = result;\n\t\t\t\t\tif (name) ctx[name] = result;\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tcommand = {\n\t\t\t\targs: [expr, args],\n\t\t\t\top: function (ctx, expr, args) {\n\t\t\t\t\tctx.result = varargConstructor(expr, args);\n\t\t\t\t\tif (name) ctx[name] = ctx.result;\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\n\t\tlet lookAhead = tokens.token(1);\n\t\tif (!(lookAhead && lookAhead.op && (lookAhead.value === '.' || lookAhead.value === \"(\"))) {\n\t\t\treturn null;\n\t\t}\n\n\t\tvar expr = parser.requireElement(\"primaryExpression\", tokens);\n\n\t\tvar rootRoot = expr.root;\n\t\tvar root = expr;\n\t\twhile (rootRoot.root != null) {\n\t\t\troot = root.root;\n\t\t\trootRoot = rootRoot.root;\n\t\t}\n\n\t\tif (expr.type !== \"functionCall\") {\n\t\t\tparser.raiseParseError(tokens, \"Pseudo-commands must be function calls\");\n\t\t}\n\n\t\tif (root.type === \"functionCall\" && root.root.root == null) {\n\t\t\tif (tokens.matchAnyToken(\"the\", \"to\", \"on\", \"with\", \"into\", \"from\", \"at\")) {\n\t\t\t\tvar realRoot = parser.requireElement(\"expression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"me\")) {\n\t\t\t\tvar realRoot = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tlet pseudoCommand\n\t\tif(realRoot){\n\t\t\tpseudoCommand = {\n\t\t\t\ttype: \"pseudoCommand\",\n\t\t\t\troot: realRoot,\n\t\t\t\targExressions: root.argExressions,\n\t\t\t\targs: [realRoot, root.argExressions],\n\t\t\t\top: function (context, rootRoot, args) {\n\t\t\t\t\truntime.nullCheck(rootRoot, realRoot);\n\t\t\t\t\tvar func = rootRoot[root.root.name];\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targs.push(context);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.result = func.apply(rootRoot, args);\n\t\t\t\t\treturn runtime.findNext(pseudoCommand, context);\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t}\n\t\t} else {\n\t\t\tpseudoCommand = {\n\t\t\t\ttype: \"pseudoCommand\",\n\t\t\t\texpr: expr,\n\t\t\t\targs: [expr],\n\t\t\t\top: function (context, result) {\n\t\t\t\t\tcontext.result = result;\n\t\t\t\t\treturn runtime.findNext(pseudoCommand, context);\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn pseudoCommand;\n\t});\n\n\t/**\n\t* @param {ParserObject} parser\n\t* @param {RuntimeObject} runtime\n\t* @param {TokensObject} tokens\n\t* @param {*} target\n\t* @param {*} value\n\t* @returns\n\t*/\n\tvar makeSetter = function (parser, runtime, tokens, target, value) {\n\n\t\tvar symbolWrite = target.type === \"symbol\";\n\t\tvar attributeWrite = target.type === \"attributeRef\";\n\t\tvar styleWrite = target.type === \"styleRef\";\n\n\t\tif (!(attributeWrite || styleWrite || symbolWrite) && target.root == null) {\n\t\t\tparser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n\t\t}\n\n\t\tvar rootElt = null;\n\t\tvar prop = null;\n\t\tif (symbolWrite) {\n\t\t\t// rootElt is null\n\t\t} else if (attributeWrite || styleWrite) {\n\t\t\trootElt = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\tvar attribute = target;\n\t\t} else {\n\t\t\tprop = target.prop ? target.prop.value : null;\n\t\t\tvar attribute = target.attribute;\n\t\t\trootElt = target.root;\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setCmd = {\n\t\t\ttarget: target,\n\t\t\tsymbolWrite: symbolWrite,\n\t\t\tvalue: value,\n\t\t\targs: [rootElt, value],\n\t\t\top: function (context, root, valueToSet) {\n\t\t\t\tif (symbolWrite) {\n\t\t\t\t\truntime.setSymbol(target.name, context, target.scope, valueToSet);\n\t\t\t\t} else {\n\t\t\t\t\truntime.nullCheck(root, rootElt);\n\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t\tif (attribute.type === \"attributeRef\") {\n\t\t\t\t\t\t\t\tif (valueToSet == null) {\n\t\t\t\t\t\t\t\t\telt.removeAttribute(attribute.name);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\telt.setAttribute(attribute.name, valueToSet);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telt.style[attribute.name] = valueToSet;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telt[prop] = valueToSet;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn setCmd;\n\t};\n\n\t_parser.addCommand(\"default\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"default\")) return;\n\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\ttokens.requireToken(\"to\");\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setter = makeSetter(parser, runtime, tokens, target, value);\n\t\tvar defaultCmd = {\n\t\t\ttarget: target,\n\t\t\tvalue: value,\n\t\t\tsetter: setter,\n\t\t\targs: [target],\n\t\t\top: function (context, target) {\n\t\t\t\tif (target) {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else {\n\t\t\t\t\treturn setter;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tsetter.parent = defaultCmd;\n\t\treturn defaultCmd;\n\t});\n\n\t_parser.addCommand(\"set\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"set\")) return;\n\t\tif (tokens.currentToken().type === \"L_BRACE\") {\n\t\t\tvar obj = parser.requireElement(\"objectLiteral\", tokens);\n\t\t\ttokens.requireToken(\"on\");\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar command = {\n\t\t\t\tobjectLiteral: obj,\n\t\t\t\ttarget: target,\n\t\t\t\targs: [obj, target],\n\t\t\t\top: function (ctx, obj, target) {\n\t\t\t\t\tmergeObjects(target, obj);\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\n\t\ttry {\n\t\t\ttokens.pushFollow(\"to\");\n\t\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\t} finally {\n\t\t\ttokens.popFollow();\n\t\t}\n\t\ttokens.requireToken(\"to\");\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\treturn makeSetter(parser, runtime, tokens, target, value);\n\t});\n\n\t_parser.addCommand(\"if\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"if\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\ttokens.matchToken(\"then\"); // optional 'then'\n\t\tvar trueBranch = parser.parseElement(\"commandList\", tokens);\n\t\tif (tokens.matchToken(\"else\") || tokens.matchToken(\"otherwise\")) {\n\t\t\tvar falseBranch = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar ifCmd = {\n\t\t\texpr: expr,\n\t\t\ttrueBranch: trueBranch,\n\t\t\tfalseBranch: falseBranch,\n\t\t\targs: [expr],\n\t\t\top: function (context, exprValue) {\n\t\t\t\tif (exprValue) {\n\t\t\t\t\treturn trueBranch;\n\t\t\t\t} else if (falseBranch) {\n\t\t\t\t\treturn falseBranch;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(trueBranch, ifCmd);\n\t\tparser.setParent(falseBranch, ifCmd);\n\t\treturn ifCmd;\n\t});\n\n\tvar parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n\t\tvar innerStartToken = tokens.currentToken();\n\t\tvar identifier;\n\t\tif (tokens.matchToken(\"for\") || startedWithForToken) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tidentifier = identifierToken.value;\n\t\t\ttokens.requireToken(\"in\");\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\tidentifier = \"it\";\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"while\")) {\n\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\tvar isUntil = true;\n\t\t\tif (tokens.matchToken(\"event\")) {\n\t\t\t\tvar evt = _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t} else {\n\t\t\tif (!parser.commandBoundary(tokens.currentToken()) &&\n\t\t\t    tokens.currentToken().value !== 'forever') {\n\t\t\t\tvar times = parser.requireElement(\"expression\", tokens);\n\t\t\t\ttokens.requireToken(\"times\");\n\t\t\t} else {\n\t\t\t\ttokens.matchToken(\"forever\"); // consume optional forever\n\t\t\t\tvar forever = true;\n\t\t\t}\n\t\t}\n\n\t\tif (tokens.matchToken(\"index\")) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar indexIdentifier = identifierToken.value;\n\t\t}\n\n\t\tvar loop = parser.parseElement(\"commandList\", tokens);\n\t\tif (loop && evt) {\n\t\t\t// if this is an event based loop, wait a tick at the end of the loop so that\n\t\t\t// events have a chance to trigger in the loop condition o_O)))\n\t\t\tvar last = loop;\n\t\t\twhile (last.next) {\n\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tvar waitATick = {\n\t\t\t\ttype: \"waitATick\",\n\t\t\t\top: function () {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tresolve(runtime.findNext(waitATick));\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\tlast.next = waitATick;\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\tif (identifier == null) {\n\t\t\tidentifier = \"_implicit_repeat_\" + innerStartToken.start;\n\t\t\tvar slot = identifier;\n\t\t} else {\n\t\t\tvar slot = identifier + \"_\" + innerStartToken.start;\n\t\t}\n\n\t\tvar repeatCmd = {\n\t\t\tidentifier: identifier,\n\t\t\tindexIdentifier: indexIdentifier,\n\t\t\tslot: slot,\n\t\t\texpression: expression,\n\t\t\tforever: forever,\n\t\t\ttimes: times,\n\t\t\tuntil: isUntil,\n\t\t\tevent: evt,\n\t\t\ton: on,\n\t\t\twhileExpr: whileExpr,\n\t\t\tresolveNext: function () {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tloop: loop,\n\t\t\targs: [whileExpr, times],\n\t\t\top: function (context, whileValue, times) {\n\t\t\t\tvar iteratorInfo = context.meta.iterators[slot];\n\t\t\t\tvar keepLooping = false;\n\t\t\t\tvar loopVal = null;\n\t\t\t\tif (this.forever) {\n\t\t\t\t\tkeepLooping = true;\n\t\t\t\t} else if (this.until) {\n\t\t\t\t\tif (evt) {\n\t\t\t\t\t\tkeepLooping = context.meta.iterators[slot].eventFired === false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeepLooping = whileValue !== true;\n\t\t\t\t\t}\n\t\t\t\t} else if (whileExpr) {\n\t\t\t\t\tkeepLooping = whileValue;\n\t\t\t\t} else if (times) {\n\t\t\t\t\tkeepLooping = iteratorInfo.index < times;\n\t\t\t\t} else {\n\t\t\t\t\tvar nextValFromIterator = iteratorInfo.iterator.next();\n\t\t\t\t\tkeepLooping = !nextValFromIterator.done;\n\t\t\t\t\tloopVal = nextValFromIterator.value;\n\t\t\t\t}\n\n\t\t\t\tif (keepLooping) {\n\t\t\t\t\tif (iteratorInfo.value) {\n\t\t\t\t\t\tcontext.result = context[identifier] = loopVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.result = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\tif (indexIdentifier) {\n\t\t\t\t\t\tcontext[indexIdentifier] = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\titeratorInfo.index++;\n\t\t\t\t\treturn loop;\n\t\t\t\t} else {\n\t\t\t\t\tcontext.meta.iterators[slot] = null;\n\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(loop, repeatCmd);\n\t\tvar repeatInit = {\n\t\t\tname: \"repeatInit\",\n\t\t\targs: [expression, evt, on],\n\t\t\top: function (context, value, event, on) {\n\t\t\t\tvar iteratorInfo = {\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\teventFired: false,\n\t\t\t\t};\n\t\t\t\tcontext.meta.iterators[slot] = iteratorInfo;\n\t\t\t\tif (value && value[Symbol.iterator]) {\n\t\t\t\t\titeratorInfo.iterator = value[Symbol.iterator]();\n\t\t\t\t}\n\t\t\t\tif (evt) {\n\t\t\t\t\tvar target = on || context.me;\n\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tfunction (e) {\n\t\t\t\t\t\t\tcontext.meta.iterators[slot].eventFired = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn repeatCmd; // continue to loop\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(repeatCmd, repeatInit);\n\t\treturn repeatInit;\n\t};\n\n\t_parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"repeat\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"for\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, true);\n\t\t}\n\t});\n\n  _parser.addCommand(\"continue\", function (parser, runtime, tokens) {\n\n    if (!tokens.matchToken(\"continue\")) return;\n\n    var command = {\n      op: function (context) {\n\n        // scan for the closest repeat statement\n        for (var parent = this.parent ; true ; parent = parent.parent) {\n\n          if (parent == undefined) {\n            parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n          }\n          if (parent.loop != undefined) {\n            return parent.resolveNext(context)\n          }\n        }\n      }\n    };\n    return command;\n  });\n\n  _parser.addCommand(\"break\", function (parser, runtime, tokens) {\n\n    if (!tokens.matchToken(\"break\")) return;\n\n    var command = {\n      op: function (context) {\n\n        // scan for the closest repeat statement\n        for (var parent = this.parent ; true ; parent = parent.parent) {\n\n          if (parent == undefined) {\n            parser.raiseParseError(tokens, \"Command `continue` cannot be used outside of a `repeat` loop.\")\n          }\n          if (parent.loop != undefined) {\n\t\t\t  console.log(parent);\n\t\t\t  return runtime.findNext(parent.parent, context);\n          }\n        }\n      }\n    };\n    return command;\n  });\n\n\t_parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n\t\treturn _parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n\t});\n\n\t_parser.addCommand(\"append\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"append\")) return;\n\t\t/** @type {GrammarElement} */\n\t\tvar targetExpr = null;\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\tvar implicitResultSymbol = {\n\t\t\ttype: \"symbol\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.resolveSymbol(\"result\", context);\n\t\t\t},\n\t\t};\n\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\ttargetExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\ttargetExpr = implicitResultSymbol;\n\t\t}\n\n\t\tvar setter = null;\n\t\tif (targetExpr.type === \"symbol\" || targetExpr.type === \"attributeRef\" || targetExpr.root != null) {\n\t\t\tsetter = makeSetter(parser, runtime, tokens, targetExpr, implicitResultSymbol);\n\t\t}\n\n\t\tvar command = {\n\t\t\tvalue: value,\n\t\t\ttarget: targetExpr,\n\t\t\targs: [targetExpr, value],\n\t\t\top: function (context, target, value) {\n\t\t\t\tif (Array.isArray(target)) {\n\t\t\t\t\ttarget.push(value);\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else if (target instanceof Element) {\n\t\t\t\t\ttarget.innerHTML += value;\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else if(setter) {\n\t\t\t\t\tcontext.result = (target || \"\") + value;\n\t\t\t\t\treturn setter;\n\t\t\t\t} else {\n\t\t\t\t\tthrow Error(\"Unable to append a value!\")\n\t\t\t\t}\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/*, value, target*/);\n\t\t\t},\n\t\t};\n\n\t\tif (setter != null) {\n\t\t\tsetter.parent = command;\n\t\t}\n\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"increment\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar implicitIncrementOp = {\n\t\t\ttype: \"implicitIncrementOp\",\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue + amount;\n\t\t\t\tcontext.result = newValue;\n\t\t\t\treturn newValue;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t}\n\t\t};\n\n\t\treturn makeSetter(parser, runtime, tokens, target, implicitIncrementOp);\n\t});\n\n\t_parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"decrement\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar implicitDecrementOp = {\n\t\t\ttype: \"implicitDecrementOp\",\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue - amount;\n\t\t\t\tcontext.result = newValue;\n\t\t\t\treturn newValue;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t}\n\t\t};\n\n\t\treturn makeSetter(parser, runtime, tokens, target, implicitDecrementOp);\n\t});\n\n\tfunction parseConversionInfo(tokens, parser) {\n\t\tvar type = \"text\";\n\t\tvar conversion;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\t\tif (tokens.matchToken(\"json\") || tokens.matchToken(\"Object\")) {\n\t\t\ttype = \"json\";\n\t\t} else if (tokens.matchToken(\"response\")) {\n\t\t\ttype = \"response\";\n\t\t} else if (tokens.matchToken(\"html\")) {\n\t\t\ttype = \"html\";\n\t\t} else if (tokens.matchToken(\"text\")) {\n\t\t\t// default, ignore\n\t\t} else {\n\t\t\tconversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\t}\n\t\treturn {type, conversion};\n\t}\n\n\t_parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"fetch\")) return;\n\t\tvar url = parser.requireElement(\"stringLike\", tokens);\n\n\t\tif (tokens.matchToken(\"as\")) {\n\t\t\tvar conversionInfo = parseConversionInfo(tokens, parser);\n\t\t}\n\n\t\tif (tokens.matchToken(\"with\") && tokens.currentToken().value !== \"{\") {\n\t\t\tvar args = parser.parseElement(\"nakedNamedArgumentList\", tokens);\n\t\t} else {\n\t\t\tvar args = parser.parseElement(\"objectLiteral\", tokens);\n\t\t}\n\n\t\tif (conversionInfo == null && tokens.matchToken(\"as\")) {\n\t\t\tconversionInfo = parseConversionInfo(tokens, parser);\n\t\t}\n\n\t\tvar type = conversionInfo ? conversionInfo.type : \"text\";\n\t\tvar conversion = conversionInfo ? conversionInfo.conversion : null\n\n\t\t/** @type {GrammarElement} */\n\t\tvar fetchCmd = {\n\t\t\turl: url,\n\t\t\targExpressions: args,\n\t\t\targs: [url, args],\n\t\t\top: function (context, url, args) {\n\t\t\t\tvar detail = args || {};\n\t\t\t\tdetail[\"sender\"] = context.me;\n\t\t\t\tdetail[\"headers\"] = detail[\"headers\"] || {}\n\t\t\t\tvar abortController = new AbortController();\n\t\t\t\tlet abortListener = context.me.addEventListener('fetch:abort', function(){\n\t\t\t\t\tabortController.abort();\n\t\t\t\t}, {once: true});\n\t\t\t\tdetail['signal'] = abortController.signal;\n\t\t\t\truntime.triggerEvent(context.me, \"hyperscript:beforeFetch\", detail);\n\t\t\t\truntime.triggerEvent(context.me, \"fetch:beforeRequest\", detail);\n\t\t\t\targs = detail;\n\t\t\t\tvar finished = false;\n\t\t\t\tif (args.timeout) {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (!finished) {\n\t\t\t\t\t\t\tabortController.abort();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, args.timeout);\n\t\t\t\t}\n\t\t\t\treturn fetch(url, args)\n\t\t\t\t\t.then(function (resp) {\n\t\t\t\t\t\tlet resultDetails = {response:resp};\n\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterResponse\", resultDetails);\n\t\t\t\t\t\tresp = resultDetails.response;\n\n\t\t\t\t\t\tif (type === \"response\") {\n\t\t\t\t\t\t\tcontext.result = resp;\n\t\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterRequest\", {result:resp});\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type === \"json\") {\n\t\t\t\t\t\t\treturn resp.json().then(function (result) {\n\t\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n\t\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn resp.text().then(function (result) {\n\t\t\t\t\t\t\tif (conversion) result = runtime.convertValue(result, conversion);\n\n\t\t\t\t\t\t\tif (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:afterRequest\", {result});\n\t\t\t\t\t\t\tfinished = true;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:error\", {\n\t\t\t\t\t\t\treason: reason,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}).finally(function(){\n\t\t\t\t\t\tcontext.me.removeEventListener('fetch:abort', abortListener);\n\t\t\t\t\t});\n\t\t\t},\n\t\t};\n\t\treturn fetchCmd;\n\t});\n}\n\n//====================================================================\n// Initialization\n//====================================================================\nfunction ready(fn) {\n\tif (document.readyState !== \"loading\") {\n\t\tsetTimeout(fn);\n\t} else {\n\t\tdocument.addEventListener(\"DOMContentLoaded\", fn);\n\t}\n}\n\nfunction getMetaConfig() {\n\t/** @type {HTMLMetaElement} */\n\tvar element = document.querySelector('meta[name=\"htmx-config\"]');\n\tif (element) {\n\t\treturn parseJSON(element.content);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nfunction mergeMetaConfig() {\n\tvar metaConfig = getMetaConfig();\n\tif (metaConfig) {\n\t\t_hyperscript.config = mergeObjects(_hyperscript.config, metaConfig);\n\t}\n}\n\nif (\"document\" in globalScope) {\n\t/** @type {HTMLScriptElement[]} */\n\tvar scripts = Array.from(document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n\tPromise.all(\n\t\tscripts.map(function (script) {\n\t\t\treturn fetch(script.src)\n\t\t\t\t.then(function (res) {\n\t\t\t\t\treturn res.text();\n\t\t\t\t})\n\t\t\t\t.then(function (code) {\n\t\t\t\t\treturn _runtime.evaluate(code);\n\t\t\t\t});\n\t\t})\n\t).then(function () {\n\t\tready(function () {\n\t\t\tmergeMetaConfig();\n\t\t\t_runtime.processNode(document.documentElement);\n\t\t\tdocument.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n\t\t\t\t_runtime.processNode(evt.detail.elt);\n\t\t\t});\n\t\t});\n\t});\n}\n\n//====================================================================\n// API\n//====================================================================\n/** @type {HyperscriptObject} */\nexport default _hyperscript = mergeObjects(\n\tfunction (str, ctx) {\n\t\treturn _runtime.evaluate(str, ctx); //OK\n\t},\n\t{\n\t\tinternals: {\n\t\t\tlexer: _lexer,\n\t\t\tparser: _parser,\n\t\t\truntime: _runtime,\n\t\t},\n\t\tElementCollection: ElementCollection,\n\t\taddFeature: function (keyword, definition) {\n\t\t\t_parser.addFeature(keyword, definition);\n\t\t},\n\t\taddCommand: function (keyword, definition) {\n\t\t\t_parser.addCommand(keyword, definition);\n\t\t},\n\t\taddLeafExpression: function (name, definition) {\n\t\t\t_parser.addLeafExpression(name, definition);\n\t\t},\n\t\taddIndirectExpression: function (name, definition) {\n\t\t\t_parser.addIndirectExpression(name, definition);\n\t\t},\n\t\tevaluate: _runtime.evaluate.bind(_runtime),\n\t\tparse: _runtime.parse.bind(_runtime),\n\t\tprocessNode: _runtime.processNode.bind(_runtime),\n\t\tconfig: {\n\t\t\tattributes: \"_, script, data-script\",\n\t\t\tdefaultTransition: \"all 500ms ease-in\",\n\t\t\tdisableSelector: \"[disable-scripting], [data-disable-scripting]\",\n\t\t\tconversions: CONVERSIONS,\n\t\t},\n\t}\n);\n","\nimport { mergeObjects } from \"../utils.js\";\n\nfunction genUUID() {\n\treturn \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n\t\tvar r = (Math.random() * 16) | 0,\n\t\tv = c == \"x\" ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n}\n\nfunction createSocket(url) {\n\treturn new WebSocket(url.evaluate());\n}\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\n\t/** @type {(string | symbol)[]} */\n\tvar PROXY_BLACKLIST = [\"then\", \"catch\", \"length\", \"asyncWrapper\", \"toJSON\"];\n\n\t_hyperscript.addFeature(\"socket\", function (parser, runtime, tokens) {\n\t\tfunction getProxy(timeout) {\n\t\t\treturn new Proxy(\n\t\t\t\t{},\n\t\t\t\t{\n\t\t\t\t\tget: function (obj, property) {\n\t\t\t\t\t\tif (PROXY_BLACKLIST.indexOf(property) >= 0) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t} else if (property === \"noTimeout\") {\n\t\t\t\t\t\t\treturn getProxy(-1);\n\t\t\t\t\t\t} else if (property === \"timeout\") {\n\t\t\t\t\t\t\treturn function (i) {\n\t\t\t\t\t\t\t\treturn getProxy(parseInt(i));\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\t\tvar uuid = genUUID();\n\t\t\t\t\t\t\t\tvar args = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tvar rpcInfo = {\n\t\t\t\t\t\t\t\t\tiid: uuid,\n\t\t\t\t\t\t\t\t\tfunction: property,\n\t\t\t\t\t\t\t\t\targs: args,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tsocket = socket ? socket : createSocket(url); //recreate socket if needed\n\t\t\t\t\t\t\t\tsocket.send(JSON.stringify(rpcInfo));\n\n\t\t\t\t\t\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\t\t\tpromises[uuid] = {\n\t\t\t\t\t\t\t\t\t\tresolve: resolve,\n\t\t\t\t\t\t\t\t\t\treject: reject,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tif (timeout >= 0) {\n\t\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\t\tif (promises[uuid]) {\n\t\t\t\t\t\t\t\t\t\t\tpromises[uuid].reject(\"Timed out\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tdelete promises[uuid];\n\t\t\t\t\t\t\t\t\t}, timeout); // TODO configurable?\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn promise;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\tif (tokens.matchToken(\"socket\")) {\n\t\t\tvar name = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\t\tvar qualifiedName = name.evaluate();\n\t\t\tvar nameSpace = qualifiedName.split(\".\");\n\t\t\tvar socketName = nameSpace.pop();\n\n\t\t\tvar promises = {};\n\t\t\tvar url = parser.requireElement(\"stringLike\", tokens);\n\n\t\t\tvar defaultTimeout = 10000;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\ttokens.requireToken(\"timeout\");\n\t\t\t\tdefaultTimeout = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"on\")) {\n\t\t\t\ttokens.requireToken(\"message\");\n\t\t\t\tif (tokens.matchToken(\"as\")) {\n\t\t\t\t\ttokens.requireToken(\"json\");\n\t\t\t\t\tvar jsonMessages = true;\n\t\t\t\t}\n\t\t\t\tvar messageHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\t\tvar implicitReturn = {\n\t\t\t\t\ttype: \"implicitReturn\",\n\t\t\t\t\top: function (context) {\n\t\t\t\t\t\treturn runtime.HALT;\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (context) {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t\tvar end = messageHandler;\n\t\t\t\twhile (end.next) {\n\t\t\t\t\tend = end.next;\n\t\t\t\t}\n\t\t\t\tend.next = implicitReturn;\n\t\t\t\t// TODO set parent?\n\t\t\t\t// parser.setParent(implicitReturn, initFeature);\n\t\t\t}\n\n\t\t\tvar socket = createSocket(url);\n\t\t\tvar rpcProxy = getProxy(defaultTimeout);\n\n\t\t\tvar socketObject = {\n\t\t\t\traw: socket,\n\t\t\t\tdispatchEvent: function (evt) {\n\t\t\t\t\tvar details = evt.detail;\n\t\t\t\t\t// remove hyperscript internals\n\t\t\t\t\tdelete details.sender;\n\t\t\t\t\tdelete details._namedArgList_;\n\t\t\t\t\tsocket.send(JSON.stringify(mergeObjects({ type: evt.type }, details)));\n\t\t\t\t},\n\t\t\t\trpc: rpcProxy,\n\t\t\t};\n\n\t\t\tvar socketFeature = {\n\t\t\t\tname: socketName,\n\t\t\t\tsocket: socketObject,\n\t\t\t\tinstall: function (target) {\n\t\t\t\t\truntime.assignToNamespace(target, nameSpace, socketName, socketObject);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tsocket.onmessage = function (evt) {\n\t\t\t\tvar data = evt.data;\n\t\t\t\ttry {\n\t\t\t\t\tvar dataAsJson = JSON.parse(data);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// not JSON\n\t\t\t\t}\n\n\t\t\t\t// RPC reply\n\t\t\t\tif (dataAsJson && dataAsJson.iid) {\n\t\t\t\t\tif (dataAsJson.throw) {\n\t\t\t\t\t\tpromises[dataAsJson.iid].reject(dataAsJson.throw);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tpromises[dataAsJson.iid].resolve(dataAsJson.return);\n\t\t\t\t\t}\n\t\t\t\t\tdelete promises[dataAsJson.iid];\n\t\t\t\t}\n\n\t\t\t\tif (messageHandler) {\n\t\t\t\t\tvar context = runtime.makeContext(socketObject, socketFeature, socketObject);\n\t\t\t\t\tif (jsonMessages) {\n\t\t\t\t\t\tif (dataAsJson) {\n\t\t\t\t\t\t\tcontext.message = dataAsJson;\n\t\t\t\t\t\t\tcontext.result = dataAsJson;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow \"Received non-JSON message from socket: \" + data;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.message = data;\n\t\t\t\t\t\tcontext.result = data;\n\t\t\t\t\t}\n\t\t\t\t\tmessageHandler.execute(context);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// clear socket on close to be recreated\n\t\t\tsocket.addEventListener(\"close\", function (e) {\n\t\t\t\tsocket = null;\n\t\t\t});\n\n\t\t\treturn socketFeature;\n\t\t}\n\t});\n}\n","\nfunction compileTemplate(template) {\n\treturn template.replace(/(?:^|\\n)([^@]*)@?/gm, function (match, p1) {\n\t\tvar templateStr = (\" \" + p1).replace(/([^\\\\])\\$\\{/g, \"$1$${escape html \").substring(1);\n\t\treturn \"\\ncall __ht_template_result.push(`\" + templateStr + \"`)\\n\";\n\t});\n}\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\n\tfunction renderTemplate(template, ctx) {\n\t\tvar buf = [];\n\t\t_hyperscript.evaluate(template, Object.assign({ __ht_template_result: buf }, ctx));\n\t\treturn buf.join(\"\");\n\t}\n\n\t_hyperscript.addCommand(\"render\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"render\")) return;\n\t\tvar template_ = parser.requireElement(\"expression\", tokens);\n\t\tvar templateArgs = {};\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\ttemplateArgs = parser.parseElement(\"namedArgumentList\", tokens);\n\t\t}\n\t\treturn {\n\t\t\targs: [template_, templateArgs],\n\t\t\top: function (ctx, template, templateArgs) {\n\t\t\t\tif (!(template instanceof Element)) throw new Error(template_.sourceFor() + \" is not an element\");\n\t\t\t\tconsole.log(compileTemplate(template.innerHTML));\n\t\t\t\tctx.result = renderTemplate(compileTemplate(template.innerHTML), templateArgs);\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t});\n\n\tfunction escapeHTML(html) {\n\t\treturn String(html)\n\t\t\t.replace(/&/g, \"&amp;\")\n\t\t\t.replace(/</g, \"&lt;\")\n\t\t\t.replace(/>/g, \"&gt;\")\n\t\t\t.replace(/\\x22/g, \"&quot;\")\n\t\t\t.replace(/\\x27/g, \"&#039;\");\n\t}\n\n\t_hyperscript.addLeafExpression(\"escape\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"escape\")) return;\n\t\tvar escapeType = tokens.matchTokenType(\"IDENTIFIER\").value;\n\n\t\t// hidden! for use in templates\n\t\tvar unescaped = tokens.matchToken(\"unescaped\");\n\n\t\tvar arg = parser.requireElement(\"expression\", tokens);\n\n\t\treturn {\n\t\t\targs: [arg],\n\t\t\top: function (ctx, arg) {\n\t\t\t\tif (unescaped) return arg;\n\t\t\t\tif (arg === undefined) return \"\";\n\t\t\t\tswitch (escapeType) {\n\t\t\t\t\tcase \"html\":\n\t\t\t\t\t\treturn escapeHTML(arg);\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(\"Unknown escape: \" + escapeType);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (ctx) {\n\t\t\t\treturn runtime.unifiedEval(this, ctx);\n\t\t\t},\n\t\t};\n\t});\n}\n","///=========================================================================\n/// This module provides the core web functionality for hyperscript\n///=========================================================================\n\nimport { mergeObjects } from \"./utils.js\"\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\t_hyperscript.addCommand(\"settle\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"settle\")) {\n\t\t\tif (!parser.commandBoundary(tokens.currentToken())) {\n\t\t\t\tvar onExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar settleCommand = {\n\t\t\t\ttype: \"settleCmd\",\n\t\t\t\targs: [onExpr],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\truntime.nullCheck(on, onExpr);\n\t\t\t\t\tvar resolve = null;\n\t\t\t\t\tvar resolved = false;\n\t\t\t\t\tvar transitionStarted = false;\n\n\t\t\t\t\tvar promise = new Promise(function (r) {\n\t\t\t\t\t\tresolve = r;\n\t\t\t\t\t});\n\n\t\t\t\t\t// listen for a transition begin\n\t\t\t\t\ton.addEventListener(\n\t\t\t\t\t\t\"transitionstart\",\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\ttransitionStarted = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\n\t\t\t\t\t// if no transition begins in 500ms, cancel\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tif (!transitionStarted && !resolved) {\n\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 500);\n\n\t\t\t\t\t// continue on a transition emd\n\t\t\t\t\ton.addEventListener(\n\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t\treturn promise;\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn settleCommand;\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"add\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"add\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tvar cssDeclaration = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\tcssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n\t\t\t\t\tif (cssDeclaration == null) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\tvar toExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar toExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (classRefs) {\n\t\t\t\treturn {\n\t\t\t\t\tclassRefs: classRefs,\n\t\t\t\t\tto: toExpr,\n\t\t\t\t\targs: [toExpr, classRefs],\n\t\t\t\t\top: function (context, to, classRefs) {\n\t\t\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\t\tif (target instanceof Element) target.classList.add(classRef.className);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else if (attributeRef) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"addCmd\",\n\t\t\t\t\tattributeRef: attributeRef,\n\t\t\t\t\tto: toExpr,\n\t\t\t\t\targs: [toExpr],\n\t\t\t\t\top: function (context, to, attrRef) {\n\t\t\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (ctx) {\n\t\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"addCmd\",\n\t\t\t\t\tcssDeclaration: cssDeclaration,\n\t\t\t\t\tto: toExpr,\n\t\t\t\t\targs: [toExpr, cssDeclaration],\n\t\t\t\t\top: function (context, to, css) {\n\t\t\t\t\t\truntime.nullCheck(to, toExpr);\n\t\t\t\t\t\truntime.implicitLoop(to, function (target) {\n\t\t\t\t\t\t\ttarget.style.cssText += css;\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (ctx) {\n\t\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.internals.parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\n\t\tvar stringParts = [\"\"]\n\t\tvar exprs = []\n\n\t\twhile (tokens.hasMore()) {\n\t\t\tif (tokens.matchOpToken(\"\\\\\")) {\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else if (tokens.matchOpToken(\"}\")) {\n\t\t\t\tbreak;\n\t\t\t} else if (tokens.matchToken(\"$\")) {\n\t\t\t\tvar opencurly = tokens.matchOpToken(\"{\");\n\t\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\t\tif (opencurly) tokens.requireOpToken(\"}\");\n\n\t\t\t\texprs.push(expr)\n\t\t\t\tstringParts.push(\"\")\n\t\t\t} else {\n\t\t\t\tvar tok = tokens.consumeToken();\n\t\t\t\tstringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n\t\t\t}\n\n\t\t\tstringParts[stringParts.length-1] += tokens.lastWhitespace();\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"styleLiteral\",\n\t\t\targs: [exprs],\n\t\t\top: function (ctx, exprs) {\n\t\t\t\tvar rv = \"\";\n\n\t\t\t\tstringParts.forEach(function (part, idx) {\n\t\t\t\t\trv += part;\n\t\t\t\t\tif (idx in exprs) rv += exprs[idx];\n\t\t\t\t});\n\n\t\t\t\treturn rv;\n\t\t\t},\n\t\t\tevaluate: function(ctx) {\n\t\t\t\treturn runtime.unifiedEval(this, ctx);\n\t\t\t}\n\t\t}\n\t})\n\n\t_hyperscript.addCommand(\"remove\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"remove\")) {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tvar elementExpr = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\telementExpr = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (elementExpr == null) {\n\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\"Expected either a class reference, attribute expression or value expression\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar fromExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar fromExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (elementExpr) {\n\t\t\t\treturn {\n\t\t\t\t\telementExpr: elementExpr,\n\t\t\t\t\tfrom: fromExpr,\n\t\t\t\t\targs: [elementExpr],\n\t\t\t\t\top: function (context, element) {\n\t\t\t\t\t\truntime.nullCheck(element, elementExpr);\n\t\t\t\t\t\truntime.implicitLoop(element, function (target) {\n\t\t\t\t\t\t\tif (target.parentElement) {\n\t\t\t\t\t\t\t\ttarget.parentElement.removeChild(target);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\tclassRefs: classRefs,\n\t\t\t\t\tattributeRef: attributeRef,\n\t\t\t\t\telementExpr: elementExpr,\n\t\t\t\t\tfrom: fromExpr,\n\t\t\t\t\targs: [classRefs, fromExpr],\n\t\t\t\t\top: function (context, classRefs, from) {\n\t\t\t\t\t\truntime.nullCheck(from, fromExpr);\n\t\t\t\t\t\tif (classRefs) {\n\t\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"toggle\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"toggle\")) {\n\t\t\tif (tokens.matchToken(\"between\")) {\n\t\t\t\tvar between = true;\n\t\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\t\ttokens.requireToken(\"and\");\n\t\t\t\tvar classRef2 = parser.requireElement(\"classRef\", tokens);\n\t\t\t} else {\n\t\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\t\tvar attributeRef = null;\n\t\t\t\tif (classRef == null) {\n\t\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar classRefs = [classRef];\n\t\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"on\")) {\n\t\t\t\tvar onExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar onExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"for\")) {\n\t\t\t\tvar time = parser.requireElement(\"expression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\t\tvar evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar toggleCmd = {\n\t\t\t\tclassRef: classRef,\n\t\t\t\tclassRef2: classRef2,\n\t\t\t\tclassRefs: classRefs,\n\t\t\t\tattributeRef: attributeRef,\n\t\t\t\ton: onExpr,\n\t\t\t\ttime: time,\n\t\t\t\tevt: evt,\n\t\t\t\tfrom: from,\n\t\t\t\ttoggle: function (on, classRef, classRef2, classRefs) {\n\t\t\t\t\truntime.nullCheck(on, onExpr);\n\t\t\t\t\tif (between) {\n\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\tif (target.classList.contains(classRef.className)) {\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t\ttarget.classList.add(classRef2.className);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.classList.add(classRef.className);\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef2.className);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (classRefs) {\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(on, function (target) {\n\t\t\t\t\t\t\t\ttarget.classList.toggle(classRef.className);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.forEach(on, function (target) {\n\t\t\t\t\t\t\tif (target.hasAttribute(attributeRef.name)) {\n\t\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\targs: [onExpr, time, evt, from, classRef, classRef2, classRefs],\n\t\t\t\top: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n\t\t\t\t\tif (time) {\n\t\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t}, time);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else if (evt) {\n\t\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\t\tvar target = from || context.me;\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\tevt,\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\treturn runtime.findNext(toggleCmd, context);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn toggleCmd;\n\t\t}\n\t});\n\n\tvar HIDE_SHOW_STRATEGIES = {\n\t\tdisplay: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.display = arg;\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\tconst internalData = _hyperscript.internals.runtime.getInternalData(element);\n\t\t\t\tif (internalData.originalDisplay == null) {\n\t\t\t\t\tinternalData.originalDisplay = element.style.display;\n\t\t\t\t}\n\t\t\t\telement.style.display = \"none\";\n\t\t\t} else {\n\t\t\t\tconst internalData = _hyperscript.internals.runtime.getInternalData(element);\n\t\t\t\tif (internalData.originalDisplay && internalData.originalDisplay !== 'none') {\n\t\t\t\t\telement.style.display = internalData.originalDisplay;\n\t\t\t\t} else {\n\t\t\t\t\telement.style.removeProperty('display');\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tvisibility: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.visibility = arg;\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\telement.style.visibility = \"hidden\";\n\t\t\t} else {\n\t\t\t\telement.style.visibility = \"visible\";\n\t\t\t}\n\t\t},\n\t\topacity: function (op, element, arg) {\n\t\t\tif (arg) {\n\t\t\t\telement.style.opacity = arg;\n\t\t\t} else if (op === \"hide\") {\n\t\t\t\telement.style.opacity = \"0\";\n\t\t\t} else {\n\t\t\t\telement.style.opacity = \"1\";\n\t\t\t}\n\t\t},\n\t};\n\n\tvar parseShowHideTarget = function (parser, runtime, tokens) {\n\t\tvar target;\n\t\tvar currentTokenValue = tokens.currentToken();\n\t\tif (currentTokenValue.value === \"when\" || currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n\t\t\ttarget = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t} else {\n\t\t\ttarget = parser.parseElement(\"expression\", tokens);\n\t\t}\n\t\treturn target;\n\t};\n\n\tvar resolveStrategy = function (parser, tokens, name) {\n\t\tvar configDefault = _hyperscript.config.defaultHideShowStrategy;\n\t\tvar strategies = HIDE_SHOW_STRATEGIES;\n\t\tif (_hyperscript.config.hideShowStrategies) {\n\t\t\tstrategies = mergeObjects(strategies, _hyperscript.config.hideShowStrategies); // merge in user provided strategies\n\t\t}\n\t\tname = name || configDefault || \"display\";\n\t\tvar value = strategies[name];\n\t\tif (value == null) {\n\t\t\tparser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n\t\t}\n\t\treturn value;\n\t};\n\n\t_hyperscript.addCommand(\"hide\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"hide\")) {\n\t\t\tvar targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n\t\t\tvar name = null;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\t}\n\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\t\treturn {\n\t\t\t\ttarget: targetExpr,\n\t\t\t\targs: [targetExpr],\n\t\t\t\top: function (ctx, target) {\n\t\t\t\t\truntime.nullCheck(target, targetExpr);\n\t\t\t\t\truntime.implicitLoop(target, function (elt) {\n\t\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"show\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"show\")) {\n\t\t\tvar targetExpr = parseShowHideTarget(parser, runtime, tokens);\n\n\t\t\tvar name = null;\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\t}\n\t\t\tvar arg = null;\n\t\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\t\targ = tokenArr\n\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"when\")) {\n\t\t\t\tvar when = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\t\treturn {\n\t\t\t\ttarget: targetExpr,\n\t\t\t\twhen: when,\n\t\t\t\targs: [targetExpr],\n\t\t\t\top: function (ctx, target) {\n\t\t\t\t\truntime.nullCheck(target, targetExpr);\n\t\t\t\t\truntime.implicitLoop(target, function (elt) {\n\t\t\t\t\t\tif (when) {\n\t\t\t\t\t\t\tctx['result'] = elt;\n\t\t\t\t\t\t\tlet whenResult = runtime.evaluateNoPromise(when, ctx);\n\t\t\t\t\t\t\tif (whenResult) {\n\t\t\t\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tctx['result'] = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"take\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"take\")) {\n\t\t\tvar classRef = parser.requireElement(\"classRef\", tokens);\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar fromExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar fromExpr = classRef;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"for\")) {\n\t\t\t\tvar forExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar forExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar takeCmd = {\n\t\t\t\tclassRef: classRef,\n\t\t\t\tfrom: fromExpr,\n\t\t\t\tforElt: forExpr,\n\t\t\t\targs: [classRef, fromExpr, forExpr],\n\t\t\t\top: function (context, eltColl, from, forElt) {\n\t\t\t\t\truntime.nullCheck(from, fromExpr);\n\t\t\t\t\truntime.nullCheck(forElt, forExpr);\n\t\t\t\t\tvar clazz = eltColl.className;\n\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\ttarget.classList.remove(clazz);\n\t\t\t\t\t});\n\t\t\t\t\truntime.implicitLoop(forElt, function (target) {\n\t\t\t\t\t\ttarget.classList.add(clazz);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn takeCmd;\n\t\t}\n\t});\n\n\tfunction putInto(runtime, context, prop, valueToPut) {\n\t\tif (prop) {\n\t\t\tvar value = runtime.resolveSymbol(prop, context);\n\t\t} else {\n\t\t\tvar value = context;\n\t\t}\n\t\tif (value instanceof Element || value instanceof HTMLDocument) {\n\t\t\twhile (value.firstChild) value.removeChild(value.firstChild);\n\t\t\tvalue.append(_hyperscript.internals.runtime.convertValue(valueToPut, \"Fragment\"));\n\t\t} else {\n\t\t\tif (prop) {\n\t\t\t\truntime.setSymbol(prop, context, null, valueToPut);\n\t\t\t} else {\n\t\t\t\tthrow \"Don't know how to put a value into \" + typeof context;\n\t\t\t}\n\t\t}\n\t}\n\n\t_hyperscript.addCommand(\"put\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"put\")) {\n\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n\t\t\tif (operationToken == null && tokens.matchToken(\"at\")) {\n\t\t\t\ttokens.matchToken(\"the\"); // optional \"the\"\n\t\t\t\toperationToken = tokens.matchAnyToken(\"start\", \"end\");\n\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t}\n\n\t\t\tif (operationToken == null) {\n\t\t\t\tparser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n\t\t\t}\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar operation = operationToken.value;\n\n\t\t\tvar symbolWrite = false;\n\t\t\tvar rootExpr = null;\n\t\t\tvar prop = null;\n\t\t\tif (target.prop && target.root && operation === \"into\") {\n\t\t\t\tprop = target.prop.value;\n\t\t\t\trootExpr = target.root;\n\t\t\t} else if (target.type === \"symbol\" && operation === \"into\") {\n\t\t\t\tsymbolWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t} else if (target.type === \"attributeRef\" && operation === \"into\") {\n\t\t\t\tvar attributeWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t\trootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t} else if (target.type === \"styleRef\" && operation === \"into\") {\n\t\t\t\tvar styleWrite = true;\n\t\t\t\tprop = target.name;\n\t\t\t\trootExpr = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\t} else if (target.attribute && operation === \"into\") {\n\t\t\t\tvar attributeWrite = target.attribute.type === \"attributeRef\";\n\t\t\t\tvar styleWrite = target.attribute.type === \"styleRef\";\n\t\t\t\tprop = target.attribute.name;\n\t\t\t\trootExpr = target.root;\n\t\t\t} else {\n\t\t\t\trootExpr = target;\n\t\t\t}\n\n\t\t\tvar putCmd = {\n\t\t\t\ttarget: target,\n\t\t\t\toperation: operation,\n\t\t\t\tsymbolWrite: symbolWrite,\n\t\t\t\tvalue: value,\n\t\t\t\targs: [rootExpr, value],\n\t\t\t\top: function (context, root, valueToPut) {\n\t\t\t\t\tif (symbolWrite) {\n\t\t\t\t\t\tputInto(runtime, context, prop, valueToPut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.nullCheck(root, rootExpr);\n\t\t\t\t\t\tif (operation === \"into\") {\n\t\t\t\t\t\t\tif (attributeWrite) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\telt.setAttribute(prop, valueToPut);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (styleWrite) {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\telt.style[prop] = valueToPut;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\t\tputInto(runtime, elt, prop, valueToPut);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar op =\n\t\t\t\t\t\t\t\toperation === \"before\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.before\n\t\t\t\t\t\t\t\t\t: operation === \"after\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.after\n\t\t\t\t\t\t\t\t\t: operation === \"start\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.prepend\n\t\t\t\t\t\t\t\t\t: operation === \"end\"\n\t\t\t\t\t\t\t\t\t? Element.prototype.append\n\t\t\t\t\t\t\t\t\t: Element.prototype.append; // unreachable\n\n\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\top.call(\n\t\t\t\t\t\t\t\t\telt,\n\t\t\t\t\t\t\t\t\tvalueToPut instanceof Node\n\t\t\t\t\t\t\t\t\t\t? valueToPut\n\t\t\t\t\t\t\t\t\t\t: runtime.convertValue(valueToPut, \"Fragment\")\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn putCmd;\n\t\t}\n\t});\n\n\tfunction parsePseudopossessiveTarget(parser, runtime, tokens) {\n\t\tvar targets;\n\t\tif (\n\t\t\ttokens.matchToken(\"the\") ||\n\t\t\ttokens.matchToken(\"element\") ||\n\t\t\ttokens.matchToken(\"elements\") ||\n\t\t\ttokens.currentToken().type === \"CLASS_REF\" ||\n\t\t\ttokens.currentToken().type === \"ID_REF\" ||\n\t\t\t(tokens.currentToken().op && tokens.currentToken().value === \"<\")\n\t\t) {\n\t\t\tparser.possessivesDisabled = true;\n\t\t\ttry {\n\t\t\t\ttargets = parser.parseElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\tdelete parser.possessivesDisabled;\n\t\t\t}\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n\t\t\tvar identifier = tokens.matchToken(\"its\");\n\t\t\ttargets = {\n\t\t\t\ttype: \"pseudopossessiveIts\",\n\t\t\t\ttoken: identifier,\n\t\t\t\tname: identifier.value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(\"it\", context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\ttokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n\t\t\ttargets = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t}\n\t\treturn targets;\n\t}\n\n\t_hyperscript.addCommand(\"transition\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"transition\")) {\n\t\t\tvar targetsExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\t\tvar properties = [];\n\t\t\tvar from = [];\n\t\t\tvar to = [];\n\t\t\tvar currentToken = tokens.currentToken();\n\t\t\twhile (\n\t\t\t\t!parser.commandBoundary(currentToken) &&\n\t\t\t\tcurrentToken.value !== \"over\" &&\n\t\t\t\tcurrentToken.value !== \"using\"\n\t\t\t) {\n\t\t\t\tif (tokens.currentToken().type === \"STYLE_REF\") {\n\t\t\t\t\tlet styleRef = tokens.consumeToken();\n\t\t\t\t\tlet styleProp = styleRef.value.substr(1);\n\t\t\t\t\tproperties.push({\n\t\t\t\t\t\ttype: \"styleRefValue\",\n\t\t\t\t\t\tevaluate: function () {\n\t\t\t\t\t\t\treturn styleProp;\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tproperties.push(parser.requireElement(\"stringLike\", tokens));\n\t\t\t\t}\n\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tfrom.push(parser.requireElement(\"expression\", tokens));\n\t\t\t\t} else {\n\t\t\t\t\tfrom.push(null);\n\t\t\t\t}\n\t\t\t\ttokens.requireToken(\"to\");\n\t\t\t\tto.push(parser.requireElement(\"expression\", tokens));\n\t\t\t\tcurrentToken = tokens.currentToken();\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"over\")) {\n\t\t\t\tvar over = parser.requireElement(\"expression\", tokens);\n\t\t\t} else if (tokens.matchToken(\"using\")) {\n\t\t\t\tvar using = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\tvar transition = {\n\t\t\t\tto: to,\n\t\t\t\targs: [targetsExpr, properties, from, to, using, over],\n\t\t\t\top: function (context, targets, properties, from, to, using, over) {\n\t\t\t\t\truntime.nullCheck(targets, targetsExpr);\n\t\t\t\t\tvar promises = [];\n\t\t\t\t\truntime.implicitLoop(targets, function (target) {\n\t\t\t\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\tvar initialTransition = target.style.transition;\n\t\t\t\t\t\t\tif (over) {\n\t\t\t\t\t\t\t\ttarget.style.transition = \"all \" + over + \"ms ease-in\";\n\t\t\t\t\t\t\t} else if (using) {\n\t\t\t\t\t\t\t\ttarget.style.transition = using;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.style.transition = _hyperscript.config.defaultTransition;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\t\tvar computedStyles = getComputedStyle(target);\n\n\t\t\t\t\t\t\tvar initialStyles = {};\n\t\t\t\t\t\t\tfor (var i = 0; i < computedStyles.length; i++) {\n\t\t\t\t\t\t\t\tvar name = computedStyles[i];\n\t\t\t\t\t\t\t\tvar initialValue = computedStyles[name];\n\t\t\t\t\t\t\t\tinitialStyles[name] = initialValue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// store intitial values\n\t\t\t\t\t\t\tif (!internalData.initalStyles) {\n\t\t\t\t\t\t\t\tinternalData.initalStyles = initialStyles;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\tvar fromVal = from[i];\n\t\t\t\t\t\t\t\tif (fromVal === \"computed\" || fromVal == null) {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = initialStyles[property];\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = fromVal;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//console.log(\"transition started\", transition);\n\n\t\t\t\t\t\t\tvar transitionStarted = false;\n\t\t\t\t\t\t\tvar resolved = false;\n\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\t\t\t//console.log(\"transition ended\", transition);\n\t\t\t\t\t\t\t\t\t\ttarget.style.transition = initialTransition;\n\t\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\t\"transitionstart\",\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\ttransitionStarted = true;\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// it no transition has started in 100ms, continue\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tif (!resolved && !transitionStarted) {\n\t\t\t\t\t\t\t\t\t//console.log(\"transition ended\", transition);\n\t\t\t\t\t\t\t\t\ttarget.style.transition = initialTransition;\n\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 100);\n\n\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\tvar autoProps = [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\t\tvar toVal = to[i];\n\t\t\t\t\t\t\t\t\tif (toVal === \"initial\") {\n\t\t\t\t\t\t\t\t\t\tvar propertyValue = internalData.initalStyles[property];\n\t\t\t\t\t\t\t\t\t\ttarget.style[property] = propertyValue;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ttarget.style[property] = toVal;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t//console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpromises.push(promise);\n\t\t\t\t\t});\n\t\t\t\t\treturn Promise.all(promises).then(function () {\n\t\t\t\t\t\treturn runtime.findNext(transition, context);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn transition;\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"measure\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"measure\")) return;\n\n\t\tvar targetExpr = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\tvar propsToMeasure = [];\n\t\tif (!parser.commandBoundary(tokens.currentToken()))\n\t\t\tdo {\n\t\t\t\tpropsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\n\t\treturn {\n\t\t\tproperties: propsToMeasure,\n\t\t\targs: [targetExpr],\n\t\t\top: function (ctx, target) {\n\t\t\t\truntime.nullCheck(target, targetExpr);\n\t\t\t\tif (0 in target) target = target[0]; // not measuring multiple elts\n\t\t\t\tvar rect = target.getBoundingClientRect();\n\t\t\t\tvar scroll = {\n\t\t\t\t\ttop: target.scrollTop,\n\t\t\t\t\tleft: target.scrollLeft,\n\t\t\t\t\ttopMax: target.scrollTopMax,\n\t\t\t\t\tleftMax: target.scrollLeftMax,\n\t\t\t\t\theight: target.scrollHeight,\n\t\t\t\t\twidth: target.scrollWidth,\n\t\t\t\t};\n\n\t\t\t\tctx.result = {\n\t\t\t\t\tx: rect.x,\n\t\t\t\t\ty: rect.y,\n\t\t\t\t\tleft: rect.left,\n\t\t\t\t\ttop: rect.top,\n\t\t\t\t\tright: rect.right,\n\t\t\t\t\tbottom: rect.bottom,\n\t\t\t\t\twidth: rect.width,\n\t\t\t\t\theight: rect.height,\n\t\t\t\t\tbounds: rect,\n\n\t\t\t\t\tscrollLeft: scroll.left,\n\t\t\t\t\tscrollTop: scroll.top,\n\t\t\t\t\tscrollLeftMax: scroll.leftMax,\n\t\t\t\t\tscrollTopMax: scroll.topMax,\n\t\t\t\t\tscrollWidth: scroll.width,\n\t\t\t\t\tscrollHeight: scroll.height,\n\t\t\t\t\tscroll: scroll,\n\t\t\t\t};\n\n\t\t\t\truntime.forEach(propsToMeasure, function (prop) {\n\t\t\t\t\tif (prop in ctx.result) ctx[prop] = ctx.result[prop];\n\t\t\t\t\telse throw \"No such measurement as \" + prop;\n\t\t\t\t});\n\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t});\n\n\t_hyperscript.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"closest\")) {\n\t\t\tif (tokens.matchToken(\"parent\")) {\n\t\t\t\tvar parentSearch = true;\n\t\t\t}\n\n\t\t\tvar css = null;\n\t\t\tif (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\tvar attributeRef = parser.requireElement(\"attributeRefAccess\", tokens, null);\n\t\t\t\tcss = \"[\" + attributeRef.attribute.name + \"]\";\n\t\t\t}\n\n\t\t\tif (css == null) {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t\tif (expr.css == null) {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected a CSS expression\");\n\t\t\t\t} else {\n\t\t\t\t\tcss = expr.css;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\tvar to = parser.parseElement(\"expression\", tokens);\n\t\t\t} else {\n\t\t\t\tvar to = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t\t}\n\n\t\t\tvar closestExpr = {\n\t\t\t\ttype: \"closestExpr\",\n\t\t\t\tparentSearch: parentSearch,\n\t\t\t\texpr: expr,\n\t\t\t\tcss: css,\n\t\t\t\tto: to,\n\t\t\t\targs: [to],\n\t\t\t\top: function (ctx, to) {\n\t\t\t\t\tif (to == null || !(to instanceof Element)) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (parentSearch) {\n\t\t\t\t\t\t\tvar node = to.parentElement ? to.parentElement.closest(css) : null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar node = to.closest(css);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\tif (attributeRef) {\n\t\t\t\tattributeRef.root = closestExpr;\n\t\t\t\tattributeRef.args = [closestExpr];\n\t\t\t\treturn attributeRef;\n\t\t\t} else {\n\t\t\t\treturn closestExpr;\n\t\t\t}\n\t\t}\n\t});\n\n\t_hyperscript.addCommand(\"go\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"go\")) {\n\t\t\tif (tokens.matchToken(\"back\")) {\n\t\t\t\tvar back = true;\n\t\t\t} else {\n\t\t\t\ttokens.matchToken(\"to\");\n\t\t\t\tif (tokens.matchToken(\"url\")) {\n\t\t\t\t\tvar target = parser.requireElement(\"stringLike\", tokens);\n\t\t\t\t\tvar url = true;\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\ttokens.requireToken(\"new\");\n\t\t\t\t\t\ttokens.requireToken(\"window\");\n\t\t\t\t\t\tvar newWindow = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttokens.matchToken(\"the\"); // optional the\n\t\t\t\t\tvar verticalPosition = tokens.matchAnyToken(\"top\", \"bottom\", \"middle\");\n\t\t\t\t\tvar horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n\t\t\t\t\tif (verticalPosition || horizontalPosition) {\n\t\t\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t\t\t}\n\t\t\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\t\t\t\tvar smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n\t\t\t\t\tvar scrollOptions = {};\n\t\t\t\t\tif (verticalPosition) {\n\t\t\t\t\t\tif (verticalPosition.value === \"top\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"start\";\n\t\t\t\t\t\t} else if (verticalPosition.value === \"bottom\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"end\";\n\t\t\t\t\t\t} else if (verticalPosition.value === \"middle\") {\n\t\t\t\t\t\t\tscrollOptions.block = \"center\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (horizontalPosition) {\n\t\t\t\t\t\tif (horizontalPosition.value === \"left\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"start\";\n\t\t\t\t\t\t} else if (horizontalPosition.value === \"center\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"center\";\n\t\t\t\t\t\t} else if (horizontalPosition.value === \"right\") {\n\t\t\t\t\t\t\tscrollOptions.inline = \"end\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (smoothness) {\n\t\t\t\t\t\tif (smoothness.value === \"smoothly\") {\n\t\t\t\t\t\t\tscrollOptions.behavior = \"smooth\";\n\t\t\t\t\t\t} else if (smoothness.value === \"instantly\") {\n\t\t\t\t\t\t\tscrollOptions.behavior = \"instant\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar goCmd = {\n\t\t\t\ttarget: target,\n\t\t\t\targs: [target],\n\t\t\t\top: function (ctx, to) {\n\t\t\t\t\tif (back) {\n\t\t\t\t\t\twindow.history.back();\n\t\t\t\t\t} else if (url) {\n\t\t\t\t\t\tif (to) {\n\t\t\t\t\t\t\tif (to.indexOf(\"#\") === 0 && !newWindow) {\n\t\t\t\t\t\t\t\twindow.location.href = to;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twindow.open(to, newWindow ? \"_blank\" : null);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\t\t\ttarget.scrollIntoView(scrollOptions);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(goCmd, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn goCmd;\n\t\t}\n\t});\n\n\t_hyperscript.config.conversions[\"Values\"] = function (/** @type {Node | NodeList} */ node) {\n\t\t/** @type Object<string,string | string[]> */\n\t\tvar result = {};\n\n\t\tvar implicitLoop = _hyperscript.internals.runtime.implicitLoop;\n\n\t\timplicitLoop(node, function (/** @type HTMLInputElement */ node) {\n\t\t\t// Try to get a value directly from this node\n\t\t\tvar input = getInputInfo(node);\n\n\t\t\tif (input !== undefined) {\n\t\t\t\tresult[input.name] = input.value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Otherwise, try to query all child elements of this node that *should* contain values.\n\t\t\tif (node.querySelectorAll != undefined) {\n\t\t\t\tvar children = node.querySelectorAll(\"input,select,textarea\");\n\t\t\t\tchildren.forEach(appendValue);\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\n\t\t/**\n\t\t * @param {HTMLInputElement} node\n\t\t */\n\t\tfunction appendValue(node) {\n\t\t\tvar info = getInputInfo(node);\n\n\t\t\tif (info == undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// If there is no value already stored in this space.\n\t\t\tif (result[info.name] == undefined) {\n\t\t\t\tresult[info.name] = info.value;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n\t\t\t\tresult[info.name] = [].concat(result[info.name], info.value);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {HTMLInputElement} node\n\t\t * @returns {{name:string, value:string | string[]} | undefined}\n\t\t */\n\t\tfunction getInputInfo(node) {\n\t\t\ttry {\n\t\t\t\t/** @type {{name: string, value: string | string[]}}*/\n\t\t\t\tvar result = {\n\t\t\t\t\tname: node.name,\n\t\t\t\t\tvalue: node.value,\n\t\t\t\t};\n\n\t\t\t\tif (result.name == undefined || result.value == undefined) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"radio\" && node.checked == false) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"checkbox\") {\n\t\t\t\t\tif (node.checked == false) {\n\t\t\t\t\t\tresult.value = undefined;\n\t\t\t\t\t} else if (typeof result.value === \"string\") {\n\t\t\t\t\t\tresult.value = [result.value];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (node.type == \"select-multiple\") {\n\t\t\t\t\t/** @type {NodeListOf<HTMLSelectElement>} */\n\t\t\t\t\tvar selected = node.querySelectorAll(\"option[selected]\");\n\n\t\t\t\t\tresult.value = [];\n\t\t\t\t\tfor (var index = 0; index < selected.length; index++) {\n\t\t\t\t\t\tresult.value.push(selected[index].value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} catch (e) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\t};\n\n\t_hyperscript.config.conversions[\"HTML\"] = function (value) {\n\t\tvar toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n\t\t\tif (value instanceof Array) {\n\t\t\t\treturn value\n\t\t\t\t\t.map(function (item) {\n\t\t\t\t\t\treturn toHTML(item);\n\t\t\t\t\t})\n\t\t\t\t\t.join(\"\");\n\t\t\t}\n\n\t\t\tif (value instanceof HTMLElement) {\n\t\t\t\treturn value.outerHTML;\n\t\t\t}\n\n\t\t\tif (value instanceof NodeList) {\n\t\t\t\tvar result = \"\";\n\t\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\t\tvar node = value[i];\n\t\t\t\t\tif (node instanceof HTMLElement) {\n\t\t\t\t\t\tresult += node.outerHTML;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tif (value.toString) {\n\t\t\t\treturn value.toString();\n\t\t\t}\n\n\t\t\treturn \"\";\n\t\t};\n\n\t\treturn toHTML(value);\n\t};\n\n\t_hyperscript.config.conversions[\"Fragment\"] = function (val) {\n\t\tvar frag = document.createDocumentFragment();\n\t\t_hyperscript.internals.runtime.implicitLoop(val, function (val) {\n\t\t\tif (val instanceof Node) frag.append(val);\n\t\t\telse {\n\t\t\t\tvar temp = document.createElement(\"template\");\n\t\t\t\ttemp.innerHTML = val;\n\t\t\t\tfrag.append(temp.content);\n\t\t\t}\n\t\t});\n\t\treturn frag;\n\t};\n}\n","\nimport _hyperscript from \"../lib/core.js\"\n\nimport web from \"../lib/web.js\"\nimport worker from \"../lib/plugin/worker.js\"\nimport socket from \"../lib/plugin/socket.js\"\nimport eventsource from \"../lib/plugin/eventsource.js\"\nimport template from \"../lib/plugin/template.js\"\nimport hdb from \"../lib/plugin/hdb.js\"\n\nweb(_hyperscript)\nworker(_hyperscript)\nsocket(_hyperscript)\neventsource(_hyperscript)\ntemplate(_hyperscript)\nhdb(_hyperscript)\n\nexport default _hyperscript","///=========================================================================\n/// This module provides the worker feature for hyperscript\n///=========================================================================\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\n\tvar invocationIdCounter = 0;\n\n\tvar workerFunc = function (self) {\n\t\tself.onmessage = function (e) {\n\t\t\tswitch (e.data.type) {\n\t\t\t\tcase \"init\":\n\t\t\t\t\tself.importScripts(e.data._hyperscript);\n\t\t\t\t\tself.importScripts.apply(self, e.data.extraScripts);\n\t\t\t\t\tconst _hyperscript = self['_hyperscript']\n\t\t\t\t\tvar tokens = _hyperscript.internals.lexer.makeTokensObject(e.data.tokens, [], e.data.source);\n\t\t\t\t\tvar hyperscript = _hyperscript.internals.parser.parseElement(\"hyperscript\", tokens);\n\t\t\t\t\thyperscript.apply(self, self);\n\t\t\t\t\tpostMessage({ type: \"didInit\" });\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"call\":\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar result = self['_hyperscript'].internals.runtime\n\t\t\t\t\t\t\t.getHyperscriptFeatures(self)[e.data.function]\n\t\t\t\t\t\t\t.apply(self, e.data.args);\n\t\t\t\t\t\tPromise.resolve(result)\n\t\t\t\t\t\t\t.then(function (value) {\n\t\t\t\t\t\t\t\tpostMessage({\n\t\t\t\t\t\t\t\t\ttype: \"resolve\",\n\t\t\t\t\t\t\t\t\tid: e.data.id,\n\t\t\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.catch(function (error) {\n\t\t\t\t\t\t\t\tpostMessage({\n\t\t\t\t\t\t\t\t\ttype: \"reject\",\n\t\t\t\t\t\t\t\t\tid: e.data.id,\n\t\t\t\t\t\t\t\t\terror: error.toString(),\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tpostMessage({\n\t\t\t\t\t\t\ttype: \"reject\",\n\t\t\t\t\t\t\tid: e.data.id,\n\t\t\t\t\t\t\terror: error.toString(),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t};\n\n\t// extract the body of the function, which was only defined so\n\t// that we can get syntax highlighting\n\tvar workerCode = \"(\" + workerFunc.toString() + \")(self)\";\n\tvar blob = new Blob([workerCode], { type: \"text/javascript\" });\n\tvar workerUri = URL.createObjectURL(blob);\n\n\t_hyperscript.addFeature(\"worker\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"worker\")) {\n\t\t\tvar name = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\t\tvar qualifiedName = name.evaluate();\n\t\t\tvar nameSpace = qualifiedName.split(\".\");\n\t\t\tvar workerName = nameSpace.pop();\n\n\t\t\t// Parse extra scripts\n\t\t\tvar extraScripts = [];\n\t\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t\t// no external scripts\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tvar extraScript = tokens.requireTokenType(\"STRING\").value;\n\t\t\t\t\t\tvar absoluteUrl = new URL(extraScript, location.href).href;\n\t\t\t\t\t\textraScripts.push(absoluteUrl);\n\t\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Consume worker methods\n\n\t\t\tvar funcNames = [];\n\t\t\tvar bodyStartIndex = tokens.consumed.length;\n\t\t\tvar bodyEndIndex = tokens.consumed.length;\n\t\t\tdo {\n\t\t\t\tvar feature = parser.parseAnyOf([\"defFeature\", \"jsFeature\"], tokens);\n\t\t\t\tif (feature) {\n\t\t\t\t\tif (feature.type === \"defFeature\") {\n\t\t\t\t\t\tfuncNames.push(feature.name);\n\t\t\t\t\t\tbodyEndIndex = tokens.consumed.length;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (tokens.hasMore()) continue;\n\t\t\t\t\t}\n\t\t\t\t} else break;\n\t\t\t} while (tokens.matchToken(\"end\") && tokens.hasMore()); // worker end\n\n\t\t\tvar bodyTokens = tokens.consumed.slice(bodyStartIndex, bodyEndIndex + 1);\n\n\t\t\t// Create worker\n\n\t\t\tvar worker = new Worker(workerUri);\n\n\t\t\t// Send init message to worker\n\n\t\t\tworker.postMessage({\n\t\t\t\ttype: \"init\",\n\t\t\t\t_hyperscript: runtime.hyperscriptUrl,\n\t\t\t\textraScripts: extraScripts,\n\t\t\t\ttokens: bodyTokens,\n\t\t\t\tsource: tokens.source,\n\t\t\t});\n\n\t\t\tvar workerPromise = new Promise(function (resolve, reject) {\n\t\t\t\tworker.addEventListener(\n\t\t\t\t\t\"message\",\n\t\t\t\t\tfunction (e) {\n\t\t\t\t\t\tif (e.data.type === \"didInit\") resolve();\n\t\t\t\t\t},\n\t\t\t\t\t{ once: true }\n\t\t\t\t);\n\t\t\t});\n\n\t\t\t// Create function stubs\n\t\t\tvar stubs = {};\n\t\t\tfuncNames.forEach(function (funcName) {\n\t\t\t\tconsole.log(funcName)\n\t\t\t\tstubs[funcName] = function () {\n\t\t\t\t\tvar args = arguments;\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tvar id = invocationIdCounter++;\n\t\t\t\t\t\tworker.addEventListener(\"message\", function returnListener(e) {\n\t\t\t\t\t\t\tif (e.data.id !== id) return;\n\t\t\t\t\t\t\tworker.removeEventListener(\"message\", returnListener);\n\t\t\t\t\t\t\tif (e.data.type === \"resolve\") resolve(e.data.value);\n\t\t\t\t\t\t\telse reject(e.data.error);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tworkerPromise.then(function () {\n\t\t\t\t\t\t\t// Worker has been initialized, send invocation.\n\t\t\t\t\t\t\tworker.postMessage({\n\t\t\t\t\t\t\t\ttype: \"call\",\n\t\t\t\t\t\t\t\tfunction: funcName,\n\t\t\t\t\t\t\t\targs: Array.from(args),\n\t\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tname: workerName,\n\t\t\t\tworker: worker,\n\t\t\t\tinstall: function (target) {\n\t\t\t\t\truntime.assignToNamespace(target, nameSpace, workerName, stubs);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n}\n","///=========================================================================\n/// This module provides the EventSource (SSE) feature for hyperscript\n///=========================================================================\n\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\t_hyperscript.addFeature(\"eventsource\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"eventsource\")) {\n\t\t\tvar urlElement;\n\t\t\tvar withCredentials = false;\n\n\t\t\t// Get the name we'll assign to this EventSource in the hyperscript context\n\t\t\t/** @type {string} */\n\t\t\tvar name = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\t\tvar nameSpace = name.split(\".\");\n\t\t\tvar eventSourceName = nameSpace.pop();\n\n\t\t\t// Get the URL of the EventSource\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\turlElement = parser.requireElement(\"stringLike\", tokens);\n\t\t\t}\n\n\t\t\t// Get option to connect with/without credentials\n\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\tif (tokens.matchToken(\"credentials\")) {\n\t\t\t\t\twithCredentials = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/** @type {EventSourceStub} */\n\t\t\tvar stub = {\n\t\t\t\teventSource: null,\n\t\t\t\tlisteners: [],\n\t\t\t\tretryCount: 0,\n\t\t\t\topen: function (url) {\n\t\t\t\t\t// calculate default values for URL argument.\n\t\t\t\t\tif (url == undefined) {\n\t\t\t\t\t\tif (stub.eventSource != null && stub.eventSource.url != undefined) {\n\t\t\t\t\t\t\turl = stub.eventSource.url;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow \"no url defined for EventSource.\";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Guard multiple opens on the same EventSource\n\t\t\t\t\tif (stub.eventSource != null) {\n\t\t\t\t\t\t// If we're opening a new URL, then close the old one first.\n\t\t\t\t\t\tif (url != stub.eventSource.url) {\n\t\t\t\t\t\t\tstub.eventSource.close();\n\t\t\t\t\t\t} else if (stub.eventSource.readyState != EventSource.CLOSED) {\n\t\t\t\t\t\t\t// Otherwise, we already have the right connection open, so there's nothing left to do.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Open the EventSource and get ready to populate event handlers\n\t\t\t\t\tstub.eventSource = new EventSource(url, {\n\t\t\t\t\t\twithCredentials: withCredentials,\n\t\t\t\t\t});\n\n\t\t\t\t\t// On successful connection.  Reset retry count.\n\t\t\t\t\tstub.eventSource.addEventListener(\"open\", function (event) {\n\t\t\t\t\t\tstub.retryCount = 0;\n\t\t\t\t\t});\n\n\t\t\t\t\t// On connection error, use exponential backoff to retry (random values from 1 second to 2^7 (128) seconds\n\t\t\t\t\tstub.eventSource.addEventListener(\"error\", function (event) {\n\t\t\t\t\t\t// If the EventSource is closed, then try to reopen\n\t\t\t\t\t\tif (stub.eventSource.readyState == EventSource.CLOSED) {\n\t\t\t\t\t\t\tstub.retryCount = Math.min(7, stub.retryCount + 1);\n\t\t\t\t\t\t\tvar timeout = Math.random() * (2 ^ stub.retryCount) * 500;\n\t\t\t\t\t\t\twindow.setTimeout(stub.open, timeout);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t// Add event listeners\n\t\t\t\t\tfor (var index = 0; index < stub.listeners.length; index++) {\n\t\t\t\t\t\tvar item = stub.listeners[index];\n\t\t\t\t\t\tstub.eventSource.addEventListener(item.type, item.handler, item.options);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tif (stub.eventSource != undefined) {\n\t\t\t\t\t\tstub.eventSource.close();\n\t\t\t\t\t}\n\t\t\t\t\tstub.retryCount = 0;\n\t\t\t\t},\n\t\t\t\taddEventListener: function (type, handler, options) {\n\t\t\t\t\tstub.listeners.push({\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\thandler: handler,\n\t\t\t\t\t\toptions: options,\n\t\t\t\t\t});\n\n\t\t\t\t\tif (stub.eventSource != null) {\n\t\t\t\t\t\tstub.eventSource.addEventListener(type, handler, options);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Create the \"feature\" that will be returned by this function.\n\n\t\t\t/** @type {EventSourceFeature} */\n\t\t\tvar feature = {\n\t\t\t\tname: eventSourceName,\n\t\t\t\tobject: stub,\n\t\t\t\tinstall: function (target) {\n\t\t\t\t\truntime.assignToNamespace(target, nameSpace, eventSourceName, stub);\n\t\t\t\t},\n\t\t\t};\n\n\t\t\t// Parse each event listener and add it into the list\n\t\t\twhile (tokens.matchToken(\"on\")) {\n\t\t\t\t// get event name\n\t\t\t\tvar eventName = parser.requireElement(\"stringLike\", tokens, \"Expected event name\").evaluate(); // OK to evaluate this in real-time?\n\n\t\t\t\t// default encoding is \"\" (autodetect)\n\t\t\t\tvar encoding = \"\";\n\n\t\t\t\t// look for alternate encoding\n\t\t\t\tif (tokens.matchToken(\"as\")) {\n\t\t\t\t\tencoding = parser.requireElement(\"stringLike\", tokens, \"Expected encoding type\").evaluate(); // Ok to evaluate this in real time?\n\t\t\t\t}\n\n\t\t\t\t// get command list for this event handler\n\t\t\t\tvar commandList = parser.requireElement(\"commandList\", tokens);\n\t\t\t\taddImplicitReturnToCommandList(commandList);\n\t\t\t\ttokens.requireToken(\"end\");\n\n\t\t\t\t// Save the event listener into the feature.  This lets us\n\t\t\t\t// connect listeners to new EventSources if we have to reconnect.\n\t\t\t\tstub.listeners.push({\n\t\t\t\t\ttype: eventName,\n\t\t\t\t\thandler: makeHandler(encoding, commandList),\n\t\t\t\t});\n\t\t\t}\n\n\t\t\ttokens.requireToken(\"end\");\n\n\t\t\t// If we have a URL element, then connect to the remote server now.\n\t\t\t// Otherwise, we can connect later with a call to .open()\n\t\t\tif (urlElement != undefined) {\n\t\t\t\tstub.open(urlElement.evaluate());\n\t\t\t}\n\n\t\t\t// Success!\n\t\t\treturn feature;\n\n\t\t\t////////////////////////////////////////////\n\t\t\t// ADDITIONAL HELPER FUNCTIONS HERE...\n\t\t\t////////////////////////////////////////////\n\n\t\t\t/**\n\t\t\t * Makes an eventHandler function that can execute the correct hyperscript commands\n\t\t\t * This is outside of the main loop so that closures don't cause us to run the wrong commands.\n\t\t\t *\n\t\t\t * @param {string} encoding\n\t\t\t * @param {*} commandList\n\t\t\t * @returns {EventHandlerNonNull}\n\t\t\t */\n\t\t\tfunction makeHandler(encoding, commandList) {\n\t\t\t\treturn function (evt) {\n\t\t\t\t\tvar data = decode(evt[\"data\"], encoding);\n\t\t\t\t\tvar context = runtime.makeContext(stub, feature, stub);\n\t\t\t\t\tcontext.event = evt;\n\t\t\t\t\tcontext.result = data;\n\t\t\t\t\tcommandList.execute(context);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Decodes/Unmarshals a string based on the selected encoding.  If the\n\t\t\t * encoding is not recognized, attempts to auto-detect based on its content\n\t\t\t *\n\t\t\t * @param {string} data - The original data to be decoded\n\t\t\t * @param {string} encoding - The method that the data is currently encoded (\"string\", \"json\", or unknown)\n\t\t\t * @returns {string} - The decoded data\n\t\t\t */\n\t\t\tfunction decode(data, encoding) {\n\t\t\t\t// Force JSON encoding\n\t\t\t\tif (encoding == \"json\") {\n\t\t\t\t\treturn JSON.parse(data);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, return the data without modification\n\t\t\t\treturn data;\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Adds a \"HALT\" command to the commandList.\n\t\t\t * TODO: This seems like something that could be optimized:\n\t\t\t * maybe the parser could do automatically,\n\t\t\t * or could be a public function in the parser available to everyone,\n\t\t\t * or the command-executer-thingy could just handle nulls implicitly.\n\t\t\t *\n\t\t\t * @param {*} commandList\n\t\t\t * @returns void\n\t\t\t */\n\t\t\tfunction addImplicitReturnToCommandList(commandList) {\n\t\t\t\tif (commandList.next) {\n\t\t\t\t\treturn addImplicitReturnToCommandList(commandList.next);\n\t\t\t\t}\n\n\t\t\t\tcommandList.next = {\n\t\t\t\t\ttype: \"implicitReturn\",\n\t\t\t\t\top: function (/** @type {Context} */ _context) {\n\t\t\t\t\t\treturn runtime.HALT;\n\t\t\t\t\t},\n\t\t\t\t\texecute: function (/** @type {Context} */ _context) {\n\t\t\t\t\t\t// do nothing\n\t\t\t\t\t},\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t});\n}","\n/**\n * @param {HyperscriptObject} _hyperscript\n */\nexport default _hyperscript => {\n\tfunction HDB(ctx, runtime, breakpoint) {\n\t\tthis.ctx = ctx;\n\t\tthis.runtime = runtime;\n\t\tthis.cmd = breakpoint;\n\t\tthis._hyperscript = _hyperscript;\n\n\t\tthis.cmdMap = [];\n\n\t\tthis.bus = new EventTarget();\n\t} // See below for methods\n\n\t_hyperscript.addCommand(\"breakpoint\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"breakpoint\")) return;\n\n\t\tvar hdb;\n\n\t\treturn {\n\t\t\top: function (ctx) {\n\t\t\t\tglobalThis.hdb = hdb = new HDB(ctx, runtime, this);\n\t\t\t\ttry {\n\t\t\t\t\treturn hdb.break(ctx);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.error(e, e.stack);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\tHDB.prototype.break = function(ctx) {\n\t\tconsole.log(\"=== HDB///_hyperscript/debugger ===\");\n\t\tthis.ui();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.bus.addEventListener(\n\t\t\t\t\"continue\",\n\t\t\t\t() => {\n\t\t\t\t\tif (this.ctx !== ctx) {\n\t\t\t\t\t\t// Context switch\n\t\t\t\t\t\tfor (var attr in ctx) {\n\t\t\t\t\t\t\tdelete ctx[attr];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tObject.assign(ctx, this.ctx);\n\t\t\t\t\t}\n\t\t\t\t\tdelete window['hdb'];\n\t\t\t\t\tresolve(this.runtime.findNext(this.cmd, this.ctx));\n\t\t\t\t},\n\t\t\t\t{ once: true }\n\t\t\t);\n\t\t});\n\t};\n\n\tHDB.prototype.continueExec = function () {\n\t\tthis.bus.dispatchEvent(new Event(\"continue\"));\n\t};\n\n\tHDB.prototype.stepOver = function () {\n\t\tif (!this.cmd) return this.continueExec();\n\t\tvar result =\n\t\t\tthis.cmd && this.cmd.type === \"breakpointCommand\"\n\t\t\t\t? this.runtime.findNext(this.cmd, this.ctx)\n\t\t\t\t: this.runtime.unifiedEval(this.cmd, this.ctx);\n\t\tif (result.type === \"implicitReturn\") return this.stepOut();\n\t\tif (result && result.then instanceof Function) {\n\t\t\treturn result.then(next => {\n\t\t\t\tthis.cmd = next;\n\t\t\t\tthis.bus.dispatchEvent(new Event(\"step\"));\n\t\t\t\tthis.logCommand();\n\t\t\t});\n\t\t} else if (result.halt_flag) {\n\t\t\tthis.bus.dispatchEvent(new Event(\"continue\"));\n\t\t} else {\n\t\t\tthis.cmd = result;\n\t\t\tthis.bus.dispatchEvent(new Event(\"step\"));\n\t\t\tthis.logCommand();\n\t\t}\n\t};\n\n\tHDB.prototype.stepOut = function () {\n\t\tif (!this.ctx.meta.caller) return this.continueExec();\n\t\tvar callingCmd = this.ctx.meta.callingCommand;\n\t\tvar oldMe = this.ctx.me;\n\t\tthis.ctx = this.ctx.meta.caller;\n\t\tconsole.log(\n\t\t\t\"[hdb] stepping out into \" + this.ctx.meta.feature.displayName)\n\t\tif (this.ctx.me instanceof Element && this.ctx.me !== oldMe) {\n\t\t\tconsole.log(\"[hdb] me: \", this.ctx.me)\n\t\t}\n\t\tthis.cmd = this.runtime.findNext(callingCmd, this.ctx);\n\t\tthis.cmd = this.runtime.findNext(this.cmd, this.ctx);\n\t\tthis.logCommand();\n\t\tthis.bus.dispatchEvent(new Event(\"step\"));\n\t};\n\n\tHDB.prototype.skipTo = function (toCmd) {\n\t\tthis.cmd = toCmd.cmd\n\t\tthis.bus.dispatchEvent(new Event(\"skip\"));\n\t}\n\n\tHDB.prototype.rewrite = function (command, newCode) {\n\t\tconsole.log('##', command)\n\t\tconst parent = command.cmd.parent\n\t\tlet prev\n\t\tfor (prev of parent.children) {\n\t\t\tif (prev.next === command.cmd) break;\n\t\t}\n\t\tconst next = command.next\n\n\t\tconst tok = _hyperscript.internals.lexer.tokenize(newCode)\n\t\tconst newcmd = _hyperscript.internals.parser.requireElement('command', tok)\n\n\t\tconsole.log(newcmd)\n\t\tnewcmd.startToken    = command.startToken\n\t\tnewcmd.endToken      = command.endToken\n\t\tnewcmd.programSource = command.programSource\n\t\tnewcmd.sourceFor = function () { return newCode }\n\n\t\tprev.next = newcmd\n\t\tnewcmd.next = next\n\t\tnewcmd.parent = parent\n\n\t\tthis.bus.dispatchEvent(new Event('step'))\n\t}\n\n\tHDB.prototype.logCommand = function () {\n\t\tvar hasSource = this.cmd.sourceFor instanceof Function;\n\t\tvar cmdSource = hasSource ? this.cmd.sourceFor() : '-- '+this.cmd.type;\n\t\tconsole.log(\"[hdb] current command: \" + cmdSource)\n\t}\n\n\tHDB.prototype.traverse = function (ge) {\n\t\tconst rv = [];\n\n\t\t(function recurse (ge) {\n\t\t\trv.push(ge);\n\t\t\tfor (const child of ge.children) recurse(rv);\n\t\t})(ge);\n\n\t\treturn rv;\n\t}\n\n\tvar ui = `\n<div class=\"hdb\" _=\"\n\ton load trigger update end \n\ton step from hdb.bus trigger update end\n\ton skip from hdb.bus trigger update end\n\ton continue from hdb.bus log 'done' then remove me.getRootNode().host\">\n\n\t<script type=\"text/hyperscript\">\n\n\tdef escapeHTML(unsafe)\n\t\tjs(unsafe) return unsafe\n\t\t\t.replace(/&/g, \"&amp;\")\n\t\t\t.replace(/</g, \"&lt;\")\n\t\t\t.replace(/>/g, \"&gt;\")\n\t\t\t.replace(/\\\\x22/g, \"&quot;\")\n\t\t\t.replace(/\\\\x27/g, \"&#039;\") end\n\t\treturn it\n\tend\n\n\tdef makeCommandWidget(i)\n\t\tget \\`<span data-cmd=\\${i}><button class=skip data-cmd=\\${i}>&rdca;</button>\\`\n\t\tif hdb.EXPERIMENTAL\n\t\t\tappend \\`<button class=rewrite data-cmd=\\${i}>Rewrite</button></span>\\`\n\t\tend\n\t\treturn it\n\tend\n\n\tdef renderCode\n\t\tset hdb.cmdMap to []\n\t\tset src to hdb.cmd.programSource\n\t\t\n\t\t-- Find feature\n\t\tset feat to hdb.cmd\n\t\trepeat until no feat.parent or feat.isFeature set feat to feat.parent end\n\n\t\t-- Traverse, finding starts\n\t\tfor cmd in hdb.traverse(feat)\n\t\t\tif no cmd.startToken continue end\n\t\t\tappend {\n\t\t\t\tindex: cmd.startToken.start,\n\t\t\t\twidget: makeCommandWidget(hdb.cmdMap.length),\n\t\t\t\tcmd: cmd\n\t\t\t} to hdb.cmdMap\n\t\tend\n\n\t\tset rv to src.slice(0, hdb.cmdMap[0].index)\n\t\tfor obj in hdb.cmdMap index i\n\t\t\tif obj.cmd is hdb.cmd\n\t\t\t\tappend obj.widget + '<u class=current>' +\n\t\t\t\t\tescapeHTML(src.slice(obj.index, hdb.cmdMap[i+1].index)) + '</u>' to rv\n\t\t\telse\n\t\t\t\tappend obj.widget + escapeHTML(src.slice(obj.index, hdb.cmdMap[i+1].index)) to rv\n\t\t\tend\n\t\tend\n\t\treturn rv\n\tend\n\n\tdef truncate(str, len)\n\t\tif str.length <= len return str end\n\t\treturn str.substr(0, len) + ''\n\n\tdef prettyPrint(obj)\n\t\tif obj is null      return 'null'      end\n\t\tif Element.prototype.isPrototypeOf(obj)\n\t\t\tset rv to '&lt;<span class=\"token tagname\">' +\n\t\t\t\tobj.tagName.toLowerCase() + \"</span>\"\n\t\t\tfor attr in Array.from(obj.attributes)\n\t\t\t\tif attr.specified\n\t\t\t\t\tset rv to rv +\n\t\t\t\t\t\t' <span class=\"token attr\">' + attr.nodeName +\n\t\t\t\t\t\t'</span>=<span class=\"token string\">\"' + truncate(attr.textContent, 10) +\n\t\t\t\t\t\t'\"</span>'\n\t\t\t\tend\n\t\t\tend\n\t\t\tset rv to rv + '>'\n\t\t\treturn rv\n\t\telse if obj.call\n\t\t\tif obj.hyperfunc\n\t\t\t\tget \"def \" + obj.hypername + ' ...'\n\t\t\telse\n\t\t\t\tget \"function \"+obj.name+\"(...) {...}\"\n\t\t\tend\n\t\telse if obj.toString\n\t\t\tcall obj.toString()\n\t\tend\n\t\treturn escapeHTML((it or 'undefined').trim())\n\tend\n\t</script>\n\n\t<header _=\"\n\ton pointerdown(clientX, clientY)\n\t\thalt the event\n\t\tcall event.stopPropagation()\n\t\tget first .hdb\n\t\tmeasure its x, y\n\t\tset xoff to clientX - x\n\t\tset yoff to clientY - y\n\t\trepeat until event pointerup from document\n\t\t\twait for pointermove or pointerup from document\n\t\t\tadd {\n\t\t\t\tleft: \\${its clientX - xoff}px;\n\t\t\t\ttop:  \\${its clientY - yoff}px;\n\t\t\t} to .hdb\n\t\tend\n\t\">\n\t\t<h2 class=\"titlebar\">HDB</h2>\n\t\t<ul role=\"toolbar\" class=\"toolbar\" _=\"on pointerdown halt\">\n\t\t\t<li><button _=\"on click call hdb.continueExec()\">\n\t\t\t\t&#x23F5; Continue\n\t\t\t</button>\n\t\t\t<li><button _=\"on click call hdb.stepOver()\">\n\t\t\t\t&#8631; Step Over\n\t\t\t</button>\n\t\t</ul>\n\t</header>\n\n\t<section class=\"sec-code\">\n\n\t\t<div class=\"code-container\">\n\t\t\t<pre class=\"code language-hyperscript\" _=\"\n\t\t\t\ton update from .hdb if hdb.cmd.programSource\n\t\t\t    \tput renderCode() into me\n\t\t\t    \tif Prism\n\t\t\t    \t\tcall Prism.highlightAllUnder(me)\n\t\t\t    \tend\n\t\t\t        go to bottom of .current in me\n\t\t\t\tend\n\n\t\t\t\ton click\n\t\t\t\t\tif target matches .skip\n\t\t\t\t\t\tget (target's @data-cmd) as Int\n\t\t\t\t\t\tcall hdb.skipTo(hdb.cmdMap[result])\n\t\t\t\t\tend\n\t\t\t\t\tif target matches .rewrite\n\t\t\t\t\t\tset cmdNo to (target's @data-cmd) as Int\n\t\t\t\t\t\tset span to the first <span[data-cmd='\\${cmdNo}'] />\n\t\t\t\t\t\tput \\`<form class=rewrite><input id=cmd></form>\\` into the span\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\t\ton submit\n\t\t\t\t\thalt the event\n\t\t\t\t\tget (closest @data-cmd to target) as Int\n\t\t\t\t\tcall hdb.rewrite(hdb.cmdMap[result], #cmd's value)\n\t\t\t\tend\n\t\t\t\"><code></code></pre>\n\t\t</div>\n\t</section>\n\n\t<section class=\"sec-console\" _=\"\n\t\t-- Print context at startup\n\t\tinit repeat for var in Object.keys(hdb.ctx) if var is not 'meta'\n\t\t\tsend hdbUI:consoleEntry(input: var, output: hdb.ctx[var]) to #console\">\n\n\t\t<ul id=\"console\" role=\"list\" _=\"\n\t\t\ton hdbUI:consoleEntry(input, output)\n\t\t\t\tif no hdb.consoleHistory set hdb.consoleHistory to [] end\n\t\t\t\tpush(input) on hdb.consoleHistory\n\t\t\t\tset node to #tmpl-console-entry.content.cloneNode(true)\n\t\t\t\tput the node at end of me\n\t\t\t\tset entry to my lastElementChild\n\t\t\t\tgo to bottom of the entry\n\t\t\t\tput escapeHTML(input) into .input in the entry\n\t\t\t\tif no output\n\t\t\t\t\tcall _hyperscript.internals.runtime.parse(input)\n\t\t\t\t\tif its execute is not undefined then call its execute(hdb.ctx)\n\t\t\t\t\telse call its evaluate(hdb.ctx)\n\t\t\t\t\tend\n\t\t\t\t\tset output to it\n\t\t\t\tend\n\t\t\t\tput prettyPrint(output) as Fragment into .output in the entry\n\t\t\t\">\n\t\t\t<template id=\"tmpl-console-entry\">\n\t\t\t\t<li class=\"console-entry\">\n\t\t\t\t\t<kbd><code class=\"input\"></code></kbd>\n\t\t\t\t\t<samp class=\"output\"></samp>\n\t\t\t\t</li>\n\t\t\t</template>\n\t\t</ul>\n\n\t\t<form id=\"console-form\" data-hist=\"0\" _=\"on submit\n\t\t\t\tsend hdbUI:consoleEntry(input: #console-input's value) to #console\n\t\t\t\tset #console-input's value to ''\n\t\t\t\tset @data-hist to 0\n\t\t\t\tset element oldContent to null\n\t\t\t\thalt\n\t\t\ton keydown[key is 'ArrowUp' or key is 'ArrowDown']\n\t\t\t\tif no hdb.consoleHistory or exit end\n\t\t\t\tif element oldContent is null set element oldContent to #console-input.value end\n\t\t\t\tif event.key is 'ArrowUp' and hdb.consoleHistory.length > -@data-hist\n\t\t\t\t\tdecrement @data-hist\n\t\t\t\telse if event.key is 'ArrowDown' and @data-hist < 0\n\t\t\t\t\tincrement @data-hist\n\t\t\t\tend end\n\t\t\t\tset #console-input.value to hdb.consoleHistory[hdb.consoleHistory.length + @data-hist as Int]\n\t\t\t\t\tor oldContent\n\t\t\t\thalt default\n\t\t\ton input if @data-hist is '0' set element oldContent to #console-input.value\">\n\t\t\t<input id=\"console-input\" placeholder=\"Enter an expression&hellip;\"\n\t\t\t\tautocomplete=\"off\">\n\t\t</form>\n\t</section>\n\n\t<style>\n\t.hdb {\n\t\tborder: 1px solid #888;\n\t\tborder-radius: .3em;\n\t\tbox-shadow: 0 .2em .3em #0008;\n\t\tposition: fixed;\n\t\ttop: .5em; right: .5em;\n\t\twidth: min(40ch, calc(100% - 1em));\n\t\tmax-height: calc(100% - 1em);\n\t\tbackground-color: white;\n\t\tfont-family: sans-serif;\n\t\topacity: .9;\n\t\tz-index: 2147483647;\n\t\tcolor: black;\n\t\tdisplay: flex;\n\t\tflex-flow: column;\n\t}\n\n\t* {\n\t\tbox-sizing: border-box;\n\t}\n\n\theader {\n\t\tdisplay: flex;\n\t\tjustify-content: space-between;\n\t\talign-items: center;\n\t\tpadding: .4em;\n\t}\n\n\t.titlebar {\n\t\tmargin: 0;\n\t\tfont-size: 1em;\n\t\ttouch-action: none;\n\t}\n\n\t.toolbar {\n\t\tdisplay: flex;\n\t\tgap: .35em;\n\n\t\tlist-style: none;\n\t\tpadding-left: 0;\n\t\tmargin: 0;\n\t}\n\n\t.toolbar a, .toolbar button {\n\t\tbackground: #2183ff;\n\t\tborder: 1px solid #3465a4;\n\t\tbox-shadow: 0 1px #b3c6ff inset, 0 .06em .06em #000;\n\t\tborder-radius: .2em;\n\t\tfont: inherit;\n\t\tpadding: .2em .3em;\n\t\tcolor: white;\n\t\ttext-shadow: 0 1px black;\n\t\tfont-weight: bold;\n\t}\n\n\t.toolbar a:hover .toolbar a:focus, .toolbar button:hover, .toolbar button:focus {\n\t\tbackground: #94c8ff;\n\t}\n\n\t.toolbar a:active, .toolbar button:active {\n\t\tbackground: #3465a4;\n\t}\n\n\t.sec-code {\n\t\tborder-radius: .3em;\n\t\toverflow: hidden;\n\t\tbox-shadow: 0 1px white inset, 0 .06em .06em #0008;\n\t\tbackground: #bdf;\n\t\tmargin: 0 .4em;\n\t\tborder: 1px solid #3465a4;\n\t}\n\n\t.hdb h3 {\n\t\tmargin: 0;\n\t\tfont-size: 1em;\n\t\tpadding: .2em .4em 0 .4em;\n\t}\n\n\t.code-container {\n\t\tdisplay: grid;\n\t\tline-height: 1.2em;\n\t\theight: calc(12 * 1.2em);\n\t\tborder-radius: 0 0 .2em .2em;\n\t\toverflow: auto;\n\t\tscrollbar-width: thin;\n\t\tscrollbar-color: #0003 transparent;\n\t}\n\n\t.code, #console, #console-input {\n\t\tfont-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace;\n\t}\n\n\t.code {\n\t\twidth: 0;\n\t\tmargin: 0;\n\t\tpadding-left: 1ch;\n\t\ttab-size: 2;\n\t\t-moz-tab-size: 2;\n\t\t-o-tab-size: 2;\n\t}\n\n\t.current {\n\t\tfont-weight: bold;\n\t\tbackground: #abf;\n\t}\n\n\t.skip {\n\t\tpadding: 0;\n\t\tmargin: 2px;\n\t\tborder: 1px solid #3465a4;\n\t\tborder-radius: 50%;\n\t\tcolor: #3465a4;\n\t\tbackground: none;\n\t\tfont-weight: bold;\n\t\tfont-size: 1.2em;\n\t\twidth: calc(2ch / 1.2 - 4px);\n\t\theight: calc(2ch / 1.2 - 4px);\n\t\tline-height: 0.6;\n\t}\n\n\t.skip:hover {\n\t\tbackground: #3465a4;\n\t\tcolor: #bdf;\n\t}\n\n\t#console {\n\t\toverflow-y: scroll;\n\t\tscrollbar-width: thin;\n\t\tscrollbar-color: #afc2db transparent;\n\t\theight: calc(12 * 1.2em);\n\t\tlist-style: none;\n\t\tpadding-left: 0;\n\t\tmargin: 0 .4em .4em .4em;\n\t\tposition: relative;\n\t\tword-wrap: break-word;\n\t}\n\n\t#console>*+* {\n\t\tmargin-top: .5em;\n\t}\n\n\t.console-entry>* {\n\t\tdisplay: block;\n\t}\n\n\t.console-entry .input  { color: #3465a4; }\n\t.console-entry .output { color: #333; }\n\n\t.console-entry .input:before  { content: '>> ' }\n\t.console-entry .output:before { content: '<- ' }\n\n\t#console-form {\n\t\tmargin: 0 .4em .4em .4em;\n\t}\n\n\t#console-input {\n\t\twidth: 100%;\n\t\tfont-size: inherit;\n\t}\n\n\t.token.tagname { font-weight: bold; }\n\t.token.attr, .token.builtin, .token.italic { font-style: italic; }\n\t.token.string { opacity: .8; }\n\t.token.keyword { color: #3465a4; }\n\t.token.bold, .token.punctuation, .token.operator { font-weight: bold; }\n\t</style>\n\t</div>\n\t`;\n\tHDB.prototype.ui = function () {\n\t\tvar node = document.createElement(\"div\");\n\t\tvar shadow = node.attachShadow({ mode: \"open\" });\n\t\tnode.style.cssText = \"all: initial\";\n\t\tshadow.innerHTML = ui;\n\t\tdocument.body.appendChild(node);\n\t\t_hyperscript.processNode(shadow.querySelector(\".hdb\"));\n\t};\n}\n"],"names":["mergeObjects","obj1","obj2","key","hasOwnProperty","getOrInitObject","root","prop","value","newObj","varargConstructor","Cls","args","bind","apply","concat","_hyperscript","globalScope","globalThis","ElementCollection","constructor","css","relativeToElement","escape","this","_css","_runtime","escapeSelector","className","substr","id","contains","elt","element","length","selectMatches","Symbol","iterator","getRootNode","querySelectorAll","_lexer","OP_TABLE","$","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","isIdentifierChar","dollarIsOp","makeTokensObject","tokens","consumed","source","consumeWhitespace","_lastConsumed","token","type","push","shift","raiseError","error","_parser","raiseParseError","matchOpToken","currentToken","op","consumeToken","matchTokenType","type1","type2","type3","type4","indexOf","matchToken","follows","match","consumeUntil","tokenList","n","dontIgnoreWhitespace","i","pushFollow","str","popFollow","pop","clearFollow","tmp","restoreFollow","f","matchAnyToken","op1","op2","op3","arguments","opToken","matchAnyOpToken","requireOpToken","requireTokenType","JSON","stringify","requireToken","list","hasMore","lastMatch","consumeUntilWhitespace","lastWhitespace","sourceFor","substring","startToken","start","endToken","end","lineFor","split","line","isValidSingleQuoteStringStart","previousToken","tokenize","string","template","position","column","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","charAfterThat","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeStyleReference","consumeIdentifier","consumeNumber","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","consumeComment","classRef","attributeRef","styleRef","idRef","identifier","number","makeOpToken","startChar","charAt","whitespace","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","initElt","parseElement","programSource","elementDefinition","requireElement","message","result","parseAnyOf","types","expression","addGrammarElement","name","definition","lines","contextLine","repeat","createParserContext","commandStart","featureStart","parser","runtime","featureElement","featureDefinition","commandElement","commandDefinition","cmd","next","indirect","unless","context","conditional","execute","unifiedExec","parent","leaf","setParent","children","Set","add","commandBoundary","parseHyperScript","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","isFeature","addLeafExpression","addIndirectExpression","parseStringTemplate","returnArr","startingBrace","ensureTerminated","commandList","implicitReturn","returned","resolve","HALT","ctx","CONVERSIONS","dynamicResolvers","Number","toFixed","num","parseInt","String","val","toString","Int","Float","parseFloat","Date","Array","from","Object","parse","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","triggerEvent","eventName","detail","sender","event","evt","Event","bubbles","cancelable","document","createEvent","initCustomEvent","makeEvent","dispatchEvent","isArrayLike","isArray","NodeList","HTMLCollection","shouldAutoIterate","forEach","func","isIterable","nth","unwrapAsyncs","values","asyncWrapper","j","valueElement","unifiedEval","async","wrappedAsyncs","argument","arr","evaluate","then","Promise","reject","arg","all","wrapArrays","e","catch","reason","_scriptAttrs","getScriptAttributes","config","attributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","hyperscriptFeaturesMap","WeakMap","getHyperscriptFeatures","hyperscriptFeatures","get","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","lexer","iterators","me","target","body","src","hyperscript","initElement","closest","disableSelector","internalData","getInternalData","initialized","script","hyperScript","setTimeout","console","stack","internalDataMap","getElementScope","scopeName","behavior","flatGet","property","getter","component","componentValue","typeCheck","typeString","nullOk","prototype","slice","implicitLoop","x","processNode","getScriptSelector","HyperscriptModule","EventTarget","mod","super","module","evaluateNoPromise","map","attribute","join","resolveSymbol","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","convertValue","converted","dynamicResolver","undefined","converter","handlingFinally","registerHyperTrace","errorHandler","handlingError","errorSymbol","currentException","resolvedNext","finallyHandler","onHalt","resolveProperty","resolveAttribute","resolveStyle","style","resolveComputedStyle","getComputedStyle","getPropertyValue","assignToNamespace","nameSpace","propertyName","newRoot","thrown","trace","caller","traceMap","Map","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","getHyperTrace","nullCheck","isEmpty","doesExist","node","Node","rv","Document","ShadowRoot","getEventQueueFor","onFeature","eventQueuesForElt","eventQueues","eventQueueForFeature","queue","executing","hyperscriptUrl","import","url","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","TemplatedQueryElementCollection","templateParts","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","outerVal","innerValue","beingTold","styleProp","startsWith","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","scope","eltPrefix","booleanLiteral","arg1","_context","rootVal","childOfUrRoot","urRoot","attributeElt","propertyAccess","possessivesDisabled","apostrophe","targetElt","results","within","rootElt","conversion","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","STRING_POSTFIXES","stringPosfix","postfix","timeFactor","time","factor","typeName","scanForwardArray","array","wrap","first","sloppyContains","container","includes","sloppyMatches","toMatch","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","reverse","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","scanForwardQuery","DOCUMENT_POSITION_FOLLOWING","scanBackwardsQuery","rhs","rhsVal","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","logicalOp","initialLogicalOp","features","install","parseEventArgs","parseSendCmd","cmdType","details","toExpr","sendCmd","to","every","events","startCountToken","startCount","endCountToken","endCount","unbounded","intersectionSpec","mutationSpec","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","debounced","lastExec","queueLast","queueFirst","queueNone","eventQueueInfo","queued","err","hypertrace","eventSpec","targets","MutationObserver","mutationList","observer","observe","IntersectionObserver","entries","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","initialCtx","inElement","clearTimeout","now","nameVal","funcName","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returnValue","hypername","setCmd","setFeature","initFeature","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","peek","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalBeingTold","lookahead","resolved","eventInfo","once","timeValue","separator","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","log","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","classList","pseudoCommand","lookAhead","realRoot","makeSetter","symbolWrite","attributeWrite","styleWrite","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","forever","times","indexIdentifier","loop","last","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","done","repeatInit","parseConversionInfo","targetExpr","implicitResultSymbol","innerHTML","amount","implicitIncrementOp","targetValue","newValue","implicitDecrementOp","conversionInfo","fetchCmd","argExpressions","abortController","AbortController","abortListener","abort","signal","finished","timeout","fetch","resp","resultDetails","response","json","text","finally","scripts","res","code","fn","metaConfig","querySelector","jString","msg","parseJSON","content","documentElement","readyState","PROXY_BLACKLIST","internals","defaultTransition","conversions","genUUID","r","createSocket","WebSocket","compileTemplate","p1","onExpr","settleCommand","transitionStarted","cssDeclaration","classRefs","attrRef","cssText","stringParts","opencurly","tok","part","idx","elementExpr","fromExpr","removeChild","remove","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","originalDisplay","removeProperty","visibility","opacity","parseShowHideTarget","currentTokenValue","resolveStrategy","configDefault","defaultHideShowStrategy","strategies","hideShowStrategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","hideShowStrategy","when","forExpr","forElt","eltColl","clazz","operationToken","operation","rootExpr","before","after","prepend","targetsExpr","properties","over","using","transition","promises","initialTransition","computedStyles","initialStyles","initalStyles","fromVal","toVal","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","y","right","bottom","bounds","parentSearch","closestExpr","back","newWindow","verticalPosition","horizontalPosition","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","scrollIntoView","getInputInfo","appendValue","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","web","invocationIdCounter","workerCode","self","onmessage","data","importScripts","extraScripts","postMessage","blob","Blob","workerUri","URL","createObjectURL","workerName","extraScript","absoluteUrl","bodyStartIndex","bodyEndIndex","bodyTokens","worker","Worker","workerPromise","stubs","returnListener","socketName","defaultTimeout","jsonMessages","messageHandler","socket","rpcProxy","getProxy","Proxy","uuid","rpcInfo","iid","send","socketObject","raw","rpc","socketFeature","dataAsJson","throw","return","urlElement","withCredentials","eventSourceName","stub","eventSource","listeners","retryCount","close","EventSource","CLOSED","min","handler","options","object","encoding","addImplicitReturnToCommandList","makeHandler","decode","template_","templateArgs","buf","assign","__ht_template_result","renderTemplate","escapeType","unescaped","HDB","breakpoint","cmdMap","bus","hdb","break","ui","attr","continueExec","stepOver","stepOut","logCommand","halt_flag","callingCmd","oldMe","skipTo","toCmd","rewrite","newCode","prev","newcmd","cmdSource","traverse","ge","recurse","child","shadow","attachShadow","mode","appendChild"],"mappings":"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"}