{"version":3,"file":"hyperscript.org.modern.js","sources":["../src/lib/core.js","../src/lib/web.js","../src/lib/worker.js","../src/lib/socket.js","../src/lib/template.js","../src/lib/hdb.js","../src/lib/eventsource.js"],"sourcesContent":["///=========================================================================\n/// This module provides the core runtime and grammar for hyperscript\n///=========================================================================\n//AMD insanity\n\n/**\n * @type {HyperscriptObject}\n */\nlet _hyperscript\n\n//====================================================================\n// Utilities\n//====================================================================\n\n/**\n * mergeObjects combines the keys from obj2 into obj2, then returns obj1\n *\n * @param {object} obj1\n * @param {object} obj2\n * @returns object\n */\nfunction mergeObjects(obj1, obj2) {\n\tfor (var key in obj2) {\n\t\tif (obj2.hasOwnProperty(key)) {\n\t\t\tobj1[key] = obj2[key];\n\t\t}\n\t}\n\treturn obj1;\n}\n\nfunction getOrInitObject(root, prop) {\n\tvar value = root[prop];\n\tif (value) {\n\t\treturn value;\n\t} else {\n\t\tvar newObj = {};\n\t\troot[prop] = newObj;\n\t\treturn newObj;\n\t}\n}\n\n/**\n * parseJSON parses a JSON string into a corresponding value.  If the\n * value passed in is not valid JSON, then it logs an error and returns `null`.\n *\n * @param {string} jString\n * @returns any\n */\nfunction parseJSON(jString) {\n\ttry {\n\t\treturn JSON.parse(jString);\n\t} catch (error) {\n\t\tlogError(error);\n\t\treturn null;\n\t}\n}\n\n/**\n * logError writes an error message to the Javascript console.  It can take any\n * value, but msg should commonly be a simple string.\n * @param {*} msg\n */\nfunction logError(msg) {\n\tif (console.error) {\n\t\tconsole.error(msg);\n\t} else if (console.log) {\n\t\tconsole.log(\"ERROR: \", msg);\n\t}\n}\n\n// TODO: JSDoc description of what's happening here\nfunction varargConstructor(Cls, args) {\n\treturn new (Cls.bind.apply(Cls, [Cls].concat(args)))();\n}\n\nvar globalScope = globalThis;\n\n//====================================================================\n// Standard library\n//====================================================================\n\nclass ElementCollection {\n\tconstructor(css, relativeToElement) {\n\t\tthis._css = css;\n\t\tthis.relativeToElement = relativeToElement;\n\t}\n\n\tget css() {\n\t\treturn _runtime.escapeSelector(this._css);\n\t}\n\n\tget className() {\n\t\treturn this._css.substr(1);\n\t}\n\n\tget id() {\n\t\treturn this.className();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn _runtime.getRootNode(this.relativeToElement)\n\t\t\t.querySelectorAll(this.css)\n\t\t\t[Symbol.iterator]();\n\t}\n}\n\n//====================================================================\n// Lexer\n//====================================================================\n\n/** @type LexerObject */\nvar _lexer = (function () {\n\tvar OP_TABLE = {\n\t\t\"+\": \"PLUS\",\n\t\t\"-\": \"MINUS\",\n\t\t\"*\": \"MULTIPLY\",\n\t\t\"/\": \"DIVIDE\",\n\t\t\".\": \"PERIOD\",\n\t\t\"..\": \"ELLIPSIS\",\n\t\t\"\\\\\": \"BACKSLASH\",\n\t\t\":\": \"COLON\",\n\t\t\"%\": \"PERCENT\",\n\t\t\"|\": \"PIPE\",\n\t\t\"!\": \"EXCLAMATION\",\n\t\t\"?\": \"QUESTION\",\n\t\t\"#\": \"POUND\",\n\t\t\"&\": \"AMPERSAND\",\n\t\t$: \"DOLLAR\",\n\t\t\";\": \"SEMI\",\n\t\t\",\": \"COMMA\",\n\t\t\"(\": \"L_PAREN\",\n\t\t\")\": \"R_PAREN\",\n\t\t\"<\": \"L_ANG\",\n\t\t\">\": \"R_ANG\",\n\t\t\"<=\": \"LTE_ANG\",\n\t\t\">=\": \"GTE_ANG\",\n\t\t\"==\": \"EQ\",\n\t\t\"===\": \"EQQ\",\n\t\t\"!=\": \"NEQ\",\n\t\t\"!==\": \"NEQQ\",\n\t\t\"{\": \"L_BRACE\",\n\t\t\"}\": \"R_BRACE\",\n\t\t\"[\": \"L_BRACKET\",\n\t\t\"]\": \"R_BRACKET\",\n\t\t\"=\": \"EQUALS\",\n\t};\n\n\t/**\n\t * isValidCSSClassChar returns `true` if the provided character is valid in a CSS class.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSClassChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isValidCSSIDChar returns `true` if the provided character is valid in a CSS ID\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isValidCSSIDChar(c) {\n\t\treturn isAlpha(c) || isNumeric(c) || c === \"-\" || c === \"_\" || c === \":\";\n\t}\n\n\t/**\n\t * isWhitespace returns `true` if the provided character is whitespace.\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isWhitespace(c) {\n\t\treturn c === \" \" || c === \"\\t\" || isNewline(c);\n\t}\n\n\t/**\n\t * positionString returns a string representation of a Token's line and column details.\n\t * @param {Token} token\n\t * @returns string\n\t */\n\tfunction positionString(token) {\n\t\treturn \"[Line: \" + token.line + \", Column: \" + token.column + \"]\";\n\t}\n\n\t/**\n\t * isNewline returns `true` if the provided character is a carrage return or newline\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNewline(c) {\n\t\treturn c === \"\\r\" || c === \"\\n\";\n\t}\n\n\t/**\n\t * isNumeric returns `true` if the provided character is a number (0-9)\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isNumeric(c) {\n\t\treturn c >= \"0\" && c <= \"9\";\n\t}\n\n\t/**\n\t * isAlpha returns `true` if the provided character is a letter in the alphabet\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isAlpha(c) {\n\t\treturn (c >= \"a\" && c <= \"z\") || (c >= \"A\" && c <= \"Z\");\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @param {boolean} [dollarIsOp]\n\t * @returns boolean\n\t */\n\tfunction isIdentifierChar(c, dollarIsOp) {\n\t\treturn c === \"_\" || c === \"$\";\n\t}\n\n\t/**\n\t * @param {string} c\n\t * @returns boolean\n\t */\n\tfunction isReservedChar(c) {\n\t\treturn c === \"`\" || c === \"^\";\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @param {Token[]} consumed\n\t * @param {string} source\n\t * @returns {TokensObject}\n\t */\n\tfunction makeTokensObject(tokens, consumed, source) {\n\t\tconsumeWhitespace(); // consume initial whitespace\n\n\t\t/** @type Token | null */\n\t\tvar _lastConsumed = null;\n\n\t\tfunction consumeWhitespace() {\n\t\t\twhile (token(0, true).type === \"WHITESPACE\") {\n\t\t\t\tconsumed.push(tokens.shift());\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {TokensObject} tokens\n\t\t * @param {*} error\n\t\t */\n\t\tfunction raiseError(tokens, error) {\n\t\t\t_parser.raiseParseError(tokens, error);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireOpToken(value) {\n\t\t\tvar token = matchOpToken(value);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyOpToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchOpToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} op1\n\t\t * @param {string} [op2]\n\t\t * @param {string} [op3]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchAnyToken(op1, op2, op3) {\n\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\tvar opToken = arguments[i];\n\t\t\t\tvar match = matchToken(opToken);\n\t\t\t\tif (match) {\n\t\t\t\t\treturn match;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchOpToken(value) {\n\t\t\tif (currentToken() && currentToken().op && currentToken().value === value) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireTokenType(type1, type2, type3, type4) {\n\t\t\tvar token = matchTokenType(type1, type2, type3, type4);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected one of \" + JSON.stringify([type1, type2, type3]));\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type1\n\t\t * @param {string} [type2]\n\t\t * @param {string} [type3]\n\t\t * @param {string} [type4]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchTokenType(type1, type2, type3, type4) {\n\t\t\tif (\n\t\t\t\tcurrentToken() &&\n\t\t\t\tcurrentToken().type &&\n\t\t\t\t[type1, type2, type3, type4].indexOf(currentToken().type) >= 0\n\t\t\t) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction requireToken(value, type) {\n\t\t\tvar token = matchToken(value, type);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\traiseError(this, \"Expected '\" + value + \"' but found '\" + currentToken().value + \"'\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token | void}\n\t\t */\n\t\tfunction matchToken(value, type) {\n\t\t\tif (follows.indexOf(value) !== -1) {\n\t\t\t\treturn; // disallowed token here\n\t\t\t}\n\t\t\tvar type = type || \"IDENTIFIER\";\n\t\t\tif (currentToken() && currentToken().value === value && currentToken().type === type) {\n\t\t\t\treturn consumeToken();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction consumeToken() {\n\t\t\tvar match = tokens.shift();\n\t\t\tconsumed.push(match);\n\t\t\t_lastConsumed = match;\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn match;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} value\n\t\t * @param {string} [type]\n\t\t * @returns {Token[]}\n\t\t */\n\t\tfunction consumeUntil(value, type) {\n\t\t\t/** @type Token[] */\n\t\t\tvar tokenList = [];\n\t\t\tvar currentToken = token(0, true);\n\n\t\t\twhile (\n\t\t\t\t(type == null || currentToken.type !== type) &&\n\t\t\t\t(value == null || currentToken.value !== value) &&\n\t\t\t\tcurrentToken.type !== \"EOF\"\n\t\t\t) {\n\t\t\t\tvar match = tokens.shift();\n\t\t\t\tconsumed.push(match);\n\t\t\t\ttokenList.push(currentToken);\n\t\t\t\tcurrentToken = token(0, true);\n\t\t\t}\n\t\t\tconsumeWhitespace(); // consume any whitespace\n\t\t\treturn tokenList;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lastWhitespace() {\n\t\t\tif (consumed[consumed.length - 1] && consumed[consumed.length - 1].type === \"WHITESPACE\") {\n\t\t\t\treturn consumed[consumed.length - 1].value;\n\t\t\t} else {\n\t\t\t\treturn \"\";\n\t\t\t}\n\t\t}\n\n\t\tfunction consumeUntilWhitespace() {\n\t\t\treturn consumeUntil(null, \"WHITESPACE\");\n\t\t}\n\n\t\t/**\n\t\t * @returns {boolean}\n\t\t */\n\t\tfunction hasMore() {\n\t\t\treturn tokens.length > 0;\n\t\t}\n\n\t\t/**\n\t\t * @param {number} n\n\t\t * @param {boolean} [dontIgnoreWhitespace]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction token(n, dontIgnoreWhitespace) {\n\t\t\tvar /**@type {Token}*/ token;\n\t\t\tvar i = 0;\n\t\t\tdo {\n\t\t\t\tif (!dontIgnoreWhitespace) {\n\t\t\t\t\twhile (tokens[i] && tokens[i].type === \"WHITESPACE\") {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoken = tokens[i];\n\t\t\t\tn--;\n\t\t\t\ti++;\n\t\t\t} while (n > -1);\n\t\t\tif (token) {\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"EOF\",\n\t\t\t\t\tvalue: \"<<<EOF>>>\",\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction currentToken() {\n\t\t\treturn token(0);\n\t\t}\n\n\t\t/**\n\t\t * @returns {Token | null}\n\t\t */\n\t\tfunction lastMatch() {\n\t\t\treturn _lastConsumed;\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction sourceFor() {\n\t\t\treturn source.substring(this.startToken.start, this.endToken.end);\n\t\t}\n\n\t\t/**\n\t\t * @returns {string}\n\t\t */\n\t\tfunction lineFor() {\n\t\t\treturn source.split(\"\\n\")[this.startToken.line - 1];\n\t\t}\n\n\t\tvar follows = [];\n\n\t\tfunction pushFollow(str) {\n\t\t\tfollows.push(str);\n\t\t}\n\n\t\tfunction popFollow() {\n\t\t\tfollows.pop();\n\t\t}\n\n\t\tfunction clearFollows() {\n\t\t\tvar tmp = follows;\n\t\t\tfollows = [];\n\t\t\treturn tmp;\n\t\t}\n\n\t\tfunction restoreFollows(f) {\n\t\t\tfollows = f;\n\t\t}\n\n\t\t/** @type {TokensObject} */\n\t\treturn {\n\t\t\tpushFollow: pushFollow,\n\t\t\tpopFollow: popFollow,\n\t\t\tclearFollow: clearFollows,\n\t\t\trestoreFollow: restoreFollows,\n\t\t\tmatchAnyToken: matchAnyToken,\n\t\t\tmatchAnyOpToken: matchAnyOpToken,\n\t\t\tmatchOpToken: matchOpToken,\n\t\t\trequireOpToken: requireOpToken,\n\t\t\tmatchTokenType: matchTokenType,\n\t\t\trequireTokenType: requireTokenType,\n\t\t\tconsumeToken: consumeToken,\n\t\t\tmatchToken: matchToken,\n\t\t\trequireToken: requireToken,\n\t\t\tlist: tokens,\n\t\t\tconsumed: consumed,\n\t\t\tsource: source,\n\t\t\thasMore: hasMore,\n\t\t\tcurrentToken: currentToken,\n\t\t\tlastMatch: lastMatch,\n\t\t\ttoken: token,\n\t\t\tconsumeUntil: consumeUntil,\n\t\t\tconsumeUntilWhitespace: consumeUntilWhitespace,\n\t\t\tlastWhitespace: lastWhitespace,\n\t\t\tsourceFor: sourceFor,\n\t\t\tlineFor: lineFor,\n\t\t};\n\t}\n\n\t/**\n\t * @param {Token[]} tokens\n\t * @returns {boolean}\n\t */\n\tfunction isValidSingleQuoteStringStart(tokens) {\n\t\tif (tokens.length > 0) {\n\t\t\tvar previousToken = tokens[tokens.length - 1];\n\t\t\tif (\n\t\t\t\tpreviousToken.type === \"IDENTIFIER\" ||\n\t\t\t\tpreviousToken.type === \"CLASS_REF\" ||\n\t\t\t\tpreviousToken.type === \"ID_REF\"\n\t\t\t) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (previousToken.op && (previousToken.value === \">\" || previousToken.value === \")\")) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {string} string\n\t * @param {boolean} [template]\n\t * @returns {TokensObject}\n\t */\n\tfunction tokenize(string, template) {\n\t\tvar tokens = /** @type {Token[]}*/ [];\n\t\tvar source = string;\n\t\tvar position = 0;\n\t\tvar column = 0;\n\t\tvar line = 1;\n\t\tvar lastToken = \"<START>\";\n\t\tvar templateBraceCount = 0;\n\n\t\tfunction inTemplate() {\n\t\t\treturn template && templateBraceCount === 0;\n\t\t}\n\n\t\twhile (position < source.length) {\n\t\t\tif (currentChar() === \"-\" && nextChar() === \"-\") {\n\t\t\t\tconsumeComment();\n\t\t\t} else {\n\t\t\t\tif (isWhitespace(currentChar())) {\n\t\t\t\t\ttokens.push(consumeWhitespace());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \".\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeClassReference());\n\t\t\t\t} else if (\n\t\t\t\t\t!possiblePrecedingSymbol() &&\n\t\t\t\t\tcurrentChar() === \"#\" &&\n\t\t\t\t\t(isAlpha(nextChar()) || nextChar() === \"{\")\n\t\t\t\t) {\n\t\t\t\t\ttokens.push(consumeIdReference());\n\t\t\t\t} else if (currentChar() === \"[\" && nextChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeAttributeReference());\n\t\t\t\t} else if (currentChar() === \"@\") {\n\t\t\t\t\ttokens.push(consumeShortAttributeReference());\n\t\t\t\t} else if (isAlpha(currentChar()) || (!inTemplate() && isIdentifierChar(currentChar()))) {\n\t\t\t\t\ttokens.push(consumeIdentifier());\n\t\t\t\t} else if (isNumeric(currentChar())) {\n\t\t\t\t\ttokens.push(consumeNumber());\n\t\t\t\t} else if (!inTemplate() && (currentChar() === '\"' || currentChar() === \"`\")) {\n\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t} else if (!inTemplate() && currentChar() === \"'\") {\n\t\t\t\t\tif (isValidSingleQuoteStringStart(tokens)) {\n\t\t\t\t\t\ttokens.push(consumeString());\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t\t}\n\t\t\t\t} else if (OP_TABLE[currentChar()]) {\n\t\t\t\t\tif (lastToken === \"$\" && currentChar() === \"{\") {\n\t\t\t\t\t\ttemplateBraceCount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (currentChar() === \"}\") {\n\t\t\t\t\t\ttemplateBraceCount--;\n\t\t\t\t\t}\n\t\t\t\t\ttokens.push(consumeOp());\n\t\t\t\t} else if (inTemplate() || isReservedChar(currentChar())) {\n\t\t\t\t\ttokens.push(makeToken(\"RESERVED\", consumeChar()));\n\t\t\t\t} else {\n\t\t\t\t\tif (position < source.length) {\n\t\t\t\t\t\tthrow Error(\"Unknown token: \" + currentChar() + \" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn makeTokensObject(tokens, [], source);\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeOpToken(type, value) {\n\t\t\tvar token = makeToken(type, value);\n\t\t\ttoken.op = true;\n\t\t\treturn token;\n\t\t}\n\n\t\t/**\n\t\t * @param {string} [type]\n\t\t * @param {string} [value]\n\t\t * @returns {Token}\n\t\t */\n\t\tfunction makeToken(type, value) {\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\tvalue: value,\n\t\t\t\tstart: position,\n\t\t\t\tend: position + 1,\n\t\t\t\tcolumn: column,\n\t\t\t\tline: line,\n\t\t\t};\n\t\t}\n\n\t\tfunction consumeComment() {\n\t\t\twhile (currentChar() && !isNewline(currentChar())) {\n\t\t\t\tconsumeChar();\n\t\t\t}\n\t\t\tconsumeChar();\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeClassReference() {\n\t\t\tvar classRef = makeToken(\"CLASS_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tclassRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated class reference\");\n\t\t\t\t} else {\n\t\t\t\t\tvalue += consumeChar(); // consume final curly\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSClassChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tclassRef.value = value;\n\t\t\tclassRef.end = position;\n\t\t\treturn classRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (position < source.length && currentChar() !== \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \"]\") {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\tfunction consumeShortAttributeReference() {\n\t\t\tvar attributeRef = makeToken(\"ATTRIBUTE_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tattributeRef.value = value;\n\t\t\tattributeRef.end = position;\n\t\t\treturn attributeRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdReference() {\n\t\t\tvar idRef = makeToken(\"ID_REF\");\n\t\t\tvar value = consumeChar();\n\t\t\tif (currentChar() === \"{\") {\n\t\t\t\tidRef.template = true;\n\t\t\t\tvalue += consumeChar();\n\t\t\t\twhile (currentChar() && currentChar() !== \"}\") {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t\tif (currentChar() !== \"}\") {\n\t\t\t\t\tthrow Error(\"Unterminated id reference\");\n\t\t\t\t} else {\n\t\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (isValidCSSIDChar(currentChar())) {\n\t\t\t\t\tvalue += consumeChar();\n\t\t\t\t}\n\t\t\t}\n\t\t\tidRef.value = value;\n\t\t\tidRef.end = position;\n\t\t\treturn idRef;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeIdentifier() {\n\t\t\tvar identifier = makeToken(\"IDENTIFIER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isAlpha(currentChar()) || isIdentifierChar(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tidentifier.value = value;\n\t\t\tidentifier.end = position;\n\t\t\treturn identifier;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeNumber() {\n\t\t\tvar number = makeToken(\"NUMBER\");\n\t\t\tvar value = consumeChar();\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() === \".\" && isNumeric(nextChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhile (isNumeric(currentChar())) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tnumber.value = value;\n\t\t\tnumber.end = position;\n\t\t\treturn number;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeOp() {\n\t\t\tvar op = makeOpToken();\n\t\t\tvar value = consumeChar(); // consume leading char\n\t\t\twhile (currentChar() && OP_TABLE[value + currentChar()]) {\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\top.type = OP_TABLE[value];\n\t\t\top.value = value;\n\t\t\top.end = position;\n\t\t\treturn op;\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeString() {\n\t\t\tvar string = makeToken(\"STRING\");\n\t\t\tvar startChar = consumeChar(); // consume leading quote\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && currentChar() !== startChar) {\n\t\t\t\tif (currentChar() === \"\\\\\") {\n\t\t\t\t\tconsumeChar(); // consume escape char and move on\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\tif (currentChar() !== startChar) {\n\t\t\t\tthrow Error(\"Unterminated string at \" + positionString(string));\n\t\t\t} else {\n\t\t\t\tconsumeChar(); // consume final quote\n\t\t\t}\n\t\t\tstring.value = value;\n\t\t\tstring.end = position;\n\t\t\tstring.template = startChar === \"`\";\n\t\t\treturn string;\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction currentChar() {\n\t\t\treturn source.charAt(position);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction nextChar() {\n\t\t\treturn source.charAt(position + 1);\n\t\t}\n\n\t\t/**\n\t\t * @returns string\n\t\t */\n\t\tfunction consumeChar() {\n\t\t\tlastToken = currentChar();\n\t\t\tposition++;\n\t\t\tcolumn++;\n\t\t\treturn lastToken;\n\t\t}\n\n\t\t/**\n\t\t * @returns boolean\n\t\t */\n\t\tfunction possiblePrecedingSymbol() {\n\t\t\treturn (\n\t\t\t\tisAlpha(lastToken) ||\n\t\t\t\tisNumeric(lastToken) ||\n\t\t\t\tlastToken === \")\" ||\n\t\t\t\tlastToken === \"}\" ||\n\t\t\t\tlastToken === \"]\"\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * @returns Token\n\t\t */\n\t\tfunction consumeWhitespace() {\n\t\t\tvar whitespace = makeToken(\"WHITESPACE\");\n\t\t\tvar value = \"\";\n\t\t\twhile (currentChar() && isWhitespace(currentChar())) {\n\t\t\t\tif (isNewline(currentChar())) {\n\t\t\t\t\tcolumn = 0;\n\t\t\t\t\tline++;\n\t\t\t\t}\n\t\t\t\tvalue += consumeChar();\n\t\t\t}\n\t\t\twhitespace.value = value;\n\t\t\twhitespace.end = position;\n\t\t\treturn whitespace;\n\t\t}\n\t}\n\n\treturn {\n\t\ttokenize: tokenize,\n\t\tmakeTokensObject: makeTokensObject,\n\t};\n})();\n\n//====================================================================\n// Parser\n//====================================================================\n\n/** @type ParserObject */\nvar _parser = (function () {\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar GRAMMAR = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar COMMANDS = {};\n\n\t/** @type {Object<string,GrammarDefinition>} */\n\tvar FEATURES = {};\n\n\tvar LEAF_EXPRESSIONS = [];\n\tvar INDIRECT_EXPRESSIONS = [];\n\n\t/**\n\t * @param {*} parseElement\n\t * @param {*} start\n\t * @param {TokensObject} tokens\n\t */\n\tfunction initElt(parseElement, start, tokens) {\n\t\tparseElement.startToken = start;\n\t\tparseElement.sourceFor = tokens.sourceFor;\n\t\tparseElement.lineFor = tokens.lineFor;\n\t\tparseElement.programSource = tokens.source;\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {GrammarElement?} root\n\t * @returns GrammarElement\n\t */\n\tfunction parseElement(type, tokens, root = undefined) {\n\t\tvar elementDefinition = GRAMMAR[type];\n\t\tif (elementDefinition) {\n\t\t\tvar start = tokens.currentToken();\n\t\t\tvar parseElement = elementDefinition(_parser, _runtime, tokens, root);\n\t\t\tif (parseElement) {\n\t\t\t\tinitElt(parseElement, start, tokens);\n\t\t\t\tparseElement.endToken = parseElement.endToken || tokens.lastMatch();\n\t\t\t\tvar root = parseElement.root;\n\t\t\t\twhile (root != null) {\n\t\t\t\t\tinitElt(root, start, tokens);\n\t\t\t\t\troot = root.root;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parseElement;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} type\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t * @param {*} [root]\n\t * @returns {GrammarElement}\n\t */\n\tfunction requireElement(type, tokens, message, root) {\n\t\tvar result = parseElement(type, tokens, root);\n\t\tif (!result) raiseParseError(tokens, message || \"Expected \" + type);\n\t\t// @ts-ignore\n\t\treturn result;\n\t}\n\n\t/**\n\t * @param {string[]} types\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseAnyOf(types, tokens) {\n\t\tfor (var i = 0; i < types.length; i++) {\n\t\t\tvar type = types[i];\n\t\t\tvar expression = parseElement(type, tokens);\n\t\t\tif (expression) {\n\t\t\t\treturn expression;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addGrammarElement(name, definition) {\n\t\tGRAMMAR[name] = definition;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addCommand(keyword, definition) {\n\t\tvar commandGrammarType = keyword + \"Command\";\n\t\tvar commandDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tconst commandElement = definition(parser, runtime, tokens);\n\t\t\tif (commandElement) {\n\t\t\t\tcommandElement.type = commandGrammarType;\n\t\t\t\tcommandElement.execute = function (context) {\n\t\t\t\t\tcontext.meta.command = commandElement;\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t};\n\t\t\t\treturn commandElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[commandGrammarType] = commandDefinitionWrapper;\n\t\tCOMMANDS[keyword] = commandDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} keyword\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addFeature(keyword, definition) {\n\t\tvar featureGrammarType = keyword + \"Feature\";\n\n\t\t/** @type {GrammarDefinition} */\n\t\tvar featureDefinitionWrapper = function (parser, runtime, tokens) {\n\t\t\tvar featureElement = definition(parser, runtime, tokens);\n\t\t\tif (featureElement) {\n\t\t\t\tfeatureElement.keyword = keyword;\n\t\t\t\tfeatureElement.type = featureGrammarType;\n\t\t\t\treturn featureElement;\n\t\t\t}\n\t\t};\n\t\tGRAMMAR[featureGrammarType] = featureDefinitionWrapper;\n\t\tFEATURES[keyword] = featureDefinitionWrapper;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addLeafExpression(name, definition) {\n\t\tLEAF_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {GrammarDefinition} definition\n\t */\n\tfunction addIndirectExpression(name, definition) {\n\t\tINDIRECT_EXPRESSIONS.push(name);\n\t\taddGrammarElement(name, definition);\n\t}\n\n\t/* ============================================================================================ */\n\t/* Core hyperscript Grammar Elements                                                            */\n\t/* ============================================================================================ */\n\taddGrammarElement(\"feature\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar featureElement = parser.requireElement(\"feature\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn featureElement;\n\t\t}\n\n\t\tvar featureDefinition = FEATURES[tokens.currentToken().value];\n\t\tif (featureDefinition) {\n\t\t\treturn featureDefinition(parser, runtime, tokens);\n\t\t}\n\t});\n\n\taddGrammarElement(\"command\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tconst commandElement = parser.requireElement(\"command\", tokens);\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn commandElement;\n\t\t}\n\n\t\tvar commandDefinition = COMMANDS[tokens.currentToken().value];\n\t\tlet commandElement;\n\t\tif (commandDefinition) {\n\t\t\tcommandElement = commandDefinition(parser, runtime, tokens);\n\t\t} else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.token(1).value === \"(\") {\n\t\t\tcommandElement = parser.requireElement(\"pseudoCommand\", tokens);\n\t\t}\n\t\tif (commandElement) {\n\t\t\treturn parser.parseElement(\"indirectStatement\", tokens, commandElement);\n\t\t}\n\n\t\treturn commandElement;\n\t});\n\n\taddGrammarElement(\"commandList\", function (parser, runtime, tokens) {\n\t\tvar cmd = parser.parseElement(\"command\", tokens);\n\t\tif (cmd) {\n\t\t\ttokens.matchToken(\"then\");\n\t\t\tconst next = parser.parseElement(\"commandList\", tokens);\n\t\t\tif (next) cmd.next = next;\n\t\t\treturn cmd;\n\t\t}\n\t});\n\n\taddGrammarElement(\"leaf\", function (parser, runtime, tokens) {\n\t\tvar result = parseAnyOf(LEAF_EXPRESSIONS, tokens);\n\t\t// symbol is last so it doesn't consume any constants\n\t\tif (result == null) {\n\t\t\treturn parseElement(\"symbol\", tokens);\n\t\t}\n\n\t\treturn result;\n\t});\n\n\taddGrammarElement(\"indirectExpression\", function (parser, runtime, tokens, root) {\n\t\tfor (var i = 0; i < INDIRECT_EXPRESSIONS.length; i++) {\n\t\t\tvar indirect = INDIRECT_EXPRESSIONS[i];\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar result = parser.parseElement(indirect, tokens, root);\n\t\t\tif (result) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"indirectStatement\", function (parser, runtime, tokens, root) {\n\t\tif (tokens.matchToken(\"unless\")) {\n\t\t\troot.endToken = tokens.lastMatch();\n\t\t\tvar conditional = parser.requireElement(\"expression\", tokens);\n\t\t\tvar unless = {\n\t\t\t\ttype: \"unlessStatementModifier\",\n\t\t\t\targs: [conditional],\n\t\t\t\top: function (context, conditional) {\n\t\t\t\t\tif (conditional) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.parent = unless;\n\t\t\treturn unless;\n\t\t}\n\t\treturn root;\n\t});\n\n\taddGrammarElement(\"primaryExpression\", function (parser, runtime, tokens) {\n\t\tvar leaf = parser.parseElement(\"leaf\", tokens);\n\t\tif (leaf) {\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, leaf);\n\t\t}\n\t\tparser.raiseParseError(tokens, \"Unexpected value: \" + tokens.currentToken().value);\n\t});\n\n\t/* ============================================================================================ */\n\t/* END Core hyperscript Grammar Elements                                                        */\n\n\t/* ============================================================================================ */\n\n\t/**\n\t *\n\t * @param {TokensObject} tokens\n\t * @returns string\n\t */\n\tfunction createParserContext(tokens) {\n\t\tvar currentToken = tokens.currentToken();\n\t\tvar source = tokens.source;\n\t\tvar lines = source.split(\"\\n\");\n\t\tvar line = currentToken && currentToken.line ? currentToken.line - 1 : lines.length - 1;\n\t\tvar contextLine = lines[line];\n\t\tvar offset = currentToken && currentToken.line ? currentToken.column : contextLine.length - 1;\n\t\treturn contextLine + \"\\n\" + \" \".repeat(offset) + \"^^\\n\\n\";\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @param {string} [message]\n\t */\n\tfunction raiseParseError(tokens, message) {\n\t\tmessage =\n\t\t\t(message || \"Unexpected Token : \" + tokens.currentToken().value) + \"\\n\\n\" + createParserContext(tokens);\n\t\tvar error = new Error(message);\n\t\terror[\"tokens\"] = tokens;\n\t\tthrow error;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {GrammarElement}\n\t */\n\tfunction parseHyperScript(tokens) {\n\t\tvar result = parseElement(\"hyperscript\", tokens);\n\t\tif (tokens.hasMore()) raiseParseError(tokens);\n\t\tif (result) return result;\n\t}\n\n\t/**\n\t * @param {GrammarElement} elt\n\t * @param {GrammarElement} parent\n\t */\n\tfunction setParent(elt, parent) {\n\t\tif (elt) {\n\t\t\telt.parent = parent;\n\t\t\tsetParent(elt.next, parent);\n\t\t}\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction commandStart(token) {\n\t\treturn COMMANDS[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {GrammarDefinition}\n\t */\n\tfunction featureStart(token) {\n\t\treturn FEATURES[token.value];\n\t}\n\n\t/**\n\t * @param {Token} token\n\t * @returns {boolean}\n\t */\n\tfunction commandBoundary(token) {\n\t\tif (\n\t\t\ttoken.value == \"end\" ||\n\t\t\ttoken.value == \"then\" ||\n\t\t\ttoken.value == \"else\" ||\n\t\t\ttoken.value == \")\" ||\n\t\t\tcommandStart(token) ||\n\t\t\tfeatureStart(token) ||\n\t\t\ttoken.type == \"EOF\"\n\t\t) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {TokensObject} tokens\n\t * @returns {(string | GrammarElement)[]}\n\t */\n\tfunction parseStringTemplate(tokens) {\n\t\t/** @type {(string | GrammarElement)[]} */\n\t\tvar returnArr = [\"\"];\n\t\tdo {\n\t\t\treturnArr.push(tokens.lastWhitespace());\n\t\t\tif (tokens.currentToken().value === \"$\") {\n\t\t\t\ttokens.consumeToken();\n\t\t\t\tvar startingBrace = tokens.matchOpToken(\"{\");\n\t\t\t\treturnArr.push(requireElement(\"expression\", tokens));\n\t\t\t\tif (startingBrace) {\n\t\t\t\t\ttokens.requireOpToken(\"}\");\n\t\t\t\t}\n\t\t\t\treturnArr.push(\"\");\n\t\t\t} else if (tokens.currentToken().value === \"\\\\\") {\n\t\t\t\ttokens.consumeToken(); // skip next\n\t\t\t\ttokens.consumeToken();\n\t\t\t} else {\n\t\t\t\tvar token = tokens.consumeToken();\n\t\t\t\treturnArr[returnArr.length - 1] += token ? token.value : \"\";\n\t\t\t}\n\t\t} while (tokens.hasMore());\n\t\treturnArr.push(tokens.lastWhitespace());\n\t\treturn returnArr;\n\t}\n\n\t// parser API\n\treturn {\n\t\tsetParent: setParent,\n\t\trequireElement: requireElement,\n\t\tparseElement: parseElement,\n\t\tfeatureStart: featureStart,\n\t\tcommandStart: commandStart,\n\t\tcommandBoundary: commandBoundary,\n\t\tparseAnyOf: parseAnyOf,\n\t\tparseHyperScript: parseHyperScript,\n\t\traiseParseError: raiseParseError,\n\t\taddGrammarElement: addGrammarElement,\n\t\taddCommand: addCommand,\n\t\taddFeature: addFeature,\n\t\taddLeafExpression: addLeafExpression,\n\t\taddIndirectExpression: addIndirectExpression,\n\t\tparseStringTemplate: parseStringTemplate,\n\t};\n})();\n\n//====================================================================\n// Runtime\n//====================================================================\n\nvar CONVERSIONS = {\n\tdynamicResolvers: /** @type DynamicConversionFunction[] */ [],\n\tString: function (val) {\n\t\tif (val.toString) {\n\t\t\treturn val.toString();\n\t\t} else {\n\t\t\treturn \"\" + val;\n\t\t}\n\t},\n\tInt: function (val) {\n\t\treturn parseInt(val);\n\t},\n\tFloat: function (val) {\n\t\treturn parseFloat(val);\n\t},\n\tNumber: function (val) {\n\t\tconsole.log(val);\n\t\treturn Number(val);\n\t},\n\tDate: function (val) {\n\t\treturn new Date(val);\n\t},\n\tArray: function (val) {\n\t\treturn Array.from(val);\n\t},\n\tJSON: function (val) {\n\t\treturn JSON.stringify(val);\n\t},\n\tObject: function (val) {\n\t\tif (val instanceof String) {\n\t\t\tval = val.toString();\n\t\t}\n\t\tif (typeof val === \"string\") {\n\t\t\treturn JSON.parse(val);\n\t\t} else {\n\t\t\treturn mergeObjects({}, val);\n\t\t}\n\t},\n};\n\n/********************************************\n * RUNTIME OBJECT\n ********************************************/\n\n/** @type {RuntimeObject} */\nvar _runtime = (function () {\n\t/**\n\t * @param {HTMLElement} elt\n\t * @param {string} selector\n\t * @returns boolean\n\t */\n\tfunction matchesSelector(elt, selector) {\n\t\t// noinspection JSUnresolvedVariable\n\t\tvar matchesFunction =\n\t\t\t// @ts-ignore\n\t\t\telt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;\n\t\treturn matchesFunction && matchesFunction.call(elt, selector);\n\t}\n\n\t/**\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @returns {Event}\n\t */\n\tfunction makeEvent(eventName, detail) {\n\t\tvar evt;\n\t\tif (globalScope.Event && typeof globalScope.Event === \"function\") {\n\t\t\tevt = new Event(eventName, {\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true,\n\t\t\t});\n\t\t\tevt['detail'] = detail;\n\t\t} else {\n\t\t\tevt = document.createEvent(\"CustomEvent\");\n\t\t\tevt.initCustomEvent(eventName, true, true, detail);\n\t\t}\n\t\treturn evt;\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @param {string} eventName\n\t * @param {Object} [detail]\n\t * @returns {boolean}\n\t */\n\tfunction triggerEvent(elt, eventName, detail) {\n\t\tdetail = detail || {};\n\t\tdetail[\"sentBy\"] = elt;\n\t\tvar event = makeEvent(eventName, detail);\n\t\tvar eventResult = elt.dispatchEvent(event);\n\t\treturn eventResult;\n\t}\n\n\t/**\n\t * isArrayLike returns `true` if the provided value is an array or\n\t * a NodeList (which is close enough to being an array for our purposes).\n\t *\n\t * @param {any} value\n\t * @returns {value is Array | NodeList}\n\t */\n\tfunction isArrayLike(value) {\n\t\treturn Array.isArray(value) || (typeof NodeList !== 'undefined' && value instanceof NodeList);\n\t}\n\n\t/**\n\t * isIterable returns `true` if the provided value supports the\n\t * iterator protocol.\n\t *\n\t * @param {any} value\n\t * @returns {value is Iterable}\n\t */\n\tfunction isIterable(value) {\n\t\treturn typeof value === 'object' \n\t\t\t&& Symbol.iterator in value \n\t\t\t&& typeof value[Symbol.iterator] === 'function';\n\t}\n\n\t/**\n\t * shouldAutoIterate returns `true` if the provided value\n\t * should be implicitly iterated over when accessing properties,\n\t * and as the target of some commands.\n\t *\n\t * Currently, this is when the value is an {ElementCollection}\n\t * or {isArrayLike} returns true.\n\t *\n\t * @param {any} value\n\t * @returns {value is any[] | NodeList | ElementCollection}\n\t */\n\tfunction shouldAutoIterate(value) {\n\t\treturn value instanceof ElementCollection || isArrayLike(value);\n\t}\n\n\t/**\n\t * forEach executes the provided `func` on every item in the `value` array.\n\t * if `value` is a single item (and not an array) then `func` is simply called\n\t * once.  If `value` is null, then no further actions are taken.\n\t *\n\t * @template T\n\t * @param {T | Iterable<T>} value\n\t * @param {(item: T) => void} func\n\t */\n\tfunction forEach(value, func) {\n\t\tif (value == null) {\n\t\t\t// do nothing\n\t\t} else if (isIterable(value)) {\n\t\t\tfor (const nth of value) {\n\t\t\t\tfunc(nth);\n\t\t\t}\n\t\t} else if (isArrayLike(value)) {\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tfunc(value[i]);\n\t\t\t}\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\t/**\n\t * implicitLoop executes the provided `func` on:\n\t * - every item of {value}, if {value} should be auto-iterated\n\t *   (see {shouldAutoIterate})\n\t * - {value} otherwise\n\t *\n\t * @template T\n\t * @param {NodeList | T | T[]} value\n\t * @param {(item:Node | T) => void} func\n\t */\n\tfunction implicitLoop(value, func) {\n\t\tif (shouldAutoIterate(value)) {\n\t\t\tfor (const x of value) func(x);\n\t\t} else {\n\t\t\tfunc(value);\n\t\t}\n\t}\n\n\tvar ARRAY_SENTINEL = { array_sentinel: true };\n\n\tfunction linearize(args) {\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\tvar arg = args[i];\n\t\t\tif (Array.isArray(arg)) {\n\t\t\t\tarr.push(ARRAY_SENTINEL);\n\t\t\t\tfor (var j = 0; j < arg.length; j++) {\n\t\t\t\t\tarr.push(arg[j]);\n\t\t\t\t}\n\t\t\t\tarr.push(ARRAY_SENTINEL);\n\t\t\t} else {\n\t\t\t\tarr.push(arg);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction delinearize(values) {\n\t\tvar arr = [];\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar value = values[i];\n\t\t\tif (value === ARRAY_SENTINEL) {\n\t\t\t\tvalue = values[++i];\n\t\t\t\tvar valueArray = [];\n\t\t\t\tarr.push(valueArray);\n\t\t\t\twhile (value !== ARRAY_SENTINEL) {\n\t\t\t\t\tvalueArray.push(value);\n\t\t\t\t\tvalue = values[++i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tarr.push(value);\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction unwrapAsyncs(values) {\n\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\tvar value = values[i];\n\t\t\tif (value.asyncWrapper) {\n\t\t\t\tvalues[i] = value.value;\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\n\t\t\t\t\tvar valueElement = value[j];\n\t\t\t\t\tif (valueElement.asyncWrapper) {\n\t\t\t\t\t\tvalue[j] = valueElement.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar HALT = {};\n\n\t/**\n\t * @param {GrammarElement} command\n\t * @param {Context} ctx\n\t */\n\tfunction unifiedExec(command, ctx) {\n\t\twhile (true) {\n\t\t\ttry {\n\t\t\t\tvar next = unifiedEval(command, ctx);\n\t\t\t} catch (e) {\n\t\t\t\t_runtime.registerHyperTrace(ctx, e);\n\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\tctx[ctx.meta.errorSymmbol] = e;\n\t\t\t\t\tcommand = ctx.meta.errorHandler;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (ctx.meta.reject) {\n\t\t\t\t\tctx.meta.reject(e);\n\t\t\t\t\tnext = HALT;\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (next == null) {\n\t\t\t\tconsole.error(command, \" did not return a next element to execute! context: \", ctx);\n\t\t\t\treturn;\n\t\t\t} else if (next.then) {\n\t\t\t\tnext.then(function (resolvedNext) {\n\t\t\t\t\tunifiedExec(resolvedNext, ctx);\n\t\t\t\t}).catch(function (reason) {\n\t\t\t\t\t_runtime.registerHyperTrace(ctx, reason);\n\t\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\t\tctx[ctx.meta.errorSymmbol] = reason;\n\t\t\t\t\t\tunifiedExec(ctx.meta.errorHandler, ctx);\n\t\t\t\t\t} else if (ctx.meta.reject) {\n\t\t\t\t\t\tctx.meta.reject(reason);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t} else if (next === HALT) {\n\t\t\t\t// done\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tcommand = next; // move to the next command\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {*} parseElement\n\t * @param {Context} ctx\n\t * @returns {*}\n\t */\n\tfunction unifiedEval(parseElement, ctx) {\n\t\t/** @type any[] */\n\t\tvar args = [ctx];\n\t\tvar async = false;\n\t\tvar wrappedAsyncs = false;\n\n\t\tif (parseElement.args) {\n\t\t\tfor (var i = 0; i < parseElement.args.length; i++) {\n\t\t\t\tvar argument = parseElement.args[i];\n\t\t\t\tif (argument == null) {\n\t\t\t\t\targs.push(null);\n\t\t\t\t} else if (Array.isArray(argument)) {\n\t\t\t\t\tvar arr = [];\n\t\t\t\t\tfor (var j = 0; j < argument.length; j++) {\n\t\t\t\t\t\tvar element = argument[j];\n\t\t\t\t\t\tvar value = element ? element.evaluate(ctx) : null; // OK\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarr.push(value);\n\t\t\t\t\t}\n\t\t\t\t\targs.push(arr);\n\t\t\t\t} else if (argument.evaluate) {\n\t\t\t\t\tvar value = argument.evaluate(ctx); // OK\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tif (value.then) {\n\t\t\t\t\t\t\tasync = true;\n\t\t\t\t\t\t} else if (value.asyncWrapper) {\n\t\t\t\t\t\t\twrappedAsyncs = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\targs.push(value);\n\t\t\t\t} else {\n\t\t\t\t\targs.push(argument);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (async) {\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tvar linearized = linearize(args);\n\t\t\t\tPromise.all(linearized)\n\t\t\t\t\t.then(function (values) {\n\t\t\t\t\t\tvalues = delinearize(values);\n\t\t\t\t\t\tif (wrappedAsyncs) {\n\t\t\t\t\t\t\tunwrapAsyncs(values);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tvar apply = parseElement.op.apply(parseElement, values);\n\t\t\t\t\t\t\tresolve(apply);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\treject(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\tif (ctx.meta.errorHandler && !ctx.meta.handlingError) {\n\t\t\t\t\t\t\tctx.meta.handlingError = true;\n\t\t\t\t\t\t\tctx[ctx.meta.errorSymmbol] = reason;\n\t\t\t\t\t\t\tunifiedExec(ctx.meta.errorHandler, ctx);\n\t\t\t\t\t\t} else if (ctx.meta.reject) {\n\t\t\t\t\t\t\tctx.meta.reject(reason);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// TODO: no meta context to reject with, trigger event?\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tif (wrappedAsyncs) {\n\t\t\t\tunwrapAsyncs(args);\n\t\t\t}\n\t\t\treturn parseElement.op.apply(parseElement, args);\n\t\t}\n\t}\n\n\tlet _scriptAttrs = null;\n\n\t/**\n\t * getAttributes returns the attribute name(s) to use when\n\t * locating hyperscript scripts in a DOM element.  If no value\n\t * has been configured, it defaults to _hyperscript.config.attributes\n\t * @returns string[]\n\t */\n\tfunction getScriptAttributes() {\n\t\tif (_scriptAttrs == null) {\n\t\t\t_scriptAttrs = _hyperscript.config.attributes.replace(/ /g, \"\").split(\",\");\n\t\t}\n\t\treturn _scriptAttrs;\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @returns {string | null}\n\t */\n\tfunction getScript(elt) {\n\t\tfor (var i = 0; i < getScriptAttributes().length; i++) {\n\t\t\tvar scriptAttribute = getScriptAttributes()[i];\n\t\t\tif (elt.hasAttribute && elt.hasAttribute(scriptAttribute)) {\n\t\t\t\treturn elt.getAttribute(scriptAttribute);\n\t\t\t}\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\treturn elt.innerText;\n\t\t}\n\t\treturn null;\n\t}\n\n\tvar hyperscriptFeaturesMap = new WeakMap\n\n\t/**\n\t * @param {Element} elt\n\t * @returns {Object}\n\t */\n\tfunction getHyperscriptFeatures(elt) {\n\t\tvar hyperscriptFeatures = hyperscriptFeaturesMap.get(elt);\n\t\tif (typeof hyperscriptFeatures === 'undefined') {\n\t\t\thyperscriptFeaturesMap.set(elt, hyperscriptFeatures = {});\n\t\t}\n\t\treturn hyperscriptFeatures;\n\t}\n\n\t/**\n\t * @param {Object} owner\n\t * @param {Context} ctx\n\t */\n\tfunction addFeatures(owner, ctx) {\n\t\tif (owner) {\n\t\t\tmergeObjects(ctx, getHyperscriptFeatures(owner));\n\t\t\taddFeatures(owner.parentElement, ctx);\n\t\t}\n\t}\n\n\t/**\n\t * @param {*} owner\n\t * @param {*} feature\n\t * @param {*} hyperscriptTarget\n\t * @param {*} event\n\t * @returns {Context}\n\t */\n\tfunction makeContext(owner, feature, hyperscriptTarget, event) {\n\t\t/** @type {Context} */\n\t\tvar ctx = {\n\t\t\tmeta: {\n\t\t\t\tparser: _parser,\n\t\t\t\tlexer: _lexer,\n\t\t\t\truntime: _runtime,\n\t\t\t\towner: owner,\n\t\t\t\tfeature: feature,\n\t\t\t\titerators: {},\n\t\t\t},\n\t\t\tme: hyperscriptTarget,\n\t\t\tevent: event,\n\t\t\ttarget: event ? event.target : null,\n\t\t\tdetail: event ? event.detail : null,\n\t\t\tbody: \"document\" in globalScope ? document.body : null,\n\t\t};\n\t\tctx.meta.ctx = ctx;\n\t\taddFeatures(owner, ctx);\n\t\treturn ctx;\n\t}\n\n\t/**\n\t * @returns string\n\t */\n\tfunction getScriptSelector() {\n\t\treturn getScriptAttributes()\n\t\t\t.map(function (attribute) {\n\t\t\t\treturn \"[\" + attribute + \"]\";\n\t\t\t})\n\t\t\t.join(\", \");\n\t}\n\n\t/**\n\t * @param {any} value\n\t * @param {string} type\n\t * @returns {any}\n\t */\n\tfunction convertValue(value, type) {\n\t\tvar dynamicResolvers = CONVERSIONS.dynamicResolvers;\n\t\tfor (var i = 0; i < dynamicResolvers.length; i++) {\n\t\t\tvar dynamicResolver = dynamicResolvers[i];\n\t\t\tvar converted = dynamicResolver(type, value);\n\t\t\tif (converted !== undefined) {\n\t\t\t\treturn converted;\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\tvar converter = CONVERSIONS[type];\n\t\tif (converter) {\n\t\t\treturn converter(value);\n\t\t}\n\n\t\tthrow \"Unknown conversion : \" + type;\n\t}\n\n\t// TODO: There do not seem to be any references to this function.\n\t// Is it still in use, or can it be removed?\n\tfunction isType(o, type) {\n\t\treturn Object.prototype.toString.call(o) === \"[object \" + type + \"]\";\n\t}\n\n\t/**\n\t * @param {string} src\n\t * @returns {GrammarElement}\n\t */\n\tfunction parse(src) {\n\t\tvar tokens = _lexer.tokenize(src);\n\t\tif (_parser.commandStart(tokens.currentToken())) {\n\t\t\tvar commandList = _parser.requireElement(\"commandList\", tokens);\n\t\t\tvar last = commandList;\n\t\t\twhile (last.next) {\n\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tlast.next = {\n\t\t\t\top: function () {\n\t\t\t\t\treturn HALT;\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn commandList;\n\t\t} else if (_parser.featureStart(tokens.currentToken())) {\n\t\t\tvar hyperscript = _parser.requireElement(\"hyperscript\", tokens);\n\t\t\treturn hyperscript;\n\t\t} else {\n\t\t\tvar expression = _parser.requireElement(\"expression\", tokens);\n\t\t\treturn expression;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} src\n\t * @param {Context} [ctx]\n\t * @param {Object} [args]\n\t * @returns {any}\n\t */\n\tfunction evaluate(src, ctx, args) {\n\t\tclass HyperscriptModule extends EventTarget {\n\t\t\tconstructor(mod) {\n\t\t\t\tsuper();\n\t\t\t\tthis.module = mod;\n\t\t\t}\n\t\t\ttoString() {\n\t\t\t\treturn this.module.id;\n\t\t\t}\n\t\t}\n\n\t\tvar body = 'document' in globalScope\n\t\t\t? globalScope.document.body \n\t\t\t: new HyperscriptModule(args && args.module);\n\t\tctx = mergeObjects(makeContext(body, null, body, null), ctx || {});\n\t\tvar element = parse(src);\n\t\tif (element.execute) {\n\t\t\telement.execute(ctx);\n\t\t\treturn ctx.result;\n\t\t} else if (element.apply) {\n\t\t\telement.apply(body, body, args);\n\t\t\treturn getHyperscriptFeatures(body);\n\t\t} else {\n\t\t\treturn element.evaluate(ctx);\n\t\t}\n\n\t\tfunction makeModule() {\n\t\t\treturn {}\n\t\t}\n\t}\n\n\t/**\n\t * @param {HTMLElement} elt\n\t */\n\tfunction processNode(elt) {\n\t\tvar selector = _runtime.getScriptSelector();\n\t\tif (matchesSelector(elt, selector)) {\n\t\t\tinitElement(elt, elt);\n\t\t}\n\t\tif (elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\") {\n\t\t\tinitElement(elt, document.body);\n\t\t}\n\t\tif (elt.querySelectorAll) {\n\t\t\tforEach(elt.querySelectorAll(selector + \", [type='text/hyperscript']\"), function (elt) {\n\t\t\t\tinitElement(elt, elt instanceof HTMLScriptElement && elt.type === \"text/hyperscript\" ? document.body : elt);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @param {Element} [target]\n\t */\n\tfunction initElement(elt, target) {\n\t\tif (elt.closest && elt.closest(_hyperscript.config.disableSelector)) {\n\t\t\treturn;\n\t\t}\n\t\tvar internalData = getInternalData(elt);\n\t\tif (!internalData.initialized) {\n\t\t\tvar src = getScript(elt);\n\t\t\tif (src) {\n\t\t\t\ttry {\n\t\t\t\t\tinternalData.initialized = true;\n\t\t\t\t\tinternalData.script = src;\n\t\t\t\t\tvar tokens = _lexer.tokenize(src);\n\t\t\t\t\tvar hyperScript = _parser.parseHyperScript(tokens);\n\t\t\t\t\tif (!hyperScript) return;\n\t\t\t\t\thyperScript.apply(target || elt, elt);\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\ttriggerEvent(target || elt, \"load\", {\n\t\t\t\t\t\t\thyperscript: true,\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 1);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_runtime.triggerEvent(elt, \"exception\", {\n\t\t\t\t\t\terror: e,\n\t\t\t\t\t});\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\"hyperscript errors were found on the following element:\",\n\t\t\t\t\t\telt,\n\t\t\t\t\t\t\"\\n\\n\",\n\t\t\t\t\t\te.message,\n\t\t\t\t\t\te.stack\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvar internalDataMap = new WeakMap\n\n\t/**\n\t * @param {Element} elt\n\t * @returns {Object}\n\t */\n\tfunction getInternalData(elt) {\n\t\tvar internalData = internalDataMap.get(elt);\n\t\tif (typeof internalData === 'undefined') {\n\t\t\tinternalDataMap.set(elt, internalData = {});\n\t\t}\n\t\treturn internalData;\n\t}\n\n\t/**\n\t * @param {any} value\n\t * @param {string} typeString\n\t * @param {boolean} [nullOk]\n\t * @returns {boolean}\n\t */\n\tfunction typeCheck(value, typeString, nullOk) {\n\t\tif (value == null && nullOk) {\n\t\t\treturn true;\n\t\t}\n\t\tvar typeName = Object.prototype.toString.call(value).slice(8, -1);\n\t\treturn typeName === typeString;\n\t}\n\n\tfunction getElementScope(context) {\n\t\tvar elt = context.meta && context.meta.owner;\n\t\tif (elt) {\n\t\t\tvar internalData = getInternalData(elt);\n\t\t\tvar scopeName = \"elementScope\";\n\t\t\tif (context.meta.feature && context.meta.feature.behavior) {\n\t\t\t\tscopeName = context.meta.feature.behavior + \"Scope\";\n\t\t\t}\n\t\t\tvar elementScope = getOrInitObject(internalData, scopeName);\n\t\t\treturn elementScope;\n\t\t} else {\n\t\t\treturn {}; // no element, return empty scope\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} str\n\t * @param {Context} context\n\t * @returns {any}\n\t */\n\tfunction resolveSymbol(str, context, type) {\n\t\tif (str === \"me\" || str === \"my\" || str === \"I\") {\n\t\t\treturn context[\"me\"];\n\t\t}\n\t\tif (str === \"it\" || str === \"its\") {\n\t\t\treturn context[\"result\"];\n\t\t}\n\t\tif (str === \"you\" || str === \"your\" || str === \"yourself\") {\n\t\t\treturn context[\"beingTold\"];\n\t\t} else {\n\t\t\tif (type === \"global\") {\n\t\t\t\treturn globalScope[str];\n\t\t\t} else if (type === \"element\") {\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\treturn elementScope[str];\n\t\t\t} else if (type === \"local\") {\n\t\t\t\treturn context[str];\n\t\t\t} else {\n\t\t\t\t// meta scope (used for event conditionals)\n\t\t\t\tif (context.meta && context.meta.context) {\n\t\t\t\t\tvar fromMetaContext = context.meta.context[str];\n\t\t\t\t\tif (typeof fromMetaContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromMetaContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// local scope\n\t\t\t\tvar fromContext = context[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\treturn fromContext;\n\t\t\t\t} else {\n\t\t\t\t\t// element scope\n\t\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\t\tfromContext = elementScope[str];\n\t\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\t\treturn fromContext;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// global scope\n\t\t\t\t\t\treturn globalScope[str];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setSymbol(str, context, type, value) {\n\t\tif (type === \"global\") {\n\t\t\tglobalScope[str] = value;\n\t\t} else if (type === \"element\") {\n\t\t\tvar elementScope = getElementScope(context);\n\t\t\telementScope[str] = value;\n\t\t} else if (type === \"local\") {\n\t\t\tcontext[str] = value;\n\t\t} else {\n\t\t\t// local scope\n\t\t\tvar fromContext = context[str];\n\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\tcontext[str] = value;\n\t\t\t} else {\n\t\t\t\t// element scope\n\t\t\t\tvar elementScope = getElementScope(context);\n\t\t\t\tfromContext = elementScope[str];\n\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\telementScope[str] = value;\n\t\t\t\t} else {\n\t\t\t\t\t// global scope\n\t\t\t\t\tfromContext = globalScope[str];\n\t\t\t\t\tif (typeof fromContext !== \"undefined\") {\n\t\t\t\t\t\tglobalScope[str] = value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext[str] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {GrammarElement} command\n\t * @param {Context} context\n\t * @returns {undefined | GrammarElement}\n\t */\n\tfunction findNext(command, context) {\n\t\tif (command) {\n\t\t\tif (command.resolveNext) {\n\t\t\t\treturn command.resolveNext(context);\n\t\t\t} else if (command.next) {\n\t\t\t\treturn command.next;\n\t\t\t} else {\n\t\t\t\treturn findNext(command.parent, context);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Object<string,any>} root\n\t * @param {string} property\n\t * @param {boolean} attribute\n\t * @returns {any}\n\t */\n\tfunction resolveProperty(root, property, attribute) {\n\t\tif (root != null) {\n\t\t\tvar val = attribute && root.getAttribute ? root.getAttribute(property) : root[property];\n\t\t\tif (typeof val !== \"undefined\") {\n\t\t\t\treturn val;\n\t\t\t}\n\n\t\t\tif (shouldAutoIterate(root)) {\n\t\t\t\t// flat map\n\t\t\t\tvar result = [];\n\t\t\t\tfor (var component of root) {\n\t\t\t\t\tvar componentValue = attribute ? component.getAttribute(property) : component[property];\n\t\t\t\t\tif (componentValue) {\n\t\t\t\t\t\tresult.push(componentValue);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Element} elt\n\t * @param {string[]} nameSpace\n\t * @param {string} name\n\t * @param {any} value\n\t */\n\tfunction assignToNamespace(elt, nameSpace, name, value) {\n\t\tif (typeof document !== \"undefined\" && elt === document.body) {\n\t\t\tvar root = globalScope;\n\t\t} else {\n\t\t\tvar root = getHyperscriptFeatures(elt);\n\t\t}\n\t\twhile (nameSpace.length > 0) {\n\t\t\tvar propertyName = nameSpace.shift();\n\t\t\tvar newRoot = root[propertyName];\n\t\t\tif (newRoot == null) {\n\t\t\t\tnewRoot = {};\n\t\t\t\troot[propertyName] = newRoot;\n\t\t\t}\n\t\t\troot = newRoot;\n\t\t}\n\n\t\troot[name] = value;\n\t}\n\n\tfunction getHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = ctx;\n\t\twhile (root.meta.caller) {\n\t\t\troot = root.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap) {\n\t\t\treturn root.meta.traceMap.get(thrown, trace);\n\t\t}\n\t}\n\n\tfunction registerHyperTrace(ctx, thrown) {\n\t\tvar trace = [];\n\t\tvar root = null;\n\t\twhile (ctx != null) {\n\t\t\ttrace.push(ctx);\n\t\t\troot = ctx;\n\t\t\tctx = ctx.meta.caller;\n\t\t}\n\t\tif (root.meta.traceMap == null) {\n\t\t\troot.meta.traceMap = new Map(); // TODO - WeakMap?\n\t\t}\n\t\tif (!root.meta.traceMap.get(thrown)) {\n\t\t\tvar traceEntry = {\n\t\t\t\ttrace: trace,\n\t\t\t\tprint: function (logger) {\n\t\t\t\t\tlogger = logger || console.error;\n\t\t\t\t\tlogger(\"hypertrace /// \");\n\t\t\t\t\tvar maxLen = 0;\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tmaxLen = Math.max(maxLen, trace[i].meta.feature.displayName.length);\n\t\t\t\t\t}\n\t\t\t\t\tfor (var i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tvar traceElt = trace[i];\n\t\t\t\t\t\tlogger(\n\t\t\t\t\t\t\t\"  ->\",\n\t\t\t\t\t\t\ttraceElt.meta.feature.displayName.padEnd(maxLen + 2),\n\t\t\t\t\t\t\t\"-\",\n\t\t\t\t\t\t\ttraceElt.meta.owner\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\troot.meta.traceMap.set(thrown, traceEntry);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} str\n\t * @returns {string}\n\t */\n\tfunction escapeSelector(str) {\n\t\treturn str.replace(/:/g, function (str) {\n\t\t\treturn \"\\\\\" + str;\n\t\t});\n\t}\n\n\t/**\n\t * @param {any} value\n\t * @param {*} elt\n\t */\n\tfunction nullCheck(value, elt) {\n\t\tif (value == null) {\n\t\t\tthrow new Error(elt.sourceFor() + \" is null\");\n\t\t}\n\t}\n\n\t/**\n\t * @param {any} value\n\t * @returns {boolean}\n\t */\n\tfunction isEmpty(value) {\n\t\treturn value == undefined || value.length === 0;\n\t}\n\n\t/**\n\t * @param {Node} node\n\t * @returns {Document|ShadowRoot}\n\t */\n\tfunction getRootNode(node) {\n\t\tvar rv = node.getRootNode();\n\t\tif (rv instanceof Document || rv instanceof ShadowRoot) return rv;\n\t\telse return document;\n\t}\n\n\t/** @type string | null */\n\t// @ts-ignore\n\tvar hyperscriptUrl = \"document\" in globalScope ? import.meta.url : null;\n\n\t/** @type {RuntimeObject} */\n\treturn {\n\t\ttypeCheck: typeCheck,\n\t\tforEach: forEach,\n\t\timplicitLoop: implicitLoop,\n\t\ttriggerEvent: triggerEvent,\n\t\tmatchesSelector: matchesSelector,\n\t\tgetScript: getScript,\n\t\tprocessNode: processNode,\n\t\tevaluate: evaluate,\n\t\tparse: parse,\n\t\tgetScriptSelector: getScriptSelector,\n\t\tresolveSymbol: resolveSymbol,\n\t\tsetSymbol: setSymbol,\n\t\tmakeContext: makeContext,\n\t\tfindNext: findNext,\n\t\tunifiedEval: unifiedEval,\n\t\tconvertValue: convertValue,\n\t\tunifiedExec: unifiedExec,\n\t\tresolveProperty: resolveProperty,\n\t\tassignToNamespace: assignToNamespace,\n\t\tregisterHyperTrace: registerHyperTrace,\n\t\tgetHyperTrace: getHyperTrace,\n\t\tgetInternalData: getInternalData,\n\t\tescapeSelector: escapeSelector,\n\t\tnullCheck: nullCheck,\n\t\tisEmpty: isEmpty,\n\t\tgetRootNode: getRootNode,\n\t\thyperscriptUrl: hyperscriptUrl,\n\t\tHALT: HALT,\n\t};\n})();\n\n//====================================================================\n// Grammar\n//====================================================================\n{\n\t_parser.addLeafExpression(\"parenthesized\", function (parser, _runtime, tokens) {\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tvar follows = tokens.clearFollow();\n\t\t\ttry {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.restoreFollow(follows);\n\t\t\t}\n\t\t\ttokens.requireOpToken(\")\");\n\t\t\treturn expr;\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"string\", function (parser, runtime, tokens) {\n\t\tvar stringToken = tokens.matchTokenType(\"STRING\");\n\t\tif (!stringToken) return;\n\t\tvar rawValue = stringToken.value;\n\t\t/** @type {any[]} */\n\t\tvar args;\n\t\tif (stringToken.template) {\n\t\t\tvar innerTokens = _lexer.tokenize(rawValue, true);\n\t\t\targs = parser.parseStringTemplate(innerTokens);\n\t\t} else {\n\t\t\targs = [];\n\t\t}\n\t\treturn {\n\t\t\ttype: \"string\",\n\t\t\ttoken: stringToken,\n\t\t\targs: args,\n\t\t\top: function (context) {\n\t\t\t\tvar returnStr = \"\";\n\t\t\t\tfor (var i = 1; i < arguments.length; i++) {\n\t\t\t\t\tvar val = arguments[i];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\treturnStr += val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn returnStr;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\tif (args.length === 0) {\n\t\t\t\t\treturn rawValue;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"nakedString\", function (parser, runtime, tokens) {\n\t\tif (tokens.hasMore()) {\n\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\treturn {\n\t\t\t\ttype: \"nakedString\",\n\t\t\t\ttokens: tokenArr,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn tokenArr\n\t\t\t\t\t\t.map(function (t) {\n\t\t\t\t\t\t\treturn t.value;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join(\"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"number\", function (parser, runtime, tokens) {\n\t\tvar number = tokens.matchTokenType(\"NUMBER\");\n\t\tif (!number) return;\n\t\tvar numberToken = number;\n\t\tvar value = parseFloat(number.value);\n\t\treturn {\n\t\t\ttype: \"number\",\n\t\t\tvalue: value,\n\t\t\tnumberToken: numberToken,\n\t\t\tevaluate: function () {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"idRef\", function (parser, runtime, tokens) {\n\t\tvar elementId = tokens.matchTokenType(\"ID_REF\");\n\t\tif (!elementId) return;\n\t\t// TODO - unify these two expression types\n\t\tif (elementId.template) {\n\t\t\tvar templateValue = elementId.value.substr(2, elementId.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"idRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn runtime.getRootNode(context.me).getElementById(arg);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst value = elementId.value.substr(1);\n\t\t\treturn {\n\t\t\t\ttype: \"idRef\",\n\t\t\t\tcss: elementId.value,\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\truntime.getRootNode(context.me).getElementById(value)\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"classRef\", function (parser, runtime, tokens) {\n\t\tvar classRef = tokens.matchTokenType(\"CLASS_REF\");\n\n\t\tif (!classRef) return;\n\n\t\t// TODO - unify these two expression types\n\t\tif (classRef.template) {\n\t\t\tvar templateValue = classRef.value.substr(2, classRef.value.length - 2);\n\t\t\tvar innerTokens = _lexer.tokenize(templateValue);\n\t\t\tvar innerExpression = parser.requireElement(\"expression\", innerTokens);\n\t\t\treturn {\n\t\t\t\ttype: \"classRefTemplate\",\n\t\t\t\targs: [innerExpression],\n\t\t\t\top: function (context, arg) {\n\t\t\t\t\treturn new ElementCollection(\".\" + arg, context.me)\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tconst css = classRef.value;\n\t\t\treturn {\n\t\t\t\ttype: \"classRef\",\n\t\t\t\tcss: css,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn new ElementCollection(css, context.me)\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\tclass TemplatedQueryElementCollection extends ElementCollection {\n\t\tconstructor(css, relativeToElement, templateParts) {\n\t\t\tsuper(css, relativeToElement);\n\t\t\tthis.templateParts = templateParts;\n\t\t\tthis.elements = templateParts.filter(elt => elt instanceof Element);\n\t\t}\n\n\t\tget css() {\n\t\t\tlet rv = \"\", i = 0\n\t\t\tfor (const val of this.templateParts) {\n\t\t\t\tif (val instanceof Element) {\n\t\t\t\t\trv += \"[data-hs-query-id='\" + i++ + \"']\";\n\t\t\t\t} else rv += val;\n\t\t\t}\n\t\t\treturn rv;\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\tthis.elements.forEach((el, i) => el.dataset.hsQueryId = i);\n\t\t\tconst rv = super[Symbol.iterator]();\n\t\t\tthis.elements.forEach(el => el.removeAttribute('data-hs-query-id'));\n\t\t\treturn rv;\n\t\t}\n\t}\n\n\t_parser.addLeafExpression(\"queryRef\", function (parser, runtime, tokens) {\n\t\tvar queryStart = tokens.matchOpToken(\"<\");\n\t\tif (!queryStart) return;\n\t\tvar queryTokens = tokens.consumeUntil(\"/\");\n\t\ttokens.requireOpToken(\"/\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar queryValue = queryTokens\n\t\t\t.map(function (t) {\n\t\t\t\tif (t.type === \"STRING\") {\n\t\t\t\t\treturn '\"' + t.value + '\"';\n\t\t\t\t} else {\n\t\t\t\t\treturn t.value;\n\t\t\t\t}\n\t\t\t})\n\t\t\t.join(\"\");\n\n\t\tif (queryValue.indexOf(\"$\") >= 0) {\n\t\t\tvar template = true;\n\t\t\tvar innerTokens = _lexer.tokenize(queryValue, true);\n\t\t\tvar args = parser.parseStringTemplate(innerTokens);\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"queryRef\",\n\t\t\tcss: queryValue,\n\t\t\targs: args,\n\t\t\top: function (context, ...args) {\n\t\t\t\tif (template) {\n\t\t\t\t\treturn new TemplatedQueryElementCollection(queryValue, context.me, args)\n\t\t\t\t} else {\n\t\t\t\t\treturn new ElementCollection(queryValue, context.me)\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"attributeRef\", function (parser, runtime, tokens) {\n\t\tvar attributeRef = tokens.matchTokenType(\"ATTRIBUTE_REF\");\n\t\tif (!attributeRef) return;\n\t\tvar outerVal = attributeRef.value;\n\t\tif (outerVal.indexOf(\"[\") === 0) {\n\t\t\tvar innerValue = outerVal.substring(2, outerVal.length - 1);\n\t\t} else {\n\t\t\tvar innerValue = outerVal.substring(1);\n\t\t}\n\t\tvar css = \"[\" + innerValue + \"]\";\n\t\tvar split = innerValue.split(\"=\");\n\t\tvar name = split[0];\n\t\tvar value = split[1];\n\t\tif (value) {\n\t\t\t// strip quotes\n\t\t\tif (value.indexOf('\"') === 0) {\n\t\t\t\tvalue = value.substring(1, value.length - 1);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"attributeRef\",\n\t\t\tname: name,\n\t\t\tcss: css,\n\t\t\tvalue: value,\n\t\t\top: function (context) {\n\t\t\t\tvar target = context.beingTold || context.me;\n\t\t\t\tif (target) {\n\t\t\t\t\treturn target.getAttribute(name);\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"objectKey\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: token.value,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t} else if (tokens.matchOpToken(\"[\")) {\n\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\texpr: expr,\n\t\t\t\targs: [expr],\n\t\t\t\top: function (ctx, expr) {\n\t\t\t\t\treturn expr;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar key = \"\";\n\t\t\tdo {\n\t\t\t\ttoken = tokens.matchTokenType(\"IDENTIFIER\") || tokens.matchOpToken(\"-\");\n\t\t\t\tif (token) key += token.value;\n\t\t\t} while (token);\n\t\t\treturn {\n\t\t\t\ttype: \"objectKey\",\n\t\t\t\tkey: key,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn key;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"objectLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"{\")) return;\n\t\tvar keyExpressions = [];\n\t\tvar valueExpressions = [];\n\t\tif (!tokens.matchOpToken(\"}\")) {\n\t\t\tdo {\n\t\t\t\tvar name = parser.requireElement(\"objectKey\", tokens);\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tkeyExpressions.push(name);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"}\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"objectLiteral\",\n\t\t\targs: [keyExpressions, valueExpressions],\n\t\t\top: function (context, keys, values) {\n\t\t\t\tvar returnVal = {};\n\t\t\t\tfor (var i = 0; i < keys.length; i++) {\n\t\t\t\t\treturnVal[keys[i]] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"namedArgumentList\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar fields = [];\n\t\tvar valueExpressions = [];\n\t\tif (!tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\ttokens.requireOpToken(\":\");\n\t\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalueExpressions.push(value);\n\t\t\t\tfields.push({ name: name, value: value });\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"namedArgumentList\",\n\t\t\tfields: fields,\n\t\t\targs: [valueExpressions],\n\t\t\top: function (context, values) {\n\t\t\t\tvar returnVal = { _namedArgList_: true };\n\t\t\t\tfor (var i = 0; i < values.length; i++) {\n\t\t\t\t\tvar field = fields[i];\n\t\t\t\t\treturnVal[field.name.value] = values[i];\n\t\t\t\t}\n\t\t\t\treturn returnVal;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"symbol\", function (parser, runtime, tokens) {\n\t\t/** @type {SymbolScope} */\n\t\tvar type = \"default\";\n\t\tif (tokens.matchToken(\"global\")) {\n\t\t\ttype = \"global\";\n\t\t} else if (tokens.matchToken(\"element\") || tokens.matchToken(\"module\")) {\n\t\t\ttype = \"element\";\n\t\t\t// optional possessive\n\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t} else if (tokens.matchToken(\"local\")) {\n\t\t\ttype = \"local\";\n\t\t}\n\t\tvar identifier = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (identifier) {\n\t\t\tconst name = identifier.value;\n\t\t\treturn {\n\t\t\t\ttype: \"symbol\",\n\t\t\t\tsymbolType: type,\n\t\t\t\ttoken: identifier,\n\t\t\t\tname: name,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.resolveSymbol(name, context, type);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"implicitMeTarget\", function (parser, runtime, tokens) {\n\t\treturn {\n\t\t\ttype: \"implicitMeTarget\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn context.beingTold || context.me;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"boolean\", function (parser, runtime, tokens) {\n\t\tvar booleanLiteral = tokens.matchToken(\"true\") || tokens.matchToken(\"false\");\n\t\tif (!booleanLiteral) return;\n\t\tconst value = booleanLiteral.value === \"true\";\n\t\treturn {\n\t\t\ttype: \"boolean\",\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn value;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"null\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"null\")) {\n\t\t\treturn {\n\t\t\t\ttype: \"null\",\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn null;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addLeafExpression(\"arrayLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar values = [];\n\t\tif (!tokens.matchOpToken(\"]\")) {\n\t\t\tdo {\n\t\t\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvalues.push(expr);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\"]\");\n\t\t}\n\t\treturn {\n\t\t\ttype: \"arrayLiteral\",\n\t\t\tvalues: values,\n\t\t\targs: [values],\n\t\t\top: function (context, values) {\n\t\t\t\treturn values;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addLeafExpression(\"blockLiteral\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"\\\\\")) return;\n\t\tvar args = [];\n\t\tvar arg1 = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (arg1) {\n\t\t\targs.push(arg1);\n\t\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t}\n\t\t}\n\t\t// TODO compound op token\n\t\ttokens.requireOpToken(\"-\");\n\t\ttokens.requireOpToken(\">\");\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\treturn {\n\t\t\ttype: \"blockLiteral\",\n\t\t\targs: args,\n\t\t\texpr: expr,\n\t\t\tevaluate: function (ctx) {\n\t\t\t\tvar returnFunc = function () {\n\t\t\t\t\t//TODO - push scope\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tctx[args[i].value] = arguments[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn expr.evaluate(ctx); //OK\n\t\t\t\t};\n\t\t\t\treturn returnFunc;\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"timeExpression\", function (parser, runtime, tokens) {\n\t\tvar time = parser.requireElement(\"expression\", tokens);\n\t\tvar factor = 1;\n\t\tif (tokens.matchToken(\"s\") || tokens.matchToken(\"seconds\")) {\n\t\t\tfactor = 1000;\n\t\t} else if (tokens.matchToken(\"ms\") || tokens.matchToken(\"milliseconds\")) {\n\t\t\t// do nothing\n\t\t}\n\t\treturn {\n\t\t\ttype: \"timeExpression\",\n\t\t\ttime: time,\n\t\t\tfactor: factor,\n\t\t\targs: [time],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn val * factor;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addIndirectExpression(\"propertyAccess\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\".\")) return;\n\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\tvar propertyAccess = {\n\t\t\ttype: \"propertyAccess\",\n\t\t\troot: root,\n\t\t\tprop: prop,\n\t\t\targs: [root],\n\t\t\top: function (_context, rootVal) {\n\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value, false);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"of\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"of\")) return;\n\t\tvar newRoot = parser.requireElement(\"expression\", tokens);\n\t\t// find the urroot\n\t\tvar childOfUrRoot = null;\n\t\tvar urRoot = root;\n\t\twhile (urRoot.root) {\n\t\t\tchildOfUrRoot = urRoot;\n\t\t\turRoot = urRoot.root;\n\t\t}\n\t\tif (urRoot.type !== \"symbol\" && urRoot.type !== \"attributeRef\") {\n\t\t\tparser.raiseParseError(tokens, \"Cannot take a property of a non-symbol: \" + urRoot.type);\n\t\t}\n\t\tvar attribute = urRoot.type === \"attributeRef\";\n\t\tvar prop = urRoot.name;\n\t\tvar propertyAccess = {\n\t\t\ttype: \"ofExpression\",\n\t\t\tprop: urRoot.token,\n\t\t\troot: newRoot,\n\t\t\tattribute: attribute,\n\t\t\texpression: root,\n\t\t\targs: [newRoot],\n\t\t\top: function (context, rootVal) {\n\t\t\t\treturn runtime.resolveProperty(rootVal, prop, attribute);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\tif (urRoot.type === \"attributeRef\") {\n\t\t\tpropertyAccess.attribute = urRoot;\n\t\t}\n\t\tif (childOfUrRoot) {\n\t\t\tchildOfUrRoot.root = propertyAccess;\n\t\t\tchildOfUrRoot.args = [propertyAccess];\n\t\t} else {\n\t\t\troot = propertyAccess;\n\t\t}\n\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, root);\n\t});\n\n\t_parser.addIndirectExpression(\"possessive\", function (parser, runtime, tokens, root) {\n\t\tif (parser.possessivesDisabled) {\n\t\t\treturn;\n\t\t}\n\t\tvar apostrophe = tokens.matchOpToken(\"'\");\n\t\tif (\n\t\t\tapostrophe ||\n\t\t\t(root.type === \"symbol\" &&\n\t\t\t\t(root.name === \"my\" || root.name === \"its\" || root.name === \"your\") &&\n\t\t\t\ttokens.currentToken().type === \"IDENTIFIER\")\n\t\t) {\n\t\t\tif (apostrophe) {\n\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t}\n\t\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\t\tif (attribute == null) {\n\t\t\t\tvar prop = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t}\n\t\t\tvar propertyAccess = {\n\t\t\t\ttype: \"possessive\",\n\t\t\t\troot: root,\n\t\t\t\tattribute: attribute,\n\t\t\t\tprop: prop,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, rootVal) {\n\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvar value = runtime.resolveProperty(rootVal, attribute.name, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar value = runtime.resolveProperty(rootVal, prop.value, false);\n\t\t\t\t\t}\n\t\t\t\t\treturn value;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t\t}\n\t});\n\n\t_parser.addIndirectExpression(\"inExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"in\")) return;\n\t\tif ((root.type !== \"idRef\" && root.type === \"queryRef\") || root.type === \"classRef\") {\n\t\t\tvar query = true;\n\t\t}\n\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\tvar propertyAccess = {\n\t\t\ttype: \"inExpression\",\n\t\t\troot: root,\n\t\t\targs: [query ? null : root, target],\n\t\t\top: function (context, rootVal, target) {\n\t\t\t\tvar returnArr = [];\n\t\t\t\tif (query) {\n\t\t\t\t\truntime.forEach(target, function (targetElt) {\n\t\t\t\t\t\tvar results = targetElt.querySelectorAll(root.css);\n\t\t\t\t\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\treturnArr.push(results[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\truntime.forEach(rootVal, function (rootElt) {\n\t\t\t\t\t\truntime.forEach(target, function (targetElt) {\n\t\t\t\t\t\t\tif (rootElt === targetElt) {\n\t\t\t\t\t\t\t\treturnArr.push(rootElt);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (returnArr.length > 0) {\n\t\t\t\t\treturn returnArr;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"asExpression\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchToken(\"as\")) return;\n\t\tvar conversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate(); // OK No promise\n\t\tvar propertyAccess = {\n\t\t\ttype: \"asExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, rootVal) {\n\t\t\t\treturn runtime.convertValue(rootVal, conversion);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, propertyAccess);\n\t});\n\n\t_parser.addIndirectExpression(\"functionCall\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"(\")) return;\n\t\tvar args = [];\n\t\tif (!tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\n\t\tif (root.root) {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root.root, args],\n\t\t\t\top: function (context, rootRoot, args) {\n\t\t\t\t\truntime.nullCheck(rootRoot, root.root);\n\t\t\t\t\tvar func = rootRoot[root.prop.value];\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targs.push(context);\n\t\t\t\t\t}\n\t\t\t\t\treturn func.apply(rootRoot, args);\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\tvar functionCall = {\n\t\t\t\ttype: \"functionCall\",\n\t\t\t\troot: root,\n\t\t\t\targExressions: args,\n\t\t\t\targs: [root, args],\n\t\t\t\top: function (context, func, argVals) {\n\t\t\t\t\truntime.nullCheck(func, root);\n\t\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\t\targVals.push(context);\n\t\t\t\t\t}\n\t\t\t\t\tvar apply = func.apply(null, argVals);\n\t\t\t\t\treturn apply;\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn parser.parseElement(\"indirectExpression\", tokens, functionCall);\n\t});\n\n\t_parser.addIndirectExpression(\"attributeRefAccess\", function (parser, runtime, tokens, root) {\n\t\tvar attribute = parser.parseElement(\"attributeRef\", tokens);\n\t\tif (!attribute) return;\n\t\tvar attributeAccess = {\n\t\t\ttype: \"attributeRefAccess\",\n\t\t\troot: root,\n\t\t\tattribute: attribute,\n\t\t\targs: [root],\n\t\t\top: function (_ctx, rootVal) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar value = runtime.resolveProperty(rootVal, attribute.name, true);\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t\treturn attributeAccess;\n\t});\n\n\t_parser.addIndirectExpression(\"arrayIndex\", function (parser, runtime, tokens, root) {\n\t\tif (!tokens.matchOpToken(\"[\")) return;\n\t\tvar andBefore = false;\n\t\tvar andAfter = false;\n\t\tvar firstIndex = null;\n\t\tvar secondIndex = null;\n\n\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\tandBefore = true;\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tfirstIndex = parser.requireElement(\"expression\", tokens);\n\n\t\t\tif (tokens.matchOpToken(\"..\")) {\n\t\t\t\tandAfter = true;\n\t\t\t\tvar current = tokens.currentToken();\n\t\t\t\tif (current.type !== \"R_BRACKET\") {\n\t\t\t\t\tsecondIndex = parser.parseElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttokens.requireOpToken(\"]\");\n\n\t\tvar arrayIndex = {\n\t\t\ttype: \"arrayIndex\",\n\t\t\troot: root,\n\t\t\tfirstIndex: firstIndex,\n\t\t\tsecondIndex: secondIndex,\n\t\t\targs: [root, firstIndex, secondIndex],\n\t\t\top: function (_ctx, root, firstIndex, secondIndex) {\n\t\t\t\tif (andBefore) {\n\t\t\t\t\treturn root.slice(0, firstIndex + 1); // returns all items from beginning to firstIndex (inclusive)\n\t\t\t\t} else if (andAfter) {\n\t\t\t\t\tif (secondIndex != null) {\n\t\t\t\t\t\treturn root.slice(firstIndex, secondIndex + 1); // returns all items from firstIndex to secondIndex (inclusive)\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn root.slice(firstIndex); // returns from firstIndex to end of array\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn root[firstIndex];\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn _runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\treturn _parser.parseElement(\"indirectExpression\", tokens, arrayIndex);\n\t});\n\n\t_parser.addGrammarElement(\"postfixExpression\", function (parser, runtime, tokens) {\n\t\tvar root = parser.parseElement(\"primaryExpression\", tokens);\n\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\treturn {\n\t\t\t\ttype: \"typeCheck\",\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\targs: [root],\n\t\t\t\top: function (context, val) {\n\t\t\t\t\tvar passed = runtime.typeCheck(val, typeName.value, nullOk);\n\t\t\t\t\tif (passed) {\n\t\t\t\t\t\treturn val;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(\"Typecheck failed!  Expected: \" + typeName.value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn root;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"logicalNot\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"not\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"logicalNot\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, val) {\n\t\t\t\treturn !val;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"noExpression\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"no\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"noExpression\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (_context, val) {\n\t\t\t\treturn runtime.isEmpty(val);\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"negativeNumber\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchOpToken(\"-\")) return;\n\t\tvar root = parser.requireElement(\"unaryExpression\", tokens);\n\t\treturn {\n\t\t\ttype: \"negativeNumber\",\n\t\t\troot: root,\n\t\t\targs: [root],\n\t\t\top: function (context, value) {\n\t\t\t\treturn -1 * value;\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"unaryExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf(\n\t\t\t[\"logicalNot\", \"relativePositionalExpression\", \"positionalExpression\", \"noExpression\", \"negativeNumber\", \"postfixExpression\"],\n\t\t\ttokens\n\t\t);\n\t});\n\n\tvar scanForwardQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = 0; i < results.length; i++) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_PRECEDING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[0];\n\t\t}\n\t}\n\n\tvar scanBackwardsQuery = function(start, root, match, wrap) {\n\t\tvar results = root.querySelectorAll(match);\n\t\tfor (var i = results.length - 1; i >= 0; i--) {\n\t\t\tvar elt = results[i];\n\t\t\tif (elt.compareDocumentPosition(start) === Node.DOCUMENT_POSITION_FOLLOWING) {\n\t\t\t\treturn elt;\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\treturn results[results.length - 1];\n\t\t}\n\t}\n\n\tvar scanForwardArray = function(start, array, match, wrap) {\n\t\tvar matches = [];\n\t\t_runtime.forEach(array, function(elt){\n\t\t\tif (elt.matches(match) || elt === start) {\n\t\t\t\tmatches.push(elt);\n\t\t\t}\n\t\t})\n\t\tfor (var i = 0; i < matches.length - 1; i++) {\n\t\t\tvar elt = matches[i];\n\t\t\tif (elt === start) {\n\t\t\t\treturn matches[i + 1];\n\t\t\t}\n\t\t}\n\t\tif (wrap) {\n\t\t\tvar first = matches[0];\n\t\t\tif (first && first.matches(match)) {\n\t\t\t\treturn first;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar scanBackwardsArray = function(start, array, match, wrap) {\n\t\treturn scanForwardArray(start, Array.from(array).reverse(), match, wrap);\n\t}\n\n\t_parser.addGrammarElement(\"relativePositionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"next\", \"previous\");\n\t\tif (!op) return;\n\t\tif (op.value === \"next\") {\n\t\t\tvar forwardSearch = true;\n\t\t}\n\n\t\tvar thing = parser.parseElement(\"expression\", tokens);\n\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\ttokens.pushFollow(\"in\");\n\t\t\ttry {\n\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t} finally {\n\t\t\t\ttokens.popFollow();\n\t\t\t}\n\t\t} else {\n\t\t\tvar from = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar inSearch = false;\n\t\tvar withinElt;\n\t\tif (tokens.matchToken(\"in\")) {\n\t\t\tinSearch = true;\n\t\t\tvar inElt = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"within\")) {\n\t\t\twithinElt = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\twithinElt = document.body;\n\t\t}\n\n\t\tvar wrapping = false;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\ttokens.requireToken(\"wrapping\")\n\t\t\twrapping = true;\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"relativePositionalExpression\",\n\t\t\tfrom: from,\n\t\t\tforwardSearch: forwardSearch,\n\t\t\tinSearch: inSearch,\n\t\t\twrapping: wrapping,\n\t\t\tinElt: inElt,\n\t\t\twithinElt: withinElt,\n\t\t\toperator: op.value,\n\t\t\targs: [thing, from, inElt, withinElt],\n\t\t\top: function (context, thing, from, inElt, withinElt) {\n\n\t\t\t\tvar css = thing.css;\n\t\t\t\tif (css == null) {\n\t\t\t\t\tthrow \"Expected a CSS value\";\n\t\t\t\t}\n\n\t\t\t\tif(inSearch) {\n\t\t\t\t\tif (inElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsArray(from, inElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (withinElt) {\n\t\t\t\t\t\tif (forwardSearch) {\n\t\t\t\t\t\t\treturn scanForwardQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn scanBackwardsQuery(from, withinElt, css, wrapping);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t}\n\n\t});\n\n\t_parser.addGrammarElement(\"positionalExpression\", function (parser, runtime, tokens) {\n\t\tvar op = tokens.matchAnyToken(\"first\", \"last\", \"random\");\n\t\tif (!op) return;\n\t\ttokens.matchAnyToken(\"in\", \"from\", \"of\");\n\t\tvar rhs = parser.requireElement(\"unaryExpression\", tokens);\n\t\tconst operator = op.value;\n\t\treturn {\n\t\t\ttype: \"positionalExpression\",\n\t\t\trhs: rhs,\n\t\t\toperator: op.value,\n\t\t\targs: [rhs],\n\t\t\top: function (context, rhsVal) {\n\t\t\t\tif (rhsVal && !Array.isArray(rhsVal)) {\n\t\t\t\t\tif (rhsVal.children) {\n\t\t\t\t\t\trhsVal = rhsVal.children;\n\t\t\t\t\t} else {\n\t\t\t\t\t\trhsVal = Array.from(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rhsVal) {\n\t\t\t\t\tif (operator === \"first\") {\n\t\t\t\t\t\treturn rhsVal[0];\n\t\t\t\t\t} else if (operator === \"last\") {\n\t\t\t\t\t\treturn rhsVal[rhsVal.length - 1];\n\t\t\t\t\t} else if (operator === \"random\") {\n\t\t\t\t\t\treturn rhsVal[Math.floor(Math.random() * rhsVal.length)];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addGrammarElement(\"mathOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"unaryExpression\", tokens);\n\t\tvar mathOp,\n\t\t\tinitialMathOp = null;\n\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\twhile (mathOp) {\n\t\t\tinitialMathOp = initialMathOp || mathOp;\n\t\t\tvar operator = mathOp.value;\n\t\t\tif (initialMathOp.value !== operator) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize math operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.parseElement(\"unaryExpression\", tokens);\n\t\t\texpr = {\n\t\t\t\ttype: \"mathOperator\",\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\toperator: operator,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"+\") {\n\t\t\t\t\t\treturn lhsVal + rhsVal;\n\t\t\t\t\t} else if (operator === \"-\") {\n\t\t\t\t\t\treturn lhsVal - rhsVal;\n\t\t\t\t\t} else if (operator === \"*\") {\n\t\t\t\t\t\treturn lhsVal * rhsVal;\n\t\t\t\t\t} else if (operator === \"/\") {\n\t\t\t\t\t\treturn lhsVal / rhsVal;\n\t\t\t\t\t} else if (operator === \"%\") {\n\t\t\t\t\t\treturn lhsVal % rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tmathOp = tokens.matchAnyOpToken(\"+\", \"-\", \"*\", \"/\", \"%\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"mathExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"mathOperator\", \"unaryExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"comparisonOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"mathExpression\", tokens);\n\t\tvar comparisonToken = tokens.matchAnyOpToken(\"<\", \">\", \"<=\", \">=\", \"==\", \"===\", \"!=\", \"!==\");\n\t\tvar operator = comparisonToken ? comparisonToken.value : null;\n\t\tvar hasRightValue = true; // By default, most comparisons require two values, but there are some exceptions.\n\t\tvar typeCheck = false;\n\n\t\tif (operator == null) {\n\t\t\tif (tokens.matchToken(\"is\") || tokens.matchToken(\"am\")) {\n\t\t\t\tif (tokens.matchToken(\"not\")) {\n\t\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\t\toperator = \"not in\";\n\t\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\t\toperator = \"not a\";\n\t\t\t\t\t\ttypeCheck = true;\n\t\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\t\toperator = \"not empty\";\n\t\t\t\t\t\thasRightValue = false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\toperator = \"!=\";\n\t\t\t\t\t}\n\t\t\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\t\t\toperator = \"in\";\n\t\t\t\t} else if (tokens.matchToken(\"a\")) {\n\t\t\t\t\toperator = \"a\";\n\t\t\t\t\ttypeCheck = true;\n\t\t\t\t} else if (tokens.matchToken(\"empty\")) {\n\t\t\t\t\toperator = \"empty\";\n\t\t\t\t\thasRightValue = false;\n\t\t\t\t} else {\n\t\t\t\t\toperator = \"==\";\n\t\t\t\t}\n\t\t\t} else if (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\toperator = \"match\";\n\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\toperator = \"contain\";\n\t\t\t} else if (tokens.matchToken(\"do\") || tokens.matchToken(\"does\")) {\n\t\t\t\ttokens.requireToken(\"not\");\n\t\t\t\tif (tokens.matchToken(\"matches\") || tokens.matchToken(\"match\")) {\n\t\t\t\t\toperator = \"not match\";\n\t\t\t\t} else if (tokens.matchToken(\"contains\") || tokens.matchToken(\"contain\")) {\n\t\t\t\t\toperator = \"not contain\";\n\t\t\t\t} else {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected matches or contains\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (operator) {\n\t\t\t// Do not allow chained comparisons, which is dumb\n\t\t\tif (typeCheck) {\n\t\t\t\tvar typeName = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\tvar nullOk = !tokens.matchOpToken(\"!\");\n\t\t\t} else if (hasRightValue) {\n\t\t\t\tvar rhs = parser.requireElement(\"mathExpression\", tokens);\n\t\t\t\tif (operator === \"match\" || operator === \"not match\") {\n\t\t\t\t\trhs = rhs.css ? rhs.css : rhs;\n\t\t\t\t}\n\t\t\t}\n\t\t\texpr = {\n\t\t\t\ttype: \"comparisonOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\ttypeName: typeName,\n\t\t\t\tnullOk: nullOk,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"==\") {\n\t\t\t\t\t\treturn lhsVal == rhsVal;\n\t\t\t\t\t} else if (operator === \"!=\") {\n\t\t\t\t\t\treturn lhsVal != rhsVal;\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"in\") {\n\t\t\t\t\t\treturn rhsVal != null && Array.from(rhsVal).indexOf(lhsVal) >= 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not in\") {\n\t\t\t\t\t\treturn rhsVal == null || Array.from(rhsVal).indexOf(lhsVal) < 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"match\") {\n\t\t\t\t\t\treturn lhsVal != null && lhsVal.matches(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not match\") {\n\t\t\t\t\t\treturn lhsVal == null || !lhsVal.matches(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"contain\") {\n\t\t\t\t\t\treturn lhsVal != null && lhsVal.contains(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"not contain\") {\n\t\t\t\t\t\treturn lhsVal == null || !lhsVal.contains(rhsVal);\n\t\t\t\t\t}\n\t\t\t\t\tif (operator === \"===\") {\n\t\t\t\t\t\treturn lhsVal === rhsVal;\n\t\t\t\t\t} else if (operator === \"!==\") {\n\t\t\t\t\t\treturn lhsVal !== rhsVal;\n\t\t\t\t\t} else if (operator === \"<\") {\n\t\t\t\t\t\treturn lhsVal < rhsVal;\n\t\t\t\t\t} else if (operator === \">\") {\n\t\t\t\t\t\treturn lhsVal > rhsVal;\n\t\t\t\t\t} else if (operator === \"<=\") {\n\t\t\t\t\t\treturn lhsVal <= rhsVal;\n\t\t\t\t\t} else if (operator === \">=\") {\n\t\t\t\t\t\treturn lhsVal >= rhsVal;\n\t\t\t\t\t} else if (operator === \"empty\") {\n\t\t\t\t\t\treturn runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"not empty\") {\n\t\t\t\t\t\treturn !runtime.isEmpty(lhsVal);\n\t\t\t\t\t} else if (operator === \"a\") {\n\t\t\t\t\t\treturn runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else if (operator === \"not a\") {\n\t\t\t\t\t\treturn !runtime.typeCheck(lhsVal, typeName.value, nullOk);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Unknown comparison : \" + operator;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"comparisonExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"comparisonOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"logicalOperator\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.parseElement(\"comparisonExpression\", tokens);\n\t\tvar logicalOp,\n\t\t\tinitialLogicalOp = null;\n\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\twhile (logicalOp) {\n\t\t\tinitialLogicalOp = initialLogicalOp || logicalOp;\n\t\t\tif (initialLogicalOp.value !== logicalOp.value) {\n\t\t\t\tparser.raiseParseError(tokens, \"You must parenthesize logical operations with different operators\");\n\t\t\t}\n\t\t\tvar rhs = parser.requireElement(\"comparisonExpression\", tokens);\n\t\t\tconst operator = logicalOp.value;\n\t\t\texpr = {\n\t\t\t\ttype: \"logicalOperator\",\n\t\t\t\toperator: operator,\n\t\t\t\tlhs: expr,\n\t\t\t\trhs: rhs,\n\t\t\t\targs: [expr, rhs],\n\t\t\t\top: function (context, lhsVal, rhsVal) {\n\t\t\t\t\tif (operator === \"and\") {\n\t\t\t\t\t\treturn lhsVal && rhsVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn lhsVal || rhsVal;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\tlogicalOp = tokens.matchToken(\"and\") || tokens.matchToken(\"or\");\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"logicalExpression\", function (parser, runtime, tokens) {\n\t\treturn parser.parseAnyOf([\"logicalOperator\", \"mathExpression\"], tokens);\n\t});\n\n\t_parser.addGrammarElement(\"asyncExpression\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"async\")) {\n\t\t\tvar value = parser.requireElement(\"logicalExpression\", tokens);\n\t\t\tvar expr = {\n\t\t\t\ttype: \"asyncExpression\",\n\t\t\t\tvalue: value,\n\t\t\t\tevaluate: function (context) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tasyncWrapper: true,\n\t\t\t\t\t\tvalue: this.value.evaluate(context), //OK\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn expr;\n\t\t} else {\n\t\t\treturn parser.parseElement(\"logicalExpression\", tokens);\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"expression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\t\treturn parser.parseElement(\"asyncExpression\", tokens);\n\t});\n\n\t_parser.addGrammarElement(\"assignableExpression\", function (parser, runtime, tokens) {\n\t\ttokens.matchToken(\"the\"); // optional the\n\n\t\t// TODO obviously we need to generalize this as a left hand side / targetable concept\n\t\tvar expr = parser.parseElement(\"primaryExpression\", tokens);\n\t\tif (expr && (\n\t\t\texpr.type === \"symbol\" ||\n\t\t\texpr.type === \"ofExpression\" ||\n\t\t\texpr.type === \"propertyAccess\" ||\n\t\t\texpr.type === \"attributeRefAccess\" ||\n\t\t\texpr.type === \"attributeRef\" ||\n\t\t\texpr.type === \"possessive\")\n\t\t) {\n\t\t\treturn expr;\n\t\t} else {\n\t\t\t_parser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"A target expression must be writable.  The expression type '\" + (expr && expr.type) + \"' is not.\"\n\t\t\t);\n\t\t}\n\t\treturn expr;\n\t});\n\n\t_parser.addGrammarElement(\"hyperscript\", function (parser, runtime, tokens) {\n\t\tvar features = [];\n\n\t\tif (tokens.hasMore()) {\n\t\t\twhile (parser.featureStart(tokens.currentToken()) || tokens.currentToken().value === \"(\") {\n\t\t\t\tvar feature = parser.requireElement(\"feature\", tokens);\n\t\t\t\tfeatures.push(feature);\n\t\t\t\ttokens.matchToken(\"end\"); // optional end\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\ttype: \"hyperscript\",\n\t\t\tfeatures: features,\n\t\t\tapply: function (target, source, args) {\n\t\t\t\t// no op\n\t\t\t\t_runtime.forEach(features, function (feature) {\n\t\t\t\t\tfeature.install(target, source, args);\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t});\n\n\tvar parseEventArgs = function (tokens) {\n\t\tvar args = [];\n\t\t// handle argument list (look ahead 3)\n\t\tif (\n\t\t\ttokens.token(0).value === \"(\" &&\n\t\t\t(tokens.token(1).value === \")\" || tokens.token(2).value === \",\" || tokens.token(2).value === \")\")\n\t\t) {\n\t\t\ttokens.matchOpToken(\"(\");\n\t\t\tdo {\n\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\treturn args;\n\t};\n\n\t_parser.addFeature(\"on\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"on\")) return;\n\t\tvar every = false;\n\t\tif (tokens.matchToken(\"every\")) {\n\t\t\tevery = true;\n\t\t}\n\t\tvar events = [];\n\t\tvar displayName = null;\n\t\tdo {\n\t\t\tvar on = parser.requireElement(\"eventName\", tokens, \"Expected event name\");\n\n\t\t\tvar eventName = on.evaluate(); // OK No Promise\n\n\t\t\tif (displayName) {\n\t\t\t\tdisplayName = displayName + \" or \" + eventName;\n\t\t\t} else {\n\t\t\t\tdisplayName = \"on \" + eventName;\n\t\t\t}\n\t\t\tvar args = parseEventArgs(tokens);\n\n\t\t\tvar filter = null;\n\t\t\tif (tokens.matchOpToken(\"[\")) {\n\t\t\t\tfilter = parser.requireElement(\"expression\", tokens);\n\t\t\t\ttokens.requireOpToken(\"]\");\n\t\t\t}\n\n\t\t\tif (tokens.currentToken().type === \"NUMBER\") {\n\t\t\t\tvar startCountToken = tokens.consumeToken();\n\t\t\t\tvar startCount = parseInt(startCountToken.value);\n\t\t\t\tif (tokens.matchToken(\"to\")) {\n\t\t\t\t\tvar endCountToken = tokens.consumeToken();\n\t\t\t\t\tvar endCount = parseInt(endCountToken.value);\n\t\t\t\t} else if (tokens.matchToken(\"and\")) {\n\t\t\t\t\tvar unbounded = true;\n\t\t\t\t\ttokens.requireToken(\"on\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eventName === \"intersection\") {\n\t\t\t\tvar intersectionSpec = {};\n\t\t\t\tif (tokens.matchToken(\"with\")) {\n\t\t\t\t\tintersectionSpec[\"with\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t}\n\t\t\t\tif (tokens.matchToken(\"having\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"margin\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"rootMargin\"] = parser.requireElement(\"stringLike\", tokens).evaluate();\n\t\t\t\t\t\t} else if (tokens.matchToken(\"threshold\")) {\n\t\t\t\t\t\t\tintersectionSpec[\"threshold\"] = parser.requireElement(\"expression\", tokens).evaluate();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown intersection config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"and\"));\n\t\t\t\t}\n\t\t\t} else if (eventName === \"mutation\") {\n\t\t\t\tvar mutationSpec = {};\n\t\t\t\tif (tokens.matchToken(\"of\")) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (tokens.matchToken(\"anything\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"childList\")) {\n\t\t\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"attributes\")) {\n\t\t\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"attributeOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"subtree\")) {\n\t\t\t\t\t\t\tmutationSpec[\"subtree\"] = true;\n\t\t\t\t\t\t} else if (tokens.matchToken(\"characterData\")) {\n\t\t\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\t\t\tmutationSpec[\"characterDataOldValue\"] = true;\n\t\t\t\t\t\t} else if (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\t\t\t\t\tvar attribute = tokens.consumeToken();\n\t\t\t\t\t\t\tif (mutationSpec[\"attributeFilter\"] == null) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (attribute.value.indexOf(\"@\") == 0) {\n\t\t\t\t\t\t\t\tmutationSpec[\"attributeFilter\"].push(attribute.value.substring(1));\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\t\t\t\"Only shorthand attribute references are allowed here\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tparser.raiseParseError(tokens, \"Unknown mutation config specification\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (tokens.matchToken(\"or\"));\n\t\t\t\t} else {\n\t\t\t\t\tmutationSpec[\"attributes\"] = true;\n\t\t\t\t\tmutationSpec[\"characterData\"] = true;\n\t\t\t\t\tmutationSpec[\"childList\"] = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar from = null;\n\t\t\tvar elsewhere = false;\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tif (tokens.matchToken(\"elsewhere\")) {\n\t\t\t\t\telsewhere = true;\n\t\t\t\t} else {\n\t\t\t\t\tfrom = parser.parseElement(\"expression\", tokens);\n\t\t\t\t\tif (!from) {\n\t\t\t\t\t\tparser.raiseParseError(tokens, 'Expected either target value or \"elsewhere\".');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// support both \"elsewhere\" and \"from elsewhere\"\n\t\t\tif (from === null && elsewhere === false && tokens.matchToken(\"elsewhere\")) {\n\t\t\t\telsewhere = true;\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\tvar inExpr = parser.parseAnyOf([\"idRef\", \"queryRef\", \"classRef\"], tokens);\n\t\t\t}\n\n\t\t\tif (tokens.matchToken(\"debounced\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"timeExpression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar debounceTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t} else if (tokens.matchToken(\"throttled\")) {\n\t\t\t\ttokens.requireToken(\"at\");\n\t\t\t\tvar timeExpr = parser.requireElement(\"timeExpression\", tokens);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvar throttleTime = timeExpr.evaluate({}); // OK No promise TODO make a literal time expr\n\t\t\t}\n\n\t\t\tevents.push({\n\t\t\t\texecCount: 0,\n\t\t\t\tevery: every,\n\t\t\t\ton: eventName,\n\t\t\t\targs: args,\n\t\t\t\tfilter: filter,\n\t\t\t\tfrom: from,\n\t\t\t\tinExpr: inExpr,\n\t\t\t\telsewhere: elsewhere,\n\t\t\t\tstartCount: startCount,\n\t\t\t\tendCount: endCount,\n\t\t\t\tunbounded: unbounded,\n\t\t\t\tdebounceTime: debounceTime,\n\t\t\t\tthrottleTime: throttleTime,\n\t\t\t\tmutationSpec: mutationSpec,\n\t\t\t\tintersectionSpec: intersectionSpec,\n\t\t\t});\n\t\t} while (tokens.matchToken(\"or\"));\n\n\t\tvar queue = [];\n\t\tvar queueLast = true;\n\t\tif (!every) {\n\t\t\tif (tokens.matchToken(\"queue\")) {\n\t\t\t\tif (tokens.matchToken(\"all\")) {\n\t\t\t\t\tvar queueAll = true;\n\t\t\t\t\tvar queueLast = false;\n\t\t\t\t} else if (tokens.matchToken(\"first\")) {\n\t\t\t\t\tvar queueFirst = true;\n\t\t\t\t} else if (tokens.matchToken(\"none\")) {\n\t\t\t\t\tvar queueNone = true;\n\t\t\t\t} else {\n\t\t\t\t\ttokens.requireToken(\"last\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar commandList = parser.parseElement(\"commandList\", tokens);\n\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\t// automatically resolve at the end of an event handler if nothing else does\n\t\t\t\tcontext.meta.resolve();\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (ctx) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\n\t\tif (commandList) {\n\t\t\t/** @type {GrammarElement} */\n\t\t\tvar start = commandList;\n\t\t\t\n\t\t\tvar end = start;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t} else {\n\t\t\tstart = implicitReturn;\n\t\t}\n\n\t\tvar onFeature = {\n\t\t\tdisplayName: displayName,\n\t\t\tevents: events,\n\t\t\tstart: start,\n\t\t\tevery: every,\n\t\t\texecuting: false,\n\t\t\texecCount: 0,\n\t\t\tqueue: queue,\n\t\t\texecute: function (/** @type {Context} */ ctx) {\n\t\t\t\tif (this.executing && every === false) {\n\t\t\t\t\tif (queueNone || (queueFirst && queue.length > 0)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (queueLast) {\n\t\t\t\t\t\tonFeature.queue.length = 0;\n\t\t\t\t\t}\n\t\t\t\t\tonFeature.queue.push(ctx);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tonFeature.execCount++;\n\t\t\t\tthis.executing = true;\n\t\t\t\tctx.meta.resolve = function () {\n\t\t\t\t\tonFeature.executing = false;\n\t\t\t\t\tvar queued = onFeature.queue.shift();\n\t\t\t\t\tif (queued) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tonFeature.execute(queued);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tctx.meta.reject = function (err) {\n\t\t\t\t\tconsole.error(err.message ? err.message : err);\n\t\t\t\t\tvar hypertrace = runtime.getHyperTrace(ctx, err);\n\t\t\t\t\tif (hypertrace) {\n\t\t\t\t\t\thypertrace.print();\n\t\t\t\t\t}\n\t\t\t\t\truntime.triggerEvent(ctx.me, \"exception\", {\n\t\t\t\t\t\terror: err,\n\t\t\t\t\t});\n\t\t\t\t\tonFeature.executing = false;\n\t\t\t\t\tvar queued = onFeature.queue.shift();\n\t\t\t\t\tif (queued) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tonFeature.execute(queued);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tstart.execute(ctx);\n\t\t\t},\n\t\t\tinstall: function (elt, source) {\n\t\t\t\truntime.forEach(onFeature.events, function (eventSpec) {\n\t\t\t\t\tvar targets;\n\t\t\t\t\tif (eventSpec.elsewhere) {\n\t\t\t\t\t\ttargets = [document];\n\t\t\t\t\t} else if (eventSpec.from) {\n\t\t\t\t\t\ttargets = eventSpec.from.evaluate({\n\t\t\t\t\t\t\tme: elt,\n\t\t\t\t\t\t\tmeta: { owner: elt, feature: onFeature },\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttargets = [elt];\n\t\t\t\t\t}\n\t\t\t\t\truntime.forEach(targets, function (target) {\n\t\t\t\t\t\t// OK NO PROMISE\n\n\t\t\t\t\t\tvar eventName = eventSpec.on;\n\t\t\t\t\t\tif (eventSpec.mutationSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:mutation\";\n\t\t\t\t\t\t\tconst observer = new MutationObserver(function (mutationList, observer) {\n\t\t\t\t\t\t\t\tconsole.log(target, mutationList);\n\t\t\t\t\t\t\t\tif (!onFeature.executing) {\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, {\n\t\t\t\t\t\t\t\t\t\tmutationList: mutationList,\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tobserver.observe(target, eventSpec.mutationSpec);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (eventSpec.intersectionSpec) {\n\t\t\t\t\t\t\teventName = \"hyperscript:insersection\";\n\t\t\t\t\t\t\tconst observer = new IntersectionObserver(function (entries) {\n\t\t\t\t\t\t\t\t_runtime.forEach(entries, function (entry) {\n\t\t\t\t\t\t\t\t\tvar detail = {\n\t\t\t\t\t\t\t\t\t\tobserver: observer,\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tdetail = mergeObjects(detail, entry);\n\t\t\t\t\t\t\t\t\tdetail[\"intersecting\"] = entry.isIntersecting;\n\t\t\t\t\t\t\t\t\t_runtime.triggerEvent(target, eventName, detail);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, eventSpec.intersectionSpec);\n\t\t\t\t\t\t\tobserver.observe(target);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar addEventListener = target.addEventListener || target.on;\n\t\t\t\t\t\taddEventListener.call(target, eventName, function listener(evt) {\n\t\t\t\t\t\t\t// OK NO PROMISE\n\t\t\t\t\t\t\tif (typeof Node !== 'undefined' && elt instanceof Node && target !== elt && !elt.isConnected) {\n\t\t\t\t\t\t\t\ttarget.removeEventListener(eventName, listener);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar ctx = runtime.makeContext(elt, onFeature, elt, evt);\n\t\t\t\t\t\t\tif (eventSpec.elsewhere && elt.contains(evt.target)) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (eventSpec.from) {\n\t\t\t\t\t\t\t\tctx.result = target;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// establish context\n\t\t\t\t\t\t\truntime.forEach(eventSpec.args, function (arg) {\n\t\t\t\t\t\t\t\tctx[arg.value] =\n\t\t\t\t\t\t\t\t\tctx.event[arg.value] || ('detail' in ctx.event ? ctx.event['detail'][arg.value] : null);\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t// apply filter\n\t\t\t\t\t\t\tif (eventSpec.filter) {\n\t\t\t\t\t\t\t\tvar initialCtx = ctx.meta.context;\n\t\t\t\t\t\t\t\tctx.meta.context = ctx.event;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tvar value = eventSpec.filter.evaluate(ctx); //OK NO PROMISE\n\t\t\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\t\t\t// match the javascript semantics for if statements\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\tctx.meta.context = initialCtx;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (eventSpec.inExpr) {\n\t\t\t\t\t\t\t\tvar inElement = evt.target;\n\t\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\t\tif (inElement.matches && inElement.matches(eventSpec.inExpr.css)) {\n\t\t\t\t\t\t\t\t\t\tctx.result = inElement;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tinElement = inElement.parentElement;\n\t\t\t\t\t\t\t\t\t\tif (inElement == null) {\n\t\t\t\t\t\t\t\t\t\t\treturn; // no match found\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// verify counts\n\t\t\t\t\t\t\teventSpec.execCount++;\n\t\t\t\t\t\t\tif (eventSpec.startCount) {\n\t\t\t\t\t\t\t\tif (eventSpec.endCount) {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount < eventSpec.startCount ||\n\t\t\t\t\t\t\t\t\t\teventSpec.execCount > eventSpec.endCount\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.unbounded) {\n\t\t\t\t\t\t\t\t\tif (eventSpec.execCount < eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (eventSpec.execCount !== eventSpec.startCount) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t//debounce\n\t\t\t\t\t\t\tif (eventSpec.debounceTime) {\n\t\t\t\t\t\t\t\tif (eventSpec.debounced) {\n\t\t\t\t\t\t\t\t\tclearTimeout(eventSpec.debounced);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\teventSpec.debounced = setTimeout(function () {\n\t\t\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t\t\t}, eventSpec.debounceTime);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// throttle\n\t\t\t\t\t\t\tif (eventSpec.throttleTime) {\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\teventSpec.lastExec &&\n\t\t\t\t\t\t\t\t\tDate.now() < eventSpec.lastExec + eventSpec.throttleTime\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\teventSpec.lastExec = Date.now();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// apply execute\n\t\t\t\t\t\t\tonFeature.execute(ctx);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t\tparser.setParent(start, onFeature);\n\t\treturn onFeature;\n\t});\n\n\t_parser.addFeature(\"def\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"def\")) return;\n\t\tvar functionName = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\tvar nameVal = functionName.evaluate(); // OK\n\t\tvar nameSpace = nameVal.split(\".\");\n\t\tvar funcName = nameSpace.pop();\n\n\t\tvar args = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// emtpy args list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\targs.push(tokens.requireTokenType(\"IDENTIFIER\"));\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar start = parser.requireElement(\"commandList\", tokens);\n\t\tif (tokens.matchToken(\"catch\")) {\n\t\t\tvar errorSymbol = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t\tvar errorHandler = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\t\tvar functionFeature = {\n\t\t\tdisplayName:\n\t\t\t\tfuncName +\n\t\t\t\t\"(\" +\n\t\t\t\targs\n\t\t\t\t\t.map(function (arg) {\n\t\t\t\t\t\treturn arg.value;\n\t\t\t\t\t})\n\t\t\t\t\t.join(\", \") +\n\t\t\t\t\")\",\n\t\t\tname: funcName,\n\t\t\targs: args,\n\t\t\tstart: start,\n\t\t\terrorHandler: errorHandler,\n\t\t\terrorSymbol: errorSymbol,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tvar func = function () {\n\t\t\t\t\t// null, worker\n\t\t\t\t\tvar ctx = runtime.makeContext(source, functionFeature, target, null);\n\n\t\t\t\t\t// install error handler if any\n\t\t\t\t\tctx.meta.errorHandler = errorHandler;\n\t\t\t\t\tctx.meta.errorSymmbol = errorSymbol;\n\n\t\t\t\t\tfor (var i = 0; i < args.length; i++) {\n\t\t\t\t\t\tvar name = args[i];\n\t\t\t\t\t\tvar argumentVal = arguments[i];\n\t\t\t\t\t\tif (name) {\n\t\t\t\t\t\t\tctx[name.value] = argumentVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tctx.meta.caller = arguments[args.length];\n\t\t\t\t\tif (ctx.meta.caller) {\n\t\t\t\t\t\tctx.meta.callingCommand = ctx.meta.caller.meta.command;\n\t\t\t\t\t}\n\t\t\t\t\tvar resolve,\n\t\t\t\t\t\treject = null;\n\t\t\t\t\tvar promise = new Promise(function (theResolve, theReject) {\n\t\t\t\t\t\tresolve = theResolve;\n\t\t\t\t\t\treject = theReject;\n\t\t\t\t\t});\n\t\t\t\t\tstart.execute(ctx);\n\t\t\t\t\tif (ctx.meta.returned) {\n\t\t\t\t\t\treturn ctx.meta.returnValue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tctx.meta.resolve = resolve;\n\t\t\t\t\t\tctx.meta.reject = reject;\n\t\t\t\t\t\treturn promise;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tfunc.hyperfunc = true;\n\t\t\t\tfunc.hypername = nameVal;\n\t\t\t\truntime.assignToNamespace(target, nameSpace, funcName, func);\n\t\t\t},\n\t\t};\n\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\t// automatically return at the end of the function if nothing else does\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tif (context.meta.resolve) {\n\t\t\t\t\tcontext.meta.resolve();\n\t\t\t\t}\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\t\t// terminate body\n\t\tif (start) {\n\t\t\tvar end = start;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t} else {\n\t\t\tfunctionFeature.start = implicitReturn;\n\t\t}\n\n\t\t// terminate error handler\n\t\tif (errorHandler) {\n\t\t\tvar end = errorHandler;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t}\n\n\t\tparser.setParent(start, functionFeature);\n\t\treturn functionFeature;\n\t});\n\n\t_parser.addFeature(\"init\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"init\")) return;\n\t\tvar immediately = tokens.matchToken('immediately');\n\n\t\tvar start = parser.parseElement(\"commandList\", tokens);\n\t\tvar initFeature = {\n\t\t\tstart: start,\n\t\t\tinstall: function (target, source) {\n\t\t\t\tif (immediately) {\n\t\t\t\t\tstart && start.execute(runtime.makeContext(target, this, target, null));\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\tstart && start.execute(runtime.makeContext(target, this, target, null));\n\t\t\t\t\t}, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\tvar implicitReturn = {\n\t\t\ttype: \"implicitReturn\",\n\t\t\top: function (context) {\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\t// do nothing\n\t\t\t},\n\t\t};\n\t\t// terminate body\n\t\tif (start) {\n\t\t\tvar end = start;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t} else {\n\t\t\tinitFeature.start = implicitReturn;\n\t\t}\n\t\tparser.setParent(start, initFeature);\n\t\treturn initFeature;\n\t});\n\n\t_parser.addFeature(\"worker\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"worker\")) {\n\t\t\tparser.raiseParseError(\n\t\t\t\ttokens,\n\t\t\t\t\"In order to use the 'worker' feature, include \" +\n\t\t\t\t\t\"the _hyperscript worker plugin. See \" +\n\t\t\t\t\t\"https://hyperscript.org/features/worker/ for \" +\n\t\t\t\t\t\"more info.\"\n\t\t\t);\n\t\t}\n\t});\n\n\t_parser.addFeature(\"behavior\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"behavior\")) return;\n\t\tvar path = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar nameSpace = path.split(\".\");\n\t\tvar name = nameSpace.pop();\n\n\t\tvar formalParams = [];\n\t\tif (tokens.matchOpToken(\"(\") && !tokens.matchOpToken(\")\")) {\n\t\t\tdo {\n\t\t\t\tformalParams.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\ttokens.requireOpToken(\")\");\n\t\t}\n\t\tvar hs = parser.requireElement(\"hyperscript\", tokens);\n\t\tfor (var i = 0; i < hs.features.length; i++) {\n\t\t\tvar feature = hs.features[i];\n\t\t\tfeature.behavior = path;\n\t\t}\n\n\t\treturn {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.assignToNamespace(\n\t\t\t\t\tglobalScope.document && globalScope.document.body,\n\t\t\t\t\tnameSpace,\n\t\t\t\t\tname,\n\t\t\t\t\tfunction (target, source, innerArgs) {\n\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\tvar elementScope = getOrInitObject(internalData, path + \"Scope\");\n\t\t\t\t\t\tfor (var i = 0; i < formalParams.length; i++) {\n\t\t\t\t\t\t\telementScope[formalParams[i]] = innerArgs[formalParams[i]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\ths.apply(target, source);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addFeature(\"install\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"install\")) return;\n\t\tvar behaviorPath = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar behaviorNamespace = behaviorPath.split(\".\");\n\t\tvar args = parser.parseElement(\"namedArgumentList\", tokens);\n\n\t\tvar installFeature;\n\t\treturn (installFeature = {\n\t\t\tinstall: function (target, source) {\n\t\t\t\truntime.unifiedEval(\n\t\t\t\t\t{\n\t\t\t\t\t\targs: [args],\n\t\t\t\t\t\top: function (ctx, args) {\n\t\t\t\t\t\t\tvar behavior = globalScope;\n\t\t\t\t\t\t\tfor (var i = 0; i < behaviorNamespace.length; i++) {\n\t\t\t\t\t\t\t\tbehavior = behavior[behaviorNamespace[i]];\n\t\t\t\t\t\t\t\tif (typeof behavior !== \"object\" && typeof behavior !== \"function\")\n\t\t\t\t\t\t\t\t\tthrow new Error(\"No such behavior defined as \" + behaviorPath);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!(behavior instanceof Function))\n\t\t\t\t\t\t\t\tthrow new Error(behaviorPath + \" is not a behavior\");\n\n\t\t\t\t\t\t\tbehavior(target, source, args);\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\truntime.makeContext(target, installFeature, target)\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t});\n\n\t_parser.addGrammarElement(\"jsBody\", function (parser, runtime, tokens) {\n\t\tvar jsSourceStart = tokens.currentToken().start;\n\t\tvar jsLastToken = tokens.currentToken();\n\n\t\tvar funcNames = [];\n\t\tvar funcName = \"\";\n\t\tvar expectFunctionDeclaration = false;\n\t\twhile (tokens.hasMore()) {\n\t\t\tjsLastToken = tokens.consumeToken();\n\t\t\tvar peek = tokens.token(0, true);\n\t\t\tif (peek.type === \"IDENTIFIER\" && peek.value === \"end\") {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (expectFunctionDeclaration) {\n\t\t\t\tif (jsLastToken.type === \"IDENTIFIER\" || jsLastToken.type === \"NUMBER\") {\n\t\t\t\t\tfuncName += jsLastToken.value;\n\t\t\t\t} else {\n\t\t\t\t\tif (funcName !== \"\") funcNames.push(funcName);\n\t\t\t\t\tfuncName = \"\";\n\t\t\t\t\texpectFunctionDeclaration = false;\n\t\t\t\t}\n\t\t\t} else if (jsLastToken.type === \"IDENTIFIER\" && jsLastToken.value === \"function\") {\n\t\t\t\texpectFunctionDeclaration = true;\n\t\t\t}\n\t\t}\n\t\tvar jsSourceEnd = jsLastToken.end + 1;\n\n\t\treturn {\n\t\t\ttype: \"jsBody\",\n\t\t\texposedFunctionNames: funcNames,\n\t\t\tjsSource: tokens.source.substring(jsSourceStart, jsSourceEnd),\n\t\t};\n\t});\n\n\t_parser.addFeature(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\n\t\tvar jsSource =\n\t\t\tjsBody.jsSource +\n\t\t\t\"\\nreturn { \" +\n\t\t\tjsBody.exposedFunctionNames\n\t\t\t\t.map(function (name) {\n\t\t\t\t\treturn name + \":\" + name;\n\t\t\t\t})\n\t\t\t\t.join(\",\") +\n\t\t\t\" } \";\n\t\tvar func = new Function(jsSource);\n\n\t\treturn {\n\t\t\tjsSource: jsSource,\n\t\t\tfunction: func,\n\t\t\texposedFunctionNames: jsBody.exposedFunctionNames,\n\t\t\tinstall: function () {\n\t\t\t\tmergeObjects(globalScope, func());\n\t\t\t},\n\t\t};\n\t});\n\n\t_parser.addCommand(\"js\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"js\")) return;\n\t\t// Parse inputs\n\t\tvar inputs = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// empty input list\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tvar inp = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\t\t\tinputs.push(inp.value);\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\tvar jsBody = parser.requireElement(\"jsBody\", tokens);\n\t\ttokens.matchToken(\"end\");\n\n\t\tvar func = varargConstructor(Function, inputs.concat([jsBody.jsSource]));\n\n\t\tvar command = {\n\t\t\tjsSource: jsBody.jsSource,\n\t\t\tfunction: func,\n\t\t\tinputs: inputs,\n\t\t\top: function (context) {\n\t\t\t\tvar args = [];\n\t\t\t\tinputs.forEach(function (input) {\n\t\t\t\t\targs.push(runtime.resolveSymbol(input, context, 'default'));\n\t\t\t\t});\n\t\t\t\tvar result = func.apply(globalScope, args);\n\t\t\t\tif (result && typeof result.then === \"function\") {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tresult.then(function (actualResult) {\n\t\t\t\t\t\t\tcontext.result = actualResult;\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcontext.result = result;\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"async\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"async\")) return;\n\t\tif (tokens.matchToken(\"do\")) {\n\t\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\n\t\t\t// Append halt\n\t\t\tvar end = body;\n\t\t\twhile (end.next) end = end.next;\n\t\t\tend.next = runtime.HALT;\n\n\t\t\ttokens.requireToken(\"end\");\n\t\t} else {\n\t\t\tvar body = parser.requireElement(\"command\", tokens);\n\t\t}\n\t\tvar command = {\n\t\t\tbody: body,\n\t\t\top: function (context) {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tbody.execute(context);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"tell\", function (parser, runtime, tokens) {\n\t\tvar startToken = tokens.currentToken();\n\t\tif (!tokens.matchToken(\"tell\")) return;\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\tvar body = parser.requireElement(\"commandList\", tokens);\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\t\tvar slot = \"tell_\" + startToken.start;\n\t\tvar tellCmd = {\n\t\t\tvalue: value,\n\t\t\tbody: body,\n\t\t\targs: [value],\n\t\t\tresolveNext: function (context) {\n\t\t\t\tvar iterator = context.meta.iterators[slot];\n\t\t\t\tif (iterator.index < iterator.value.length) {\n\t\t\t\t\tcontext.beingTold = iterator.value[iterator.index++];\n\t\t\t\t\treturn body;\n\t\t\t\t} else {\n\t\t\t\t\t// restore original me\n\t\t\t\t\tcontext.beingTold = iterator.originalBeingTold;\n\t\t\t\t\tif (this.next) {\n\t\t\t\t\t\treturn this.next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\top: function (context, value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\tvalue = [];\n\t\t\t\t} else if (!(Array.isArray(value) || value instanceof NodeList)) {\n\t\t\t\t\tvalue = [value];\n\t\t\t\t}\n\t\t\t\tcontext.meta.iterators[slot] = {\n\t\t\t\t\toriginalBeingTold: context.beingTold,\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t};\n\t\t\t\treturn this.resolveNext(context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(body, tellCmd);\n\t\treturn tellCmd;\n\t});\n\n\t_parser.addCommand(\"wait\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"wait\")) return;\n\t\tvar command;\n\t\t\n\t\t// wait on event\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\ttokens.matchToken(\"a\"); // optional \"a\"\n\t\t\tvar events = [];\n\t\t\tdo {\n\t\t\t\tvar lookahead = tokens.token(0);\n\t\t\t\tif (lookahead.type === 'NUMBER' || lookahead.type === 'L_PAREN') {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\ttime: parser.requireElement('timeExpression', tokens).evaluate() // TODO: do we want to allow async here?\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tevents.push({\n\t\t\t\t\t\tname: _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\").evaluate(),\n\t\t\t\t\t\targs: parseEventArgs(tokens),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} while (tokens.matchToken(\"or\"));\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\n\t\t\t// wait on event\n\t\t\tcommand = {\n\t\t\t\tevent: events,\n\t\t\t\ton: on,\n\t\t\t\targs: [on],\n\t\t\t\top: function (context, on) {\n\t\t\t\t\tvar target = on ? on : context.me;\n\t\t\t\t\tif (!(target instanceof EventTarget))\n\t\t\t\t\t\tthrow new Error(\"Not a valid event target: \" + this.on.sourceFor());\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tvar resolved = false;\n\t\t\t\t\t\truntime.forEach(events, (eventInfo) => {\n\t\t\t\t\t\t\tvar listener = (event) => {\n\t\t\t\t\t\t\t\tcontext.result = event;\n\t\t\t\t\t\t\t\truntime.forEach(eventInfo.args, (arg) => {\n\t\t\t\t\t\t\t\t\tcontext[arg.value] =\n\t\t\t\t\t\t\t\t\t\tevent[arg.value] || (event.detail ? event.detail[arg.value] : null);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\t\t\tresolved = true;\n\t\t\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (eventInfo.name) target.addEventListener(eventInfo.name, listener, { once: true });\n\t\t\t\t\t\t\telse if (eventInfo.time) setTimeout(listener, eventInfo.time, eventInfo.time)\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tvar time;\n\t\t\tif (tokens.matchToken(\"a\")) {\n\t\t\t\ttokens.requireToken(\"tick\");\n\t\t\t\ttime = 0;\n\t\t\t} else {\n\t\t\t\ttime = _parser.requireElement(\"timeExpression\", tokens);\n\t\t\t}\n\n\t\t\tcommand = {\n\t\t\t\ttype: \"waitCmd\",\n\t\t\t\ttime: time,\n\t\t\t\targs: [time],\n\t\t\t\top: function (context, timeValue) {\n\t\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\tresolve(runtime.findNext(this, context));\n\t\t\t\t\t\t}, timeValue);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t// TODO  - colon path needs to eventually become part of ruby-style symbols\n\t_parser.addGrammarElement(\"dotOrColonPath\", function (parser, runtime, tokens) {\n\t\tvar root = tokens.matchTokenType(\"IDENTIFIER\");\n\t\tif (root) {\n\t\t\tvar path = [root.value];\n\n\t\t\tvar separator = tokens.matchOpToken(\".\") || tokens.matchOpToken(\":\");\n\t\t\tif (separator) {\n\t\t\t\tdo {\n\t\t\t\t\tpath.push(tokens.requireTokenType(\"IDENTIFIER\").value);\n\t\t\t\t} while (tokens.matchOpToken(separator.value));\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype: \"dotOrColonPath\",\n\t\t\t\tpath: path,\n\t\t\t\tevaluate: function () {\n\t\t\t\t\treturn path.join(separator ? separator.value : \"\");\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"eventName\", function (parser, runtime, tokens) {\n\t\tvar token;\n\t\tif ((token = tokens.matchTokenType(\"STRING\"))) {\n\t\t\treturn {\n\t\t\t\tevaluate: function() {\n\t\t\t\t\treturn token.value;\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\treturn parser.parseElement(\"dotOrColonPath\", tokens);\n\t});\n\n\t_parser.addCommand(\"send\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"send\")) return;\n\t\tvar eventName = parser.requireElement(\"eventName\", tokens);\n\n\t\tvar details = parser.parseElement(\"namedArgumentList\", tokens);\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\tvar to = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar to = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar sendCmd = {\n\t\t\teventName: eventName,\n\t\t\tdetails: details,\n\t\t\tto: to,\n\t\t\targs: [to, eventName, details],\n\t\t\top: function (context, to, eventName, details) {\n\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\truntime.triggerEvent(target, eventName, details ? details : {});\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(sendCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn sendCmd;\n\t});\n\n\tvar parseReturnFunction = function (parser, runtime, tokens, returnAValue) {\n\t\tif (returnAValue) {\n\t\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar returnCmd = {\n\t\t\tvalue: value,\n\t\t\targs: [value],\n\t\t\top: function (context, value) {\n\t\t\t\tvar resolve = context.meta.resolve;\n\t\t\t\tcontext.meta.returned = true;\n\t\t\t\tif (resolve) {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tresolve(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext.meta.returned = true;\n\t\t\t\t\tcontext.meta.returnValue = value;\n\t\t\t\t}\n\t\t\t\treturn runtime.HALT;\n\t\t\t},\n\t\t};\n\t\treturn returnCmd;\n\t};\n\n\t_parser.addCommand(\"return\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"return\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, true);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"exit\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"exit\")) {\n\t\t\treturn parseReturnFunction(parser, runtime, tokens, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"halt\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"halt\")) {\n\t\t\tif (tokens.matchToken(\"the\")) {\n\t\t\t\ttokens.requireToken(\"event\");\n\t\t\t\t// optional possessive\n\t\t\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\t\t\ttokens.requireToken(\"s\");\n\t\t\t\t}\n\t\t\t\tvar keepExecuting = true;\n\t\t\t}\n\t\t\tif (tokens.matchToken(\"bubbling\")) {\n\t\t\t\tvar bubbling = true;\n\t\t\t} else if (tokens.matchToken(\"default\")) {\n\t\t\t\tvar haltDefault = true;\n\t\t\t}\n\t\t\tvar exit = parseReturnFunction(parser, runtime, tokens, false);\n\n\t\t\tvar haltCmd = {\n\t\t\t\tkeepExecuting: true,\n\t\t\t\tbubbling: bubbling,\n\t\t\t\thaltDefault: haltDefault,\n\t\t\t\texit: exit,\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tif (ctx.event) {\n\t\t\t\t\t\tif (bubbling) {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t} else if (haltDefault) {\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tctx.event.stopPropagation();\n\t\t\t\t\t\t\tctx.event.preventDefault();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (keepExecuting) {\n\t\t\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn haltCmd;\n\t\t}\n\t});\n\n\t_parser.addCommand(\"log\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"log\")) return;\n\t\tvar exprs = [parser.parseElement(\"expression\", tokens)];\n\t\twhile (tokens.matchOpToken(\",\")) {\n\t\t\texprs.push(parser.requireElement(\"expression\", tokens));\n\t\t}\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tvar withExpr = parser.requireElement(\"expression\", tokens);\n\t\t}\n\t\tvar logCmd = {\n\t\t\texprs: exprs,\n\t\t\twithExpr: withExpr,\n\t\t\targs: [withExpr, exprs],\n\t\t\top: function (ctx, withExpr, values) {\n\t\t\t\tif (withExpr) {\n\t\t\t\t\twithExpr.apply(null, values);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log.apply(null, values);\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t\treturn logCmd;\n\t});\n\n\t_parser.addCommand(\"throw\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"throw\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar throwCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (ctx, expr) {\n\t\t\t\truntime.registerHyperTrace(ctx, expr);\n\t\t\t\tvar reject = ctx.meta && ctx.meta.reject;\n\t\t\t\tif (reject) {\n\t\t\t\t\treject(expr);\n\t\t\t\t\treturn runtime.HALT;\n\t\t\t\t} else {\n\t\t\t\t\tthrow expr;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn throwCmd;\n\t});\n\n\tvar parseCallOrGet = function (parser, runtime, tokens) {\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\tvar callCmd = {\n\t\t\texpr: expr,\n\t\t\targs: [expr],\n\t\t\top: function (context, result) {\n\t\t\t\tcontext.result = result;\n\t\t\t\treturn runtime.findNext(callCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn callCmd;\n\t};\n\t_parser.addCommand(\"call\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"call\")) return;\n\t\tvar call = parseCallOrGet(parser, runtime, tokens);\n\t\tif (call.expr && call.expr.type !== \"functionCall\") {\n\t\t\tparser.raiseParseError(tokens, \"Must be a function invocation\");\n\t\t}\n\t\treturn call;\n\t});\n\t_parser.addCommand(\"get\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"get\")) {\n\t\t\treturn parseCallOrGet(parser, runtime, tokens);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"make\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"make\")) return;\n\t\ttokens.matchToken(\"a\") || tokens.matchToken(\"an\");\n\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\n\t\tvar args = [];\n\t\tif (expr.type !== \"queryRef\" && tokens.matchToken(\"from\")) {\n\t\t\tdo {\n\t\t\t\targs.push(parser.requireElement(\"expression\", tokens));\n\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t}\n\n\t\tif (tokens.matchToken(\"called\")) {\n\t\t\tvar name = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t}\n\n\t\tvar command;\n\t\tif (expr.type === \"queryRef\") {\n\t\t\tcommand = {\n\t\t\t\top: function (ctx) {\n\t\t\t\t\tvar match,\n\t\t\t\t\t\ttagname = \"div\",\n\t\t\t\t\t\tid,\n\t\t\t\t\t\tclasses = [];\n\t\t\t\t\tvar re = /(?:(^|#|\\.)([^#\\. ]+))/g;\n\t\t\t\t\twhile ((match = re.exec(expr.css))) {\n\t\t\t\t\t\tif (match[1] === \"\") tagname = match[2].trim();\n\t\t\t\t\t\telse if (match[1] === \"#\") id = match[2].trim();\n\t\t\t\t\t\telse classes.push(match[2].trim());\n\t\t\t\t\t}\n\n\t\t\t\t\tvar result = document.createElement(tagname);\n\t\t\t\t\tif (id !== undefined) result.id = id;\n\t\t\t\t\tfor (var i = 0; i < classes.length; i++) {\n\t\t\t\t\t\tvar cls = classes[i];\n\t\t\t\t\t\tresult.classList.add(cls)\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.result = result;\n\t\t\t\t\tif (name) ctx[name] = result;\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t} else {\n\t\t\tcommand = {\n\t\t\t\targs: [expr, args],\n\t\t\t\top: function (ctx, expr, args) {\n\t\t\t\t\tctx.result = varargConstructor(expr, args);\n\t\t\t\t\tif (name) ctx[name] = ctx.result;\n\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"pseudoCommand\", function (parser, runtime, tokens) {\n\t\tvar expr = parser.requireElement(\"primaryExpression\", tokens);\n\t\tif (expr.type !== \"functionCall\" && expr.root.type !== \"symbol\") {\n\t\t\tparser.raiseParseError(tokens, \"Implicit function calls must start with a simple function\");\n\t\t}\n\t\t// optional \"on\", \"with\", or \"to\"\n\t\tif (!tokens.matchAnyToken(\"to\", \"on\", \"with\", \"into\", \"from\", \"at\") && parser.commandBoundary(tokens.currentToken())) {\n\t\t\tvar target = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t} else {\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\t}\n\t\tvar functionName = expr.root.name;\n\t\tvar functionArgs = expr.argExressions;\n\n\t\t/** @type {GrammarElement} */\n\t\tvar pseudoCommand = {\n\t\t\ttype: \"pseudoCommand\",\n\t\t\texpr: expr,\n\t\t\targs: [target, functionArgs],\n\t\t\top: function (context, target, args) {\n\t\t\t\tvar func = target[functionName];\n\t\t\t\tif (func.hyperfunc) {\n\t\t\t\t\targs.push(context);\n\t\t\t\t}\n\t\t\t\tvar result = func.apply(target, args);\n\t\t\t\tcontext.result = result;\n\t\t\t\treturn runtime.findNext(pseudoCommand, context);\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\n\t\treturn pseudoCommand;\n\t});\n\n\t/**\n\t * @param {ParserObject} parser\n\t * @param {RuntimeObject} runtime\n\t * @param {TokensObject} tokens\n\t * @param {*} target\n\t * @param {*} value\n\t * @returns\n\t */\n\tvar makeSetter = function (parser, runtime, tokens, target, value) {\n\t\tvar symbolWrite = target.type === \"symbol\";\n\t\tvar attributeWrite = target.type === \"attributeRef\";\n\t\tif (!attributeWrite && !symbolWrite && target.root == null) {\n\t\t\tparser.raiseParseError(tokens, \"Can only put directly into symbols, not references\");\n\t\t}\n\n\t\tvar root = null;\n\t\tvar prop = null;\n\t\tif (symbolWrite) {\n\t\t\t// root is null\n\t\t} else if (attributeWrite) {\n\t\t\troot = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t\tvar attribute = target;\n\t\t} else {\n\t\t\tprop = target.prop ? target.prop.value : null;\n\t\t\tvar attribute = target.attribute;\n\t\t\troot = target.root;\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setCmd = {\n\t\t\ttarget: target,\n\t\t\tsymbolWrite: symbolWrite,\n\t\t\tvalue: value,\n\t\t\targs: [root, value],\n\t\t\top: function (context, root, valueToSet) {\n\t\t\t\tif (symbolWrite) {\n\t\t\t\t\truntime.setSymbol(target.name, context, target.symbolType, valueToSet);\n\t\t\t\t} else {\n\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\tif (attribute) {\n\t\t\t\t\t\t\tif (valueToSet == null) {\n\t\t\t\t\t\t\t\telt.removeAttribute(attribute.name);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\telt.setAttribute(attribute.name, valueToSet);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telt[prop] = valueToSet;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn setCmd;\n\t};\n\n\t_parser.addCommand(\"default\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"default\")) return;\n\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\ttokens.requireToken(\"to\");\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\t/** @type {GrammarElement} */\n\t\tvar setter = makeSetter(parser, runtime, tokens, target, value);\n\t\tvar defaultCmd = {\n\t\t\ttarget: target,\n\t\t\tvalue: value,\n\t\t\tsetter: setter,\n\t\t\targs: [target],\n\t\t\top: function (context, target) {\n\t\t\t\tif (target) {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t} else {\n\t\t\t\t\treturn setter;\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tsetter.parent = defaultCmd;\n\t\treturn defaultCmd;\n\t});\n\n\t_parser.addCommand(\"set\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"set\")) return;\n\t\tif (tokens.currentToken().type === \"L_BRACE\") {\n\t\t\tvar obj = parser.requireElement(\"objectLiteral\", tokens);\n\t\t\ttokens.requireToken(\"on\");\n\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\t\tvar command = {\n\t\t\t\tobjectLiteral: obj,\n\t\t\t\ttarget: target,\n\t\t\t\targs: [obj, target],\n\t\t\t\top: function (ctx, obj, target) {\n\t\t\t\t\tmergeObjects(target, obj);\n\t\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t\treturn command;\n\t\t}\n\n\t\ttry {\n\t\t\ttokens.pushFollow(\"to\");\n\t\t\tvar target = parser.requireElement(\"assignableExpression\", tokens);\n\t\t} finally {\n\t\t\ttokens.popFollow();\n\t\t}\n\t\ttokens.requireToken(\"to\");\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\t\treturn makeSetter(parser, runtime, tokens, target, value);\n\t});\n\n\t_parser.addCommand(\"if\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"if\")) return;\n\t\tvar expr = parser.requireElement(\"expression\", tokens);\n\t\ttokens.matchToken(\"then\"); // optional 'then'\n\t\tvar trueBranch = parser.parseElement(\"commandList\", tokens);\n\t\tif (tokens.matchToken(\"else\")) {\n\t\t\tvar falseBranch = parser.parseElement(\"commandList\", tokens);\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar ifCmd = {\n\t\t\texpr: expr,\n\t\t\ttrueBranch: trueBranch,\n\t\t\tfalseBranch: falseBranch,\n\t\t\targs: [expr],\n\t\t\top: function (context, exprValue) {\n\t\t\t\tif (exprValue) {\n\t\t\t\t\treturn trueBranch;\n\t\t\t\t} else if (falseBranch) {\n\t\t\t\t\treturn falseBranch;\n\t\t\t\t} else {\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(trueBranch, ifCmd);\n\t\tparser.setParent(falseBranch, ifCmd);\n\t\treturn ifCmd;\n\t});\n\n\tvar parseRepeatExpression = function (parser, tokens, runtime, startedWithForToken) {\n\t\tvar innerStartToken = tokens.currentToken();\n\t\tvar identifier;\n\t\tif (tokens.matchToken(\"for\") || startedWithForToken) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tidentifier = identifierToken.value;\n\t\t\ttokens.requireToken(\"in\");\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"in\")) {\n\t\t\tidentifier = \"it\";\n\t\t\tvar expression = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"while\")) {\n\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\tvar isUntil = true;\n\t\t\tif (tokens.matchToken(\"event\")) {\n\t\t\t\tvar evt = _parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar whileExpr = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t} else if (tokens.matchTokenType(\"NUMBER\")) {\n\t\t\tvar times = parseFloat(innerStartToken.value);\n\t\t\ttokens.requireToken(\"times\");\n\t\t} else {\n\t\t\ttokens.matchToken(\"forever\"); // consume optional forever\n\t\t\tvar forever = true;\n\t\t}\n\n\t\tif (tokens.matchToken(\"index\")) {\n\t\t\tvar identifierToken = tokens.requireTokenType(\"IDENTIFIER\");\n\t\t\tvar indexIdentifier = identifierToken.value;\n\t\t}\n\n\t\tvar loop = parser.parseElement(\"commandList\", tokens);\n\t\tif (loop && evt) {\n\t\t\t// if this is an event based loop, wait a tick at the end of the loop so that\n\t\t\t// events have a chance to trigger in the loop condition o_O)))\n\t\t\tvar last = loop;\n\t\t\twhile (last.next) {\n\t\t\t\tlast = last.next;\n\t\t\t}\n\t\t\tvar waitATick = {\n\t\t\t\ttype: \"waitATick\",\n\t\t\t\top: function () {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tresolve(runtime.findNext(waitATick));\n\t\t\t\t\t\t}, 0);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t};\n\t\t\tlast.next = waitATick;\n\t\t}\n\t\tif (tokens.hasMore()) {\n\t\t\ttokens.requireToken(\"end\");\n\t\t}\n\n\t\tif (identifier == null) {\n\t\t\tidentifier = \"_implicit_repeat_\" + innerStartToken.start;\n\t\t\tvar slot = identifier;\n\t\t} else {\n\t\t\tvar slot = identifier + \"_\" + innerStartToken.start;\n\t\t}\n\n\t\tvar repeatCmd = {\n\t\t\tidentifier: identifier,\n\t\t\tindexIdentifier: indexIdentifier,\n\t\t\tslot: slot,\n\t\t\texpression: expression,\n\t\t\tforever: forever,\n\t\t\ttimes: times,\n\t\t\tuntil: isUntil,\n\t\t\tevent: evt,\n\t\t\ton: on,\n\t\t\twhileExpr: whileExpr,\n\t\t\tresolveNext: function () {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tloop: loop,\n\t\t\targs: [whileExpr],\n\t\t\top: function (context, whileValue) {\n\t\t\t\tvar iteratorInfo = context.meta.iterators[slot];\n\t\t\t\tvar keepLooping = false;\n\t\t\t\tvar loopVal = null;\n\t\t\t\tif (this.forever) {\n\t\t\t\t\tkeepLooping = true;\n\t\t\t\t} else if (this.until) {\n\t\t\t\t\tif (evt) {\n\t\t\t\t\t\tkeepLooping = context.meta.iterators[slot].eventFired === false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tkeepLooping = whileValue !== true;\n\t\t\t\t\t}\n\t\t\t\t} else if (whileExpr) {\n\t\t\t\t\tkeepLooping = whileValue;\n\t\t\t\t} else if (times) {\n\t\t\t\t\tkeepLooping = iteratorInfo.index < this.times;\n\t\t\t\t} else {\n\t\t\t\t\tvar nextValFromIterator = iteratorInfo.iterator.next();\n\t\t\t\t\tkeepLooping = !nextValFromIterator.done;\n\t\t\t\t\tloopVal = nextValFromIterator.value;\n\t\t\t\t}\n\n\t\t\t\tif (keepLooping) {\n\t\t\t\t\tif (iteratorInfo.value) {\n\t\t\t\t\t\tcontext.result = context[identifier] = loopVal;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.result = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\tif (indexIdentifier) {\n\t\t\t\t\t\tcontext[indexIdentifier] = iteratorInfo.index;\n\t\t\t\t\t}\n\t\t\t\t\titeratorInfo.index++;\n\t\t\t\t\treturn loop;\n\t\t\t\t} else {\n\t\t\t\t\tcontext.meta.iterators[slot] = null;\n\t\t\t\t\treturn runtime.findNext(this.parent, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\tparser.setParent(loop, repeatCmd);\n\t\tvar repeatInit = {\n\t\t\tname: \"repeatInit\",\n\t\t\targs: [expression, evt, on],\n\t\t\top: function (context, value, event, on) {\n\t\t\t\tvar iteratorInfo = {\n\t\t\t\t\tindex: 0,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\teventFired: false,\n\t\t\t\t};\n\t\t\t\tcontext.meta.iterators[slot] = iteratorInfo;\n\t\t\t\tif (value && value[Symbol.iterator]) {\n\t\t\t\t\titeratorInfo.iterator = value[Symbol.iterator]();\n\t\t\t\t}\n\t\t\t\tif (evt) {\n\t\t\t\t\tvar target = on || context.me;\n\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\tevent,\n\t\t\t\t\t\tfunction (e) {\n\t\t\t\t\t\t\tcontext.meta.iterators[slot].eventFired = true;\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn repeatCmd; // continue to loop\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\t\tparser.setParent(repeatCmd, repeatInit);\n\t\treturn repeatInit;\n\t};\n\n\t_parser.addCommand(\"repeat\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"repeat\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, false);\n\t\t}\n\t});\n\n\t_parser.addCommand(\"for\", function (parser, runtime, tokens) {\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\treturn parseRepeatExpression(parser, tokens, runtime, true);\n\t\t}\n\t});\n\n\t_parser.addGrammarElement(\"stringLike\", function (parser, runtime, tokens) {\n\t\treturn _parser.parseAnyOf([\"string\", \"nakedString\"], tokens);\n\t});\n\n\t_parser.addCommand(\"append\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"append\")) return;\n\t\tvar target = null;\n\t\tvar prop = null;\n\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\ttarget = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tif (target == null) {\n\t\t\tprop = \"result\";\n\t\t} else if (target.type === \"symbol\") {\n\t\t\tprop = target.name;\n\t\t} else if (target.type === \"propertyAccess\") {\n\t\t\tprop = target.prop.value;\n\t\t} else {\n\t\t\tthrow \"Unable to append to \" + target.type;\n\t\t}\n\n\t\tvar command = {\n\t\t\tvalue: value,\n\t\t\ttarget: target,\n\t\t\targs: [value],\n\t\t\top: function (context, value) {\n\t\t\t\tif (Array.isArray(context[prop])) {\n\t\t\t\t\tcontext[prop].push(value);\n\t\t\t\t} else if (context[prop] instanceof Element) {\n\t\t\t\t\tif (typeof value == \"string\") {\n\t\t\t\t\t\tcontext[prop].innerHTML += value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Don't know how to append non-strings to an HTML Element yet.\";\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext[prop] += value;\n\t\t\t\t}\n\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/*, value, target*/);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"increment\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"increment\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar command = {\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue + amount;\n\t\t\t\tvar setter = makeSetter(parser, runtime, tokens, target, newValue);\n\t\t\t\tcontext.result = newValue;\n\t\t\t\tsetter.parent = this;\n\t\t\t\treturn setter;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/* , target, amount */);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"decrement\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"decrement\")) return;\n\t\tvar amount;\n\n\t\t// This is optional.  Defaults to \"result\"\n\t\tvar target = parser.parseElement(\"assignableExpression\", tokens);\n\n\t\t// This is optional. Defaults to 1.\n\t\tif (tokens.matchToken(\"by\")) {\n\t\t\tamount = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar command = {\n\t\t\ttarget: target,\n\t\t\targs: [target, amount],\n\t\t\top: function (context, targetValue, amount) {\n\t\t\t\ttargetValue = targetValue ? parseFloat(targetValue) : 0;\n\t\t\t\tamount = amount ? parseFloat(amount) : 1;\n\t\t\t\tvar newValue = targetValue - amount;\n\t\t\t\tvar setter = makeSetter(parser, runtime, tokens, target, newValue);\n\t\t\t\tcontext.result = newValue;\n\t\t\t\tsetter.parent = this;\n\t\t\t\treturn setter;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context/*, target, amount*/);\n\t\t\t},\n\t\t};\n\t\treturn command;\n\t});\n\n\t_parser.addCommand(\"fetch\", function (parser, runtime, tokens) {\n\t\tif (!tokens.matchToken(\"fetch\")) return;\n\t\tvar url = parser.requireElement(\"stringLike\", tokens);\n\t\tvar args = parser.parseElement(\"objectLiteral\", tokens);\n\n\t\tvar type = \"text\";\n\t\tvar conversion;\n\t\tif (tokens.matchToken(\"as\")) {\n\t\t\tif (tokens.matchToken(\"json\")) {\n\t\t\t\ttype = \"json\";\n\t\t\t} else if (tokens.matchToken(\"response\")) {\n\t\t\t\ttype = \"response\";\n\t\t\t} else if (tokens.matchToken(\"html\")) {\n\t\t\t\ttype = \"html\";\n\t\t\t} else if (tokens.matchToken(\"text\")) {\n\t\t\t\t// default, ignore\n\t\t\t} else {\n\t\t\t\tconversion = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\t\t}\n\t\t}\n\n\t\t/** @type {GrammarElement} */\n\t\tvar fetchCmd = {\n\t\t\turl: url,\n\t\t\targExpressions: args,\n\t\t\targs: [url, args],\n\t\t\top: function (context, url, args) {\n\t\t\t\treturn fetch(url, args)\n\t\t\t\t\t.then(function (resp) {\n\t\t\t\t\t\tif (type === \"response\") {\n\t\t\t\t\t\t\tcontext.result = resp;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type === \"json\") {\n\t\t\t\t\t\t\treturn resp.json().then(function (result) {\n\t\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn resp.text().then(function (result) {\n\t\t\t\t\t\t\tif (conversion) result = runtime.convertValue(result, conversion);\n\n\t\t\t\t\t\t\tif (type === \"html\") result = runtime.convertValue(result, \"Fragment\");\n\n\t\t\t\t\t\t\tcontext.result = result;\n\t\t\t\t\t\t\treturn runtime.findNext(fetchCmd, context);\n\t\t\t\t\t\t});\n\t\t\t\t\t})\n\t\t\t\t\t.catch(function (reason) {\n\t\t\t\t\t\truntime.triggerEvent(context.me, \"fetch:error\", {\n\t\t\t\t\t\t\treason: reason,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tthrow reason;\n\t\t\t\t\t});\n\t\t\t},\n\t\t};\n\t\treturn fetchCmd;\n\t});\n}\n\n//====================================================================\n// Initialization\n//====================================================================\nfunction ready(fn) {\n\tif (document.readyState !== \"loading\") {\n\t\tsetTimeout(fn);\n\t} else {\n\t\tdocument.addEventListener(\"DOMContentLoaded\", fn);\n\t}\n}\n\nfunction getMetaConfig() {\n\t/** @type {HTMLMetaElement} */\n\tvar element = document.querySelector('meta[name=\"htmx-config\"]');\n\tif (element) {\n\t\treturn parseJSON(element.content);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nfunction mergeMetaConfig() {\n\tvar metaConfig = getMetaConfig();\n\tif (metaConfig) {\n\t\t_hyperscript.config = mergeObjects(_hyperscript.config, metaConfig);\n\t}\n}\n\nif (\"document\" in globalScope) {\n\t/** @type {HTMLScriptElement[]} */\n\tvar scripts = Array.from(document.querySelectorAll(\"script[type='text/hyperscript'][src]\"))\n\tPromise.all(\n\t\tscripts.map(function (script) {\n\t\t\treturn fetch(script.src)\n\t\t\t\t.then(function (res) {\n\t\t\t\t\treturn res.text();\n\t\t\t\t})\n\t\t\t\t.then(function (code) {\n\t\t\t\t\treturn _runtime.evaluate(code);\n\t\t\t\t});\n\t\t})\n\t).then(function () {\n\t\tready(function () {\n\t\t\tmergeMetaConfig();\n\t\t\t_runtime.processNode(document.documentElement);\n\t\t\tdocument.addEventListener(\"htmx:load\", function (/** @type {CustomEvent} */ evt) {\n\t\t\t\t_runtime.processNode(evt.detail.elt);\n\t\t\t});\n\t\t});\n\t});\n}\n\n//====================================================================\n// API\n//====================================================================\n/** @type {HyperscriptObject} */\nexport default _hyperscript = mergeObjects(\n\tfunction (str, ctx) {\n\t\treturn _runtime.evaluate(str, ctx); //OK\n\t},\n\t{\n\t\tinternals: {\n\t\t\tlexer: _lexer,\n\t\t\tparser: _parser,\n\t\t\truntime: _runtime,\n\t\t},\n\t\tElementCollection: ElementCollection,\n\t\taddFeature: function (keyword, definition) {\n\t\t\t_parser.addFeature(keyword, definition);\n\t\t},\n\t\taddCommand: function (keyword, definition) {\n\t\t\t_parser.addCommand(keyword, definition);\n\t\t},\n\t\taddLeafExpression: function (name, definition) {\n\t\t\t_parser.addLeafExpression(name, definition);\n\t\t},\n\t\taddIndirectExpression: function (name, definition) {\n\t\t\t_parser.addIndirectExpression(name, definition);\n\t\t},\n\t\tevaluate: _runtime.evaluate.bind(_runtime),\n\t\tparse: _runtime.parse.bind(_runtime),\n\t\tprocessNode: _runtime.processNode.bind(_runtime),\n\t\tconfig: {\n\t\t\tattributes: \"_, script, data-script\",\n\t\t\tdefaultTransition: \"all 500ms ease-in\",\n\t\t\tdisableSelector: \"[disable-scripting], [data-disable-scripting]\",\n\t\t\tconversions: CONVERSIONS,\n\t\t},\n\t}\n);\n","///=========================================================================\n/// This module provides the core web functionality for hyperscript\n///=========================================================================\n\nimport _hyperscript from \"./core\"\n\nfunction mergeObjects(obj1, obj2) {\n\tfor (var key in obj2) {\n\t\tif (obj2.hasOwnProperty(key)) {\n\t\t\tobj1[key] = obj2[key];\n\t\t}\n\t}\n\treturn obj1;\n}\n\n_hyperscript.addCommand(\"settle\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"settle\")) {\n\t\tif (!parser.commandBoundary(tokens.currentToken())) {\n\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar on = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar settleCommand = {\n\t\t\ttype: \"settleCmd\",\n\t\t\targs: [on],\n\t\t\top: function (context, on) {\n\t\t\t\tvar resolve = null;\n\t\t\t\tvar resolved = false;\n\t\t\t\tvar transitionStarted = false;\n\n\t\t\t\tvar promise = new Promise(function (r) {\n\t\t\t\t\tresolve = r;\n\t\t\t\t});\n\n\t\t\t\t// listen for a transition begin\n\t\t\t\ton.addEventListener(\n\t\t\t\t\t\"transitionstart\",\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\ttransitionStarted = true;\n\t\t\t\t\t},\n\t\t\t\t\t{ once: true }\n\t\t\t\t);\n\n\t\t\t\t// if no transition begins in 500ms, cancel\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (!transitionStarted && !resolved) {\n\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t}\n\t\t\t\t}, 500);\n\n\t\t\t\t// continue on a transition emd\n\t\t\t\ton.addEventListener(\n\t\t\t\t\t\"transitionend\",\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\tif (!resolved) {\n\t\t\t\t\t\t\tresolve(runtime.findNext(settleCommand, context));\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{ once: true }\n\t\t\t\t);\n\t\t\t\treturn promise;\n\t\t\t},\n\t\t\texecute: function (context) {\n\t\t\t\treturn runtime.unifiedExec(this, context);\n\t\t\t},\n\t\t};\n\t\treturn settleCommand;\n\t}\n});\n\n_hyperscript.addCommand(\"add\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"add\")) {\n\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\tvar attributeRef = null;\n\t\tvar cssDeclaration = null;\n\t\tif (classRef == null) {\n\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\tif (attributeRef == null) {\n\t\t\t\tcssDeclaration = parser.parseElement(\"styleLiteral\", tokens);\n\t\t\t\tif (cssDeclaration == null) {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar classRefs = [classRef];\n\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\tclassRefs.push(classRef);\n\t\t\t}\n\t\t}\n\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\tvar to = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar to = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tif (classRefs) {\n\t\t\treturn {\n\t\t\t\tclassRefs: classRefs,\n\t\t\t\tto: to,\n\t\t\t\targs: [to, classRefs],\n\t\t\t\top: function (context, to, classRefs) {\n\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\t\t\tif (target instanceof Element) target.classList.add(classRef.className);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else if (attributeRef) {\n\t\t\treturn {\n\t\t\t\ttype: \"addCmd\",\n\t\t\t\tattributeRef: attributeRef,\n\t\t\t\tto: to,\n\t\t\t\targs: [to],\n\t\t\t\top: function (context, to, attrRef) {\n\t\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t\texecute: function (ctx) {\n\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\ttype: \"addCmd\",\n\t\t\t\tcssDeclaration: cssDeclaration,\n\t\t\t\tto: to,\n\t\t\t\targs: [to, cssDeclaration],\n\t\t\t\top: function (context, to, css) {\n\t\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\t\ttarget.style.cssText += css;\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t\texecute: function (ctx) {\n\t\t\t\t\treturn runtime.unifiedExec(this, ctx);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n});\n\n_hyperscript.internals.parser.addGrammarElement(\"styleLiteral\", function (parser, runtime, tokens) {\n\tif (!tokens.matchOpToken(\"{\")) return;\n\n\tvar stringParts = [\"\"]\n\tvar exprs = []\n\n\twhile (tokens.hasMore()) {\n\t\tif (tokens.matchOpToken(\"\\\\\")) {\n\t\t\ttokens.consumeToken();\n\t\t} else if (tokens.matchOpToken(\"}\")) {\n\t\t\tbreak;\n\t\t} else if (tokens.matchToken(\"$\")) {\n\t\t\tvar opencurly = tokens.matchOpToken(\"{\");\n\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\tif (opencurly) tokens.requireOpToken(\"}\");\n\n\t\t\texprs.push(expr)\n\t\t\tstringParts.push(\"\")\n\t\t} else {\n\t\t\tvar tok = tokens.consumeToken();\n\t\t\tstringParts[stringParts.length-1] += tokens.source.substring(tok.start, tok.end);\n\t\t}\n\n\t\tstringParts[stringParts.length-1] += tokens.lastWhitespace();\n\t}\n\n\treturn {\n\t\ttype: \"styleLiteral\",\n\t\targs: [exprs],\n\t\top: function (ctx, exprs) {\n\t\t\tvar rv = \"\";\n\n\t\t\tstringParts.forEach(function (part, idx) {\n\t\t\t\trv += part;\n\t\t\t\tif (idx in exprs) rv += exprs[idx];\n\t\t\t});\n\n\t\t\treturn rv;\n\t\t},\n\t\tevaluate: function(ctx) {\n\t\t\treturn runtime.unifiedEval(this, ctx);\n\t\t}\n\t}\n})\n\n_hyperscript.addCommand(\"remove\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"remove\")) {\n\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\tvar attributeRef = null;\n\t\tvar elementExpr = null;\n\t\tif (classRef == null) {\n\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\tif (attributeRef == null) {\n\t\t\t\telementExpr = parser.parseElement(\"expression\", tokens);\n\t\t\t\tif (elementExpr == null) {\n\t\t\t\t\tparser.raiseParseError(\n\t\t\t\t\t\ttokens,\n\t\t\t\t\t\t\"Expected either a class reference, attribute expression or value expression\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvar classRefs = [classRef];\n\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\tclassRefs.push(classRef);\n\t\t\t}\n\t\t}\n\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar from = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tif (elementExpr) {\n\t\t\treturn {\n\t\t\t\telementExpr: elementExpr,\n\t\t\t\tfrom: from,\n\t\t\t\targs: [elementExpr],\n\t\t\t\top: function (context, element) {\n\t\t\t\t\truntime.forEach(element, function (target) {\n\t\t\t\t\t\tif (target.parentElement) {\n\t\t\t\t\t\t\ttarget.parentElement.removeChild(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\tclassRefs: classRefs,\n\t\t\t\tattributeRef: attributeRef,\n\t\t\t\telementExpr: elementExpr,\n\t\t\t\tfrom: from,\n\t\t\t\targs: [classRefs, from],\n\t\t\t\top: function (context, classRefs, from) {\n\t\t\t\t\tif (classRefs) {\n\t\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\t\truntime.implicitLoop(from, function (target) {\n\t\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\truntime.forEach(from, function (target) {\n\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n});\n\n_hyperscript.addCommand(\"toggle\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"toggle\")) {\n\t\tif (tokens.matchToken(\"between\")) {\n\t\t\tvar between = true;\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\ttokens.requireToken(\"and\");\n\t\t\tvar classRef2 = parser.requireElement(\"classRef\", tokens);\n\t\t} else {\n\t\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\t\t\tvar attributeRef = null;\n\t\t\tif (classRef == null) {\n\t\t\t\tattributeRef = parser.parseElement(\"attributeRef\", tokens);\n\t\t\t\tif (attributeRef == null) {\n\t\t\t\t\tparser.raiseParseError(tokens, \"Expected either a class reference or attribute expression\");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tvar classRefs = [classRef];\n\t\t\t\twhile ((classRef = parser.parseElement(\"classRef\", tokens))) {\n\t\t\t\t\tclassRefs.push(classRef);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (tokens.matchToken(\"on\")) {\n\t\t\tvar on = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar on = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\tvar time = parser.requireElement(\"timeExpression\", tokens);\n\t\t} else if (tokens.matchToken(\"until\")) {\n\t\t\tvar evt = parser.requireElement(\"dotOrColonPath\", tokens, \"Expected event name\");\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t\t}\n\t\t}\n\n\t\tvar toggleCmd = {\n\t\t\tclassRef: classRef,\n\t\t\tclassRef2: classRef2,\n\t\t\tclassRefs: classRefs,\n\t\t\tattributeRef: attributeRef,\n\t\t\ton: on,\n\t\t\ttime: time,\n\t\t\tevt: evt,\n\t\t\tfrom: from,\n\t\t\ttoggle: function (on, classRef, classRef2, classRefs) {\n\t\t\t\tif (between) {\n\t\t\t\t\truntime.forEach(on, function (target) {\n\t\t\t\t\t\tif (target.classList.contains(classRef.className)) {\n\t\t\t\t\t\t\ttarget.classList.remove(classRef.className);\n\t\t\t\t\t\t\ttarget.classList.add(classRef2.className);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.classList.add(classRef.className);\n\t\t\t\t\t\t\ttarget.classList.remove(classRef2.className);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else if (classRefs) {\n\t\t\t\t\truntime.forEach(classRefs, function (classRef) {\n\t\t\t\t\t\truntime.forEach(on, function (target) {\n\t\t\t\t\t\t\ttarget.classList.toggle(classRef.className);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\truntime.forEach(on, function (target) {\n\t\t\t\t\t\tif (target.hasAttribute(attributeRef.name)) {\n\t\t\t\t\t\t\ttarget.removeAttribute(attributeRef.name);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.setAttribute(attributeRef.name, attributeRef.value);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t},\n\t\t\targs: [on, time, evt, from, classRef, classRef2, classRefs],\n\t\t\top: function (context, on, time, evt, from, classRef, classRef2, classRefs) {\n\t\t\t\tif (time) {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t}, time);\n\t\t\t\t\t});\n\t\t\t\t} else if (evt) {\n\t\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\t\tvar target = from || context.me;\n\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\tevt,\n\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t\t\t\tresolve(runtime.findNext(toggleCmd, context));\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t);\n\t\t\t\t\t\ttoggleCmd.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthis.toggle(on, classRef, classRef2, classRefs);\n\t\t\t\t\treturn runtime.findNext(toggleCmd, context);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\t\treturn toggleCmd;\n\t}\n});\n\nvar HIDE_SHOW_STRATEGIES = {\n\tdisplay: function (op, element, arg) {\n\t\tif (arg) {\n\t\t\telement.style.display = arg;\n\t\t} else if (op === \"hide\") {\n\t\t\telement.style.display = \"none\";\n\t\t} else {\n\t\t\telement.style.display = \"block\";\n\t\t}\n\t},\n\tvisibility: function (op, element, arg) {\n\t\tif (arg) {\n\t\t\telement.style.visibility = arg;\n\t\t} else if (op === \"hide\") {\n\t\t\telement.style.visibility = \"hidden\";\n\t\t} else {\n\t\t\telement.style.visibility = \"visible\";\n\t\t}\n\t},\n\topacity: function (op, element, arg) {\n\t\tif (arg) {\n\t\t\telement.style.opacity = arg;\n\t\t} else if (op === \"hide\") {\n\t\t\telement.style.opacity = \"0\";\n\t\t} else {\n\t\t\telement.style.opacity = \"1\";\n\t\t}\n\t},\n};\n\nvar parseShowHideTarget = function (parser, runtime, tokens) {\n\tvar target;\n\tvar currentTokenValue = tokens.currentToken();\n\tif (currentTokenValue.value === \"with\" || parser.commandBoundary(currentTokenValue)) {\n\t\ttarget = parser.parseElement(\"implicitMeTarget\", tokens);\n\t} else {\n\t\ttarget = parser.parseElement(\"expression\", tokens);\n\t}\n\treturn target;\n};\n\nvar resolveStrategy = function (parser, tokens, name) {\n\tvar configDefault = _hyperscript.config.defaultHideShowStrategy;\n\tvar strategies = HIDE_SHOW_STRATEGIES;\n\tif (_hyperscript.config.hideShowStrategies) {\n\t\tstrategies = mergeObjects(strategies, _hyperscript.config.hideShowStrategies); // merge in user provided strategies\n\t}\n\tname = name || configDefault || \"display\";\n\tvar value = strategies[name];\n\tif (value == null) {\n\t\tparser.raiseParseError(tokens, \"Unknown show/hide strategy : \" + name);\n\t}\n\treturn value;\n};\n\n_hyperscript.addCommand(\"hide\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"hide\")) {\n\t\tvar target = parseShowHideTarget(parser, runtime, tokens);\n\n\t\tvar name = null;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t}\n\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\treturn {\n\t\t\ttarget: target,\n\t\t\targs: [target],\n\t\t\top: function (ctx, target) {\n\t\t\t\truntime.forEach(target, function (elt) {\n\t\t\t\t\thideShowStrategy(\"hide\", elt);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t}\n});\n\n_hyperscript.addCommand(\"show\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"show\")) {\n\t\tvar target = parseShowHideTarget(parser, runtime, tokens);\n\n\t\tvar name = null;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tname = tokens.requireTokenType(\"IDENTIFIER\").value;\n\t\t}\n\t\tvar arg = null;\n\t\tif (tokens.matchOpToken(\":\")) {\n\t\t\tvar tokenArr = tokens.consumeUntilWhitespace();\n\t\t\ttokens.matchTokenType(\"WHITESPACE\");\n\t\t\targ = tokenArr\n\t\t\t\t.map(function (t) {\n\t\t\t\t\treturn t.value;\n\t\t\t\t})\n\t\t\t\t.join(\"\");\n\t\t}\n\t\tvar hideShowStrategy = resolveStrategy(parser, tokens, name);\n\n\t\treturn {\n\t\t\ttarget: target,\n\t\t\targs: [target],\n\t\t\top: function (ctx, target) {\n\t\t\t\truntime.forEach(target, function (elt) {\n\t\t\t\t\thideShowStrategy(\"show\", elt, arg);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, ctx);\n\t\t\t},\n\t\t};\n\t}\n});\n\n_hyperscript.addCommand(\"trigger\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"trigger\")) {\n\t\tvar eventName = parser.requireElement(\"eventName\", tokens);\n\t\tvar details = parser.parseElement(\"namedArgumentList\", tokens);\n\n\t\tvar triggerCmd = {\n\t\t\teventName: eventName,\n\t\t\tdetails: details,\n\t\t\targs: [eventName, details],\n\t\t\top: function (context, eventNameStr, details) {\n\t\t\t\truntime.triggerEvent(context.me, eventNameStr, details ? details : {});\n\t\t\t\treturn runtime.findNext(triggerCmd, context);\n\t\t\t},\n\t\t};\n\t\treturn triggerCmd;\n\t}\n});\n\n_hyperscript.addCommand(\"take\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"take\")) {\n\t\tvar classRef = parser.parseElement(\"classRef\", tokens);\n\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\tvar from = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar from = classRef;\n\t\t}\n\n\t\tif (tokens.matchToken(\"for\")) {\n\t\t\tvar forElt = parser.requireElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar forElt = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar takeCmd = {\n\t\t\tclassRef: classRef,\n\t\t\tfrom: from,\n\t\t\tforElt: forElt,\n\t\t\targs: [classRef, from, forElt],\n\t\t\top: function (context, eltColl, from, forElt) {\n\t\t\t\tvar clazz = eltColl.className;\n\t\t\t\truntime.forEach(from, function (target) {\n\t\t\t\t\ttarget.classList.remove(clazz);\n\t\t\t\t});\n\t\t\t\truntime.forEach(forElt, function (target) {\n\t\t\t\t\ttarget.classList.add(clazz);\n\t\t\t\t});\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn takeCmd;\n\t}\n});\n\nfunction putInto(context, prop, valueToPut) {\n\tif (prop) {\n\t\tvar value = context[prop];\n\t} else {\n\t\tvar value = context;\n\t}\n\tif (value instanceof Element || value instanceof HTMLDocument) {\n\t\twhile (value.firstChild) value.removeChild(value.firstChild);\n\t\tvalue.append(_hyperscript.internals.runtime.convertValue(valueToPut, \"Fragment\"));\n\t} else {\n\t\tif (prop) {\n\t\t\tcontext[prop] = valueToPut;\n\t\t} else {\n\t\t\tthrow \"Don't know how to put a value into \" + typeof context;\n\t\t}\n\t}\n}\n\n_hyperscript.addCommand(\"put\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"put\")) {\n\t\tvar value = parser.requireElement(\"expression\", tokens);\n\n\t\tvar operationToken = tokens.matchAnyToken(\"into\", \"before\", \"after\");\n\n\t\tif (operationToken == null && tokens.matchToken(\"at\")) {\n\t\t\ttokens.matchToken(\"the\"); // optional \"the\"\n\t\t\toperationToken = tokens.matchAnyToken(\"start\", \"end\");\n\t\t\ttokens.requireToken(\"of\");\n\t\t}\n\n\t\tif (operationToken == null) {\n\t\t\tparser.raiseParseError(tokens, \"Expected one of 'into', 'before', 'at start of', 'at end of', 'after'\");\n\t\t}\n\t\tvar target = parser.requireElement(\"expression\", tokens);\n\n\t\tvar operation = operationToken.value;\n\n\t\tvar symbolWrite = false;\n\t\tvar root = null;\n\t\tvar prop = null;\n\t\tif (target.type === \"propertyAccess\" && operation === \"into\") {\n\t\t\tprop = target.prop.value;\n\t\t\troot = target.root;\n\t\t} else if (target.type === \"symbol\" && operation === \"into\") {\n\t\t\tsymbolWrite = true;\n\t\t\tprop = target.name;\n\t\t} else if (target.type === \"attributeRef\" && operation === \"into\") {\n\t\t\tvar attributeWrite = true;\n\t\t\tprop = target.name;\n\t\t\troot = parser.requireElement(\"implicitMeTarget\", tokens);\n\t\t} else if (target.type === \"attributeRefAccess\" && operation === \"into\") {\n\t\t\tvar attributeWrite = true;\n\t\t\tprop = target.attribute.name;\n\t\t\troot = target.root;\n\t\t} else {\n\t\t\troot = target;\n\t\t}\n\n\t\tvar putCmd = {\n\t\t\ttarget: target,\n\t\t\toperation: operation,\n\t\t\tsymbolWrite: symbolWrite,\n\t\t\tvalue: value,\n\t\t\targs: [root, value],\n\t\t\top: function (context, root, valueToPut) {\n\t\t\t\tif (symbolWrite) {\n\t\t\t\t\tputInto(context, prop, valueToPut);\n\t\t\t\t} else {\n\t\t\t\t\tif (operation === \"into\") {\n\t\t\t\t\t\tif (attributeWrite) {\n\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\telt.setAttribute(prop, valueToPut);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\t\tputInto(elt, prop, valueToPut);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar op =\n\t\t\t\t\t\t\toperation === \"before\"\n\t\t\t\t\t\t\t\t? Element.prototype.before\n\t\t\t\t\t\t\t\t: operation === \"after\"\n\t\t\t\t\t\t\t\t? Element.prototype.after\n\t\t\t\t\t\t\t\t: operation === \"start\"\n\t\t\t\t\t\t\t\t? Element.prototype.prepend\n\t\t\t\t\t\t\t\t: operation === \"end\"\n\t\t\t\t\t\t\t\t? Element.prototype.append\n\t\t\t\t\t\t\t\t: Element.prototype.append; // unreachable\n\n\t\t\t\t\t\truntime.implicitLoop(root, function (elt) {\n\t\t\t\t\t\t\top.call(\n\t\t\t\t\t\t\t\telt,\n\t\t\t\t\t\t\t\tvalueToPut instanceof Node\n\t\t\t\t\t\t\t\t\t? valueToPut\n\t\t\t\t\t\t\t\t\t: runtime.convertValue(valueToPut, \"Fragment\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(this, context);\n\t\t\t},\n\t\t};\n\t\treturn putCmd;\n\t}\n});\n\nfunction parsePseudopossessiveTarget(parser, runtime, tokens) {\n\tvar targets;\n\tif (\n\t\ttokens.matchToken(\"the\") ||\n\t\ttokens.matchToken(\"element\") ||\n\t\ttokens.matchToken(\"elements\") ||\n\t\ttokens.currentToken().type === \"CLASS_REF\" ||\n\t\ttokens.currentToken().type === \"ID_REF\" ||\n\t\t(tokens.currentToken().op && tokens.currentToken().value === \"<\")\n\t) {\n\t\tparser.possessivesDisabled = true;\n\t\ttry {\n\t\t\ttargets = parser.parseElement(\"expression\", tokens);\n\t\t} finally {\n\t\t\tdelete parser.possessivesDisabled;\n\t\t}\n\t\t// optional possessive\n\t\tif (tokens.matchOpToken(\"'\")) {\n\t\t\ttokens.requireToken(\"s\");\n\t\t}\n\t} else if (tokens.currentToken().type === \"IDENTIFIER\" && tokens.currentToken().value === \"its\") {\n\t\tvar identifier = tokens.matchToken(\"its\");\n\t\ttargets = {\n\t\t\ttype: \"pseudopossessiveIts\",\n\t\t\ttoken: identifier,\n\t\t\tname: identifier.value,\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.resolveSymbol(\"it\", context);\n\t\t\t},\n\t\t};\n\t} else {\n\t\ttokens.matchToken(\"my\") || tokens.matchToken(\"me\"); // consume optional 'my'\n\t\ttargets = parser.parseElement(\"implicitMeTarget\", tokens);\n\t}\n\treturn targets;\n}\n\n_hyperscript.addCommand(\"transition\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"transition\")) {\n\t\tvar targets = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\t\tvar properties = [];\n\t\tvar from = [];\n\t\tvar to = [];\n\t\tvar currentToken = tokens.currentToken();\n\t\twhile (\n\t\t\t!parser.commandBoundary(currentToken) &&\n\t\t\tcurrentToken.value !== \"over\" &&\n\t\t\tcurrentToken.value !== \"using\"\n\t\t) {\n\t\t\tproperties.push(parser.requireElement(\"stringLike\", tokens));\n\n\t\t\tif (tokens.matchToken(\"from\")) {\n\t\t\t\tfrom.push(parser.requireElement(\"stringLike\", tokens));\n\t\t\t} else {\n\t\t\t\tfrom.push(null);\n\t\t\t}\n\t\t\ttokens.requireToken(\"to\");\n\t\t\tto.push(parser.requireElement(\"stringLike\", tokens));\n\t\t\tcurrentToken = tokens.currentToken();\n\t\t}\n\t\tif (tokens.matchToken(\"over\")) {\n\t\t\tvar over = parser.requireElement(\"timeExpression\", tokens);\n\t\t} else if (tokens.matchToken(\"using\")) {\n\t\t\tvar using = parser.requireElement(\"expression\", tokens);\n\t\t}\n\n\t\tvar transition = {\n\t\t\tto: to,\n\t\t\targs: [targets, properties, from, to, using, over],\n\t\t\top: function (context, targets, properties, from, to, using, over) {\n\t\t\t\tvar promises = [];\n\t\t\t\truntime.forEach(targets, function (target) {\n\t\t\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\t\t\tvar initialTransition = target.style.transition;\n\t\t\t\t\t\tif (over) {\n\t\t\t\t\t\t\ttarget.style.transition = \"all \" + over + \"ms ease-in\";\n\t\t\t\t\t\t} else if (using) {\n\t\t\t\t\t\t\ttarget.style.transition = using;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget.style.transition = _hyperscript.config.defaultTransition;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar internalData = runtime.getInternalData(target);\n\t\t\t\t\t\tvar computedStyles = getComputedStyle(target);\n\n\t\t\t\t\t\tvar initialStyles = {};\n\t\t\t\t\t\tfor (var i = 0; i < computedStyles.length; i++) {\n\t\t\t\t\t\t\tvar name = computedStyles[i];\n\t\t\t\t\t\t\tvar initialValue = computedStyles[name];\n\t\t\t\t\t\t\tinitialStyles[name] = initialValue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// store intitial values\n\t\t\t\t\t\tif (!internalData.initalStyles) {\n\t\t\t\t\t\t\tinternalData.initalStyles = initialStyles;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\tvar fromVal = from[i];\n\t\t\t\t\t\t\tif (fromVal == \"computed\" || fromVal == null) {\n\t\t\t\t\t\t\t\ttarget.style[property] = initialStyles[property];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget.style[property] = fromVal;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// console.log(\"transition started\", transition);\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tvar autoProps = [];\n\t\t\t\t\t\t\tfor (var i = 0; i < properties.length; i++) {\n\t\t\t\t\t\t\t\tvar property = properties[i];\n\t\t\t\t\t\t\t\tvar toVal = to[i];\n\t\t\t\t\t\t\t\tif (toVal == \"initial\") {\n\t\t\t\t\t\t\t\t\tvar propertyValue = internalData.initalStyles[property];\n\t\t\t\t\t\t\t\t\ttarget.style[property] = propertyValue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ttarget.style[property] = toVal;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// console.log(\"set\", property, \"to\", target.style[property], \"on\", target, \"value passed in : \", toVal);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget.addEventListener(\n\t\t\t\t\t\t\t\t\"transitionend\",\n\t\t\t\t\t\t\t\tfunction () {\n\t\t\t\t\t\t\t\t\t// console.log(\"transition ended\", transition);\n\t\t\t\t\t\t\t\t\ttarget.style.transition = initialTransition;\n\t\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t{ once: true }\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}, 5);\n\t\t\t\t\t});\n\t\t\t\t\tpromises.push(promise);\n\t\t\t\t});\n\t\t\t\treturn Promise.all(promises).then(function () {\n\t\t\t\t\treturn runtime.findNext(transition, context);\n\t\t\t\t});\n\t\t\t},\n\t\t};\n\t\treturn transition;\n\t}\n});\n\n_hyperscript.addCommand(\"measure\", function (parser, runtime, tokens) {\n\tif (!tokens.matchToken(\"measure\")) return;\n\n\tvar target = parsePseudopossessiveTarget(parser, runtime, tokens);\n\n\tvar propsToMeasure = [];\n\tif (!parser.commandBoundary(tokens.currentToken()))\n\t\tdo {\n\t\t\tpropsToMeasure.push(tokens.matchTokenType(\"IDENTIFIER\").value);\n\t\t} while (tokens.matchOpToken(\",\"));\n\n\treturn {\n\t\tproperties: propsToMeasure,\n\t\targs: [target],\n\t\top: function (ctx, target) {\n\t\t\tif (0 in target) target = target[0]; // not measuring multiple elts\n\t\t\tvar rect = target.getBoundingClientRect();\n\t\t\tvar scroll = {\n\t\t\t\ttop: target.scrollTop,\n\t\t\t\tleft: target.scrollLeft,\n\t\t\t\ttopMax: target.scrollTopMax,\n\t\t\t\tleftMax: target.scrollLeftMax,\n\t\t\t\theight: target.scrollHeight,\n\t\t\t\twidth: target.scrollWidth,\n\t\t\t};\n\n\t\t\tctx.result = {\n\t\t\t\tx: rect.x,\n\t\t\t\ty: rect.y,\n\t\t\t\tleft: rect.left,\n\t\t\t\ttop: rect.top,\n\t\t\t\tright: rect.right,\n\t\t\t\tbottom: rect.bottom,\n\t\t\t\twidth: rect.width,\n\t\t\t\theight: rect.height,\n\t\t\t\tbounds: rect,\n\n\t\t\t\tscrollLeft: scroll.left,\n\t\t\t\tscrollTop: scroll.top,\n\t\t\t\tscrollLeftMax: scroll.leftMax,\n\t\t\t\tscrollTopMax: scroll.topMax,\n\t\t\t\tscrollWidth: scroll.width,\n\t\t\t\tscrollHeight: scroll.height,\n\t\t\t\tscroll: scroll,\n\t\t\t};\n\n\t\t\truntime.forEach(propsToMeasure, function (prop) {\n\t\t\t\tif (prop in ctx.result) ctx[prop] = ctx.result[prop];\n\t\t\t\telse throw \"No such measurement as \" + prop;\n\t\t\t});\n\n\t\t\treturn runtime.findNext(this, ctx);\n\t\t},\n\t};\n});\n\n_hyperscript.addLeafExpression(\"closestExpr\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"closest\")) {\n\t\tif (tokens.matchToken(\"parent\")) {\n\t\t\tvar parentSearch = true;\n\t\t}\n\n\t\tvar css = null;\n\t\tif (tokens.currentToken().type === \"ATTRIBUTE_REF\") {\n\t\t\tvar attributeRef = parser.parseElement(\"attributeRefAccess\", tokens, null);\n\t\t\tcss = \"[\" + attributeRef.attribute.name + \"]\";\n\t\t}\n\n\t\tif (css == null) {\n\t\t\tvar expr = parser.parseElement(\"expression\", tokens);\n\t\t\tif (expr.css == null) {\n\t\t\t\tparser.raiseParseError(tokens, \"Expected a CSS expression\");\n\t\t\t} else {\n\t\t\t\tcss = expr.css;\n\t\t\t}\n\t\t}\n\n\t\tif (tokens.matchToken(\"to\")) {\n\t\t\tvar to = parser.parseElement(\"expression\", tokens);\n\t\t} else {\n\t\t\tvar to = parser.parseElement(\"implicitMeTarget\", tokens);\n\t\t}\n\n\t\tvar closestExpr = {\n\t\t\ttype: \"closestExpr\",\n\t\t\tparentSearch: parentSearch,\n\t\t\texpr: expr,\n\t\t\tcss: css,\n\t\t\tto: to,\n\t\t\targs: [to],\n\t\t\top: function (ctx, to) {\n\t\t\t\tif (to == null || !(to instanceof Element)) {\n\t\t\t\t\treturn null;\n\t\t\t\t} else {\n\t\t\t\t\tif (parentSearch) {\n\t\t\t\t\t\tvar node = to.parentElement ? to.parentElement.closest(css) : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar node = to.closest(css);\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t}\n\t\t\t},\n\t\t\tevaluate: function (context) {\n\t\t\t\treturn runtime.unifiedEval(this, context);\n\t\t\t},\n\t\t};\n\n\t\tif (attributeRef) {\n\t\t\tattributeRef.root = closestExpr;\n\t\t\tattributeRef.args = [closestExpr];\n\t\t\treturn attributeRef;\n\t\t} else {\n\t\t\treturn closestExpr;\n\t\t}\n\t}\n});\n\n_hyperscript.addCommand(\"go\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"go\")) {\n\t\tif (tokens.matchToken(\"back\")) {\n\t\t\tvar back = true;\n\t\t} else {\n\t\t\ttokens.matchToken(\"to\");\n\t\t\tif (tokens.matchToken(\"url\")) {\n\t\t\t\tvar target = parser.requireElement(\"stringLike\", tokens);\n\t\t\t\tvar url = true;\n\t\t\t\tif (tokens.matchToken(\"in\")) {\n\t\t\t\t\ttokens.requireToken(\"new\");\n\t\t\t\t\ttokens.requireToken(\"window\");\n\t\t\t\t\tvar newWindow = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttokens.matchToken(\"the\"); // optional the\n\t\t\t\tvar verticalPosition = tokens.matchAnyToken(\"top\", \"bottom\", \"middle\");\n\t\t\t\tvar horizontalPosition = tokens.matchAnyToken(\"left\", \"center\", \"right\");\n\t\t\t\tif (verticalPosition || horizontalPosition) {\n\t\t\t\t\ttokens.requireToken(\"of\");\n\t\t\t\t}\n\t\t\t\tvar target = parser.requireElement(\"expression\", tokens);\n\t\t\t\tvar smoothness = tokens.matchAnyToken(\"smoothly\", \"instantly\");\n\n\t\t\t\tvar scrollOptions = {};\n\t\t\t\tif (verticalPosition) {\n\t\t\t\t\tif (verticalPosition.value === \"top\") {\n\t\t\t\t\t\tscrollOptions.block = \"start\";\n\t\t\t\t\t} else if (verticalPosition.value === \"bottom\") {\n\t\t\t\t\t\tscrollOptions.block = \"end\";\n\t\t\t\t\t} else if (verticalPosition.value === \"middle\") {\n\t\t\t\t\t\tscrollOptions.block = \"center\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (horizontalPosition) {\n\t\t\t\t\tif (horizontalPosition.value === \"left\") {\n\t\t\t\t\t\tscrollOptions.inline = \"start\";\n\t\t\t\t\t} else if (horizontalPosition.value === \"center\") {\n\t\t\t\t\t\tscrollOptions.inline = \"center\";\n\t\t\t\t\t} else if (horizontalPosition.value === \"right\") {\n\t\t\t\t\t\tscrollOptions.inline = \"end\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (smoothness) {\n\t\t\t\t\tif (smoothness.value === \"smoothly\") {\n\t\t\t\t\t\tscrollOptions.behavior = \"smooth\";\n\t\t\t\t\t} else if (smoothness.value === \"instantly\") {\n\t\t\t\t\t\tscrollOptions.behavior = \"instant\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar goCmd = {\n\t\t\ttarget: target,\n\t\t\targs: [target],\n\t\t\top: function (ctx, to) {\n\t\t\t\tif (back) {\n\t\t\t\t\twindow.history.back();\n\t\t\t\t} else if (url) {\n\t\t\t\t\tif (to) {\n\t\t\t\t\t\tif (to.indexOf(\"#\") === 0 && !newWindow) {\n\t\t\t\t\t\t\twindow.location.href = to;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twindow.open(to, newWindow ? \"_blank\" : null);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\truntime.forEach(to, function (target) {\n\t\t\t\t\t\ttarget.scrollIntoView(scrollOptions);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn runtime.findNext(goCmd);\n\t\t\t},\n\t\t};\n\t\treturn goCmd;\n\t}\n});\n\n_hyperscript.config.conversions[\"Values\"] = function (/** @type {Node | NodeList} */ node) {\n\t/** @type Object<string,string | string[]> */\n\tvar result = {};\n\n\tvar implicitLoop = _hyperscript.internals.runtime.implicitLoop;\n\n\timplicitLoop(node, function (/** @type HTMLInputElement */ node) {\n\t\t// Try to get a value directly from this node\n\t\tvar input = getInputInfo(node);\n\n\t\tif (input !== undefined) {\n\t\t\tresult[input.name] = input.value;\n\t\t\treturn;\n\t\t}\n\n\t\t// Otherwise, try to query all child elements of this node that *should* contain values.\n\t\tif (node.querySelectorAll != undefined) {\n\t\t\tvar children = node.querySelectorAll(\"input,select,textarea\");\n\t\t\tchildren.forEach(appendValue);\n\t\t}\n\t});\n\n\treturn result;\n\n\t/**\n\t * @param {HTMLInputElement} node\n\t */\n\tfunction appendValue(node) {\n\t\tvar info = getInputInfo(node);\n\n\t\tif (info == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If there is no value already stored in this space.\n\t\tif (result[info.name] == undefined) {\n\t\t\tresult[info.name] = info.value;\n\t\t\treturn;\n\t\t}\n\n\t\tif (Array.isArray(result[info.name]) && Array.isArray(info.value)) {\n\t\t\tresult[info.name] = [].concat(result[info.name], info.value);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * @param {HTMLInputElement} node\n\t * @returns {{name:string, value:string | string[]} | undefined}\n\t */\n\tfunction getInputInfo(node) {\n\t\ttry {\n\t\t\t/** @type {{name: string, value: string | string[]}}*/\n\t\t\tvar result = {\n\t\t\t\tname: node.name,\n\t\t\t\tvalue: node.value,\n\t\t\t};\n\n\t\t\tif (result.name == undefined || result.value == undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (node.type == \"radio\" && node.checked == false) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (node.type == \"checkbox\") {\n\t\t\t\tif (node.checked == false) {\n\t\t\t\t\tresult.value = undefined;\n\t\t\t\t} else if (typeof result.value === \"string\") {\n\t\t\t\t\tresult.value = [result.value];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (node.type == \"select-multiple\") {\n\t\t\t\t/** @type {NodeListOf<HTMLSelectElement>} */\n\t\t\t\tvar selected = node.querySelectorAll(\"option[selected]\");\n\n\t\t\t\tresult.value = [];\n\t\t\t\tfor (var index = 0; index < selected.length; index++) {\n\t\t\t\t\tresult.value.push(selected[index].value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (e) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n};\n\n_hyperscript.config.conversions[\"HTML\"] = function (value) {\n\tvar toHTML = /** @returns {string}*/ function (/** @type any*/ value) {\n\t\tif (value instanceof Array) {\n\t\t\treturn value\n\t\t\t\t.map(function (item) {\n\t\t\t\t\treturn toHTML(item);\n\t\t\t\t})\n\t\t\t\t.join(\"\");\n\t\t}\n\n\t\tif (value instanceof HTMLElement) {\n\t\t\treturn value.outerHTML;\n\t\t}\n\n\t\tif (value instanceof NodeList) {\n\t\t\tvar result = \"\";\n\t\t\tfor (var i = 0; i < value.length; i++) {\n\t\t\t\tvar node = value[i];\n\t\t\t\tif (node instanceof HTMLElement) {\n\t\t\t\t\tresult += node.outerHTML;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tif (value.toString) {\n\t\t\treturn value.toString();\n\t\t}\n\n\t\treturn \"\";\n\t};\n\n\treturn toHTML(value);\n};\n\n_hyperscript.config.conversions[\"Fragment\"] = function (val) {\n\tvar frag = document.createDocumentFragment();\n\t_hyperscript.internals.runtime.implicitLoop(val, function (val) {\n\t\tif (val instanceof Node) frag.append(val);\n\t\telse {\n\t\t\tvar temp = document.createElement(\"template\");\n\t\t\ttemp.innerHTML = val;\n\t\t\tfrag.append(temp.content);\n\t\t}\n\t});\n\treturn frag;\n};\n","///=========================================================================\n/// This module provides the worker feature for hyperscript\n///=========================================================================\n\nimport _hyperscript from \"./core\"\n\nvar invocationIdCounter = 0;\n\nvar workerFunc = function () {\n\tself.onmessage = function (e) {\n\t\tswitch (e.data.type) {\n\t\t\tcase \"init\":\n\t\t\t\timportScripts(e.data._hyperscript);\n\t\t\t\timportScripts.apply(self, e.data.extraScripts);\n\t\t\t\tvar tokens = _hyperscript.internals.lexer.makeTokensObject(e.data.tokens, [], e.data.source);\n\t\t\t\tvar hyperscript = _hyperscript.internals.parser.parseElement(\"hyperscript\", tokens);\n\t\t\t\thyperscript.apply(self);\n\t\t\t\tpostMessage({ type: \"didInit\" });\n\t\t\t\tbreak;\n\t\t\tcase \"call\":\n\t\t\t\ttry {\n\t\t\t\t\tvar result = self[e.data.function].apply(self, e.data.args);\n\t\t\t\t\tPromise.resolve(result)\n\t\t\t\t\t\t.then(function (value) {\n\t\t\t\t\t\t\tpostMessage({\n\t\t\t\t\t\t\t\ttype: \"resolve\",\n\t\t\t\t\t\t\t\tid: e.data.id,\n\t\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch(function (error) {\n\t\t\t\t\t\t\tpostMessage({\n\t\t\t\t\t\t\t\ttype: \"reject\",\n\t\t\t\t\t\t\t\tid: e.data.id,\n\t\t\t\t\t\t\t\terror: error.toString(),\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t} catch (error) {\n\t\t\t\t\tpostMessage({\n\t\t\t\t\t\ttype: \"reject\",\n\t\t\t\t\t\tid: e.data.id,\n\t\t\t\t\t\terror: error.toString(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n};\n\n// extract the body of the function, which was only defined so\n// that we can get syntax highlighting\nvar workerCode = \"(\" + workerFunc.toString() + \")()\";\nvar blob = new Blob([workerCode], { type: \"text/javascript\" });\nvar workerUri = URL.createObjectURL(blob);\n\n_hyperscript.addFeature(\"worker\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"worker\")) {\n\t\tvar name = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\tvar qualifiedName = name.evaluate();\n\t\tvar nameSpace = qualifiedName.split(\".\");\n\t\tvar workerName = nameSpace.pop();\n\n\t\t// Parse extra scripts\n\t\tvar extraScripts = [];\n\t\tif (tokens.matchOpToken(\"(\")) {\n\t\t\tif (tokens.matchOpToken(\")\")) {\n\t\t\t\t// no external scripts\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tvar extraScript = tokens.requireTokenType(\"STRING\").value;\n\t\t\t\t\tvar absoluteUrl = new URL(extraScript, location.href).href;\n\t\t\t\t\textraScripts.push(absoluteUrl);\n\t\t\t\t} while (tokens.matchOpToken(\",\"));\n\t\t\t\ttokens.requireOpToken(\")\");\n\t\t\t}\n\t\t}\n\n\t\t// Consume worker methods\n\n\t\tvar funcNames = [];\n\t\tvar bodyStartIndex = tokens.consumed.length;\n\t\tvar bodyEndIndex = tokens.consumed.length;\n\t\tdo {\n\t\t\tvar feature = parser.parseAnyOf([\"defFeature\", \"jsFeature\"], tokens);\n\t\t\tif (feature) {\n\t\t\t\tif (feature.type === \"defFeature\") {\n\t\t\t\t\tfuncNames.push(feature.name);\n\t\t\t\t\tbodyEndIndex = tokens.consumed.length;\n\t\t\t\t} else {\n\t\t\t\t\tif (tokens.hasMore()) continue;\n\t\t\t\t}\n\t\t\t} else break;\n\t\t} while (tokens.matchToken(\"end\") && tokens.hasMore()); // worker end\n\n\t\tvar bodyTokens = tokens.consumed.slice(bodyStartIndex, bodyEndIndex + 1);\n\n\t\t// Create worker\n\n\t\tvar worker = new Worker(workerUri, { type: \"module\" });\n\n\t\t// Send init message to worker\n\n\t\tworker.postMessage({\n\t\t\ttype: \"init\",\n\t\t\t_hyperscript: runtime.hyperscriptUrl,\n\t\t\textraScripts: extraScripts,\n\t\t\ttokens: bodyTokens,\n\t\t\tsource: tokens.source,\n\t\t});\n\n\t\tvar workerPromise = new Promise(function (resolve, reject) {\n\t\t\tworker.addEventListener(\n\t\t\t\t\"message\",\n\t\t\t\tfunction (e) {\n\t\t\t\t\tif (e.data.type === \"didInit\") resolve();\n\t\t\t\t},\n\t\t\t\t{ once: true }\n\t\t\t);\n\t\t});\n\n\t\t// Create function stubs\n\t\tvar stubs = {};\n\t\tfuncNames.forEach(function (funcName) {\n\t\t\tstubs[funcName] = function () {\n\t\t\t\tvar args = arguments;\n\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\tvar id = invocationIdCounter++;\n\t\t\t\t\tworker.addEventListener(\"message\", function returnListener(e) {\n\t\t\t\t\t\tif (e.data.id !== id) return;\n\t\t\t\t\t\tworker.removeEventListener(\"message\", returnListener);\n\t\t\t\t\t\tif (e.data.type === \"resolve\") resolve(e.data.value);\n\t\t\t\t\t\telse reject(e.data.error);\n\t\t\t\t\t});\n\t\t\t\t\tworkerPromise.then(function () {\n\t\t\t\t\t\t// Worker has been initialized, send invocation.\n\t\t\t\t\t\tworker.postMessage({\n\t\t\t\t\t\t\ttype: \"call\",\n\t\t\t\t\t\t\tfunction: funcName,\n\t\t\t\t\t\t\targs: Array.from(args),\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\n\t\treturn {\n\t\t\tname: workerName,\n\t\t\tworker: worker,\n\t\t\tinstall: function (target) {\n\t\t\t\truntime.assignToNamespace(target, nameSpace, workerName, stubs);\n\t\t\t},\n\t\t};\n\t}\n});\n","///=========================================================================\n/// This module provides the worker feature for hyperscript\n///=========================================================================\n\nimport _hyperscript from \"./core\";\n\nfunction mergeObjects(obj1, obj2) {\n\tfor (var key in obj2) {\n\t\tif (obj2.hasOwnProperty(key)) {\n\t\t\tobj1[key] = obj2[key];\n\t\t}\n\t}\n\treturn obj1;\n}\n\nfunction genUUID() {\n\treturn \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n\t\tvar r = (Math.random() * 16) | 0,\n\t\t\tv = c == \"x\" ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n}\n\nfunction createSocket(url) {\n\treturn new WebSocket(url.evaluate());\n}\n\nvar PROXY_BLACKLIST = [\"then\", \"catch\", \"length\", \"asyncWrapper\", \"toJSON\"];\n\n_hyperscript.addFeature(\"socket\", function (parser, runtime, tokens) {\n\tfunction getProxy(timeout) {\n\t\treturn new Proxy(\n\t\t\t{},\n\t\t\t{\n\t\t\t\tget: function (obj, property) {\n\t\t\t\t\tif (PROXY_BLACKLIST.indexOf(property) >= 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else if (property === \"noTimeout\") {\n\t\t\t\t\t\treturn getProxy(-1);\n\t\t\t\t\t} else if (property === \"timeout\") {\n\t\t\t\t\t\treturn function (i) {\n\t\t\t\t\t\t\treturn getProxy(parseInt(i));\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn function () {\n\t\t\t\t\t\t\tvar uuid = genUUID();\n\t\t\t\t\t\t\tvar args = [];\n\t\t\t\t\t\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\t\t\t\t\t\targs.push(arguments[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvar rpcInfo = {\n\t\t\t\t\t\t\t\tiid: uuid,\n\t\t\t\t\t\t\t\tfunction: property,\n\t\t\t\t\t\t\t\targs: args,\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tsocket = socket ? socket : createSocket(url); //recreate socket if needed\n\t\t\t\t\t\t\tsocket.send(JSON.stringify(rpcInfo));\n\n\t\t\t\t\t\t\tvar promise = new Promise(function (resolve, reject) {\n\t\t\t\t\t\t\t\tpromises[uuid] = {\n\t\t\t\t\t\t\t\t\tresolve: resolve,\n\t\t\t\t\t\t\t\t\treject: reject,\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\tif (timeout >= 0) {\n\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\tif (promises[uuid]) {\n\t\t\t\t\t\t\t\t\t\tpromises[uuid].reject(\"Timed out\");\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tdelete promises[uuid];\n\t\t\t\t\t\t\t\t}, timeout); // TODO configurable?\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn promise;\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t}\n\t\t);\n\t}\n\n\tif (tokens.matchToken(\"socket\")) {\n\t\tvar name = parser.requireElement(\"dotOrColonPath\", tokens);\n\t\tvar qualifiedName = name.evaluate();\n\t\tvar nameSpace = qualifiedName.split(\".\");\n\t\tvar socketName = nameSpace.pop();\n\n\t\tvar promises = {};\n\t\tvar url = parser.requireElement(\"stringLike\", tokens);\n\n\t\tvar defaultTimeout = 10000;\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\ttokens.requireToken(\"timeout\");\n\t\t\tdefaultTimeout = parser.requireElement(\"timeExpression\", tokens).evaluate();\n\t\t}\n\n\t\tif (tokens.matchToken(\"on\")) {\n\t\t\ttokens.requireToken(\"message\");\n\t\t\tif (tokens.matchToken(\"as\")) {\n\t\t\t\ttokens.requireToken(\"json\");\n\t\t\t\tvar jsonMessages = true;\n\t\t\t}\n\t\t\tvar messageHandler = parser.requireElement(\"commandList\", tokens);\n\t\t\tvar implicitReturn = {\n\t\t\t\ttype: \"implicitReturn\",\n\t\t\t\top: function (context) {\n\t\t\t\t\treturn runtime.HALT;\n\t\t\t\t},\n\t\t\t\texecute: function (context) {\n\t\t\t\t\t// do nothing\n\t\t\t\t},\n\t\t\t};\n\t\t\tvar end = messageHandler;\n\t\t\twhile (end.next) {\n\t\t\t\tend = end.next;\n\t\t\t}\n\t\t\tend.next = implicitReturn;\n\t\t\t// TODO set parent?\n\t\t\t// parser.setParent(implicitReturn, initFeature);\n\t\t}\n\n\t\tvar socket = createSocket(url);\n\t\tvar rpcProxy = getProxy(defaultTimeout);\n\n\t\tvar socketObject = {\n\t\t\traw: socket,\n\t\t\tdispatchEvent: function (evt) {\n\t\t\t\tvar details = evt.detail;\n\t\t\t\t// remove hyperscript internals\n\t\t\t\tdelete details.sentBy;\n\t\t\t\tdelete details._namedArgList_;\n\t\t\t\tsocket.send(JSON.stringify(mergeObjects({ type: evt.type }, details)));\n\t\t\t},\n\t\t\trpc: rpcProxy,\n\t\t};\n\n\t\tvar socketFeature = {\n\t\t\tname: socketName,\n\t\t\tsocket: socketObject,\n\t\t\tinstall: function (target) {\n\t\t\t\truntime.assignToNamespace(target, nameSpace, socketName, socketObject);\n\t\t\t},\n\t\t};\n\n\t\tsocket.onmessage = function (evt) {\n\t\t\tvar data = evt.data;\n\t\t\ttry {\n\t\t\t\tvar dataAsJson = JSON.parse(data);\n\t\t\t} catch (e) {\n\t\t\t\t// not JSON\n\t\t\t}\n\n\t\t\t// RPC reply\n\t\t\tif (dataAsJson && dataAsJson.iid) {\n\t\t\t\tif (dataAsJson.throw) {\n\t\t\t\t\tpromises[dataAsJson.iid].reject(dataAsJson.throw);\n\t\t\t\t} else {\n\t\t\t\t\tpromises[dataAsJson.iid].resolve(dataAsJson.return);\n\t\t\t\t}\n\t\t\t\tdelete promises[dataAsJson.iid];\n\t\t\t}\n\n\t\t\tif (messageHandler) {\n\t\t\t\tvar context = runtime.makeContext(socketObject, socketFeature, socketObject);\n\t\t\t\tif (jsonMessages) {\n\t\t\t\t\tif (dataAsJson) {\n\t\t\t\t\t\tcontext.message = dataAsJson;\n\t\t\t\t\t\tcontext.result = dataAsJson;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"Received non-JSON message from socket: \" + data;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcontext.message = data;\n\t\t\t\t\tcontext.result = data;\n\t\t\t\t}\n\t\t\t\tmessageHandler.execute(context);\n\t\t\t}\n\t\t};\n\n\t\t// clear socket on close to be recreated\n\t\tsocket.addEventListener(\"close\", function (e) {\n\t\t\tsocket = null;\n\t\t});\n\n\t\treturn socketFeature;\n\t}\n});\n","\nimport _hyperscript from \"./core\"\n\nfunction compileTemplate(template) {\n\treturn template.replace(/(?:^|\\n)([^@]*)@?/gm, function (match, p1) {\n\t\tvar templateStr = (\" \" + p1).replace(/([^\\\\])\\$\\{/g, \"$1$${escape html \").substring(1);\n\t\treturn \"\\ncall __ht_template_result.push(`\" + templateStr + \"`)\\n\";\n\t});\n}\n\nfunction renderTemplate(template, ctx) {\n\tvar buf = [];\n\t_hyperscript(template, Object.assign({ __ht_template_result: buf }, ctx));\n\treturn buf.join(\"\");\n}\n\n_hyperscript.addCommand(\"render\", function (parser, runtime, tokens) {\n\tif (!tokens.matchToken(\"render\")) return;\n\tvar template_ = parser.requireElement(\"expression\", tokens);\n\tvar templateArgs = {};\n\tif (tokens.matchToken(\"with\")) {\n\t\ttemplateArgs = parser.parseElement(\"namedArgumentList\", tokens);\n\t}\n\treturn {\n\t\targs: [template_, templateArgs],\n\t\top: function (ctx, template, templateArgs) {\n\t\t\tif (!(template instanceof Element)) throw new Error(template_.sourceFor() + \" is not an element\");\n\t\t\tconsole.log(compileTemplate(template.innerHTML));\n\t\t\tctx.result = renderTemplate(compileTemplate(template.innerHTML), templateArgs);\n\t\t\treturn runtime.findNext(this, ctx);\n\t\t},\n\t};\n});\n\nfunction escapeHTML(html) {\n\treturn String(html)\n\t\t.replace(/&/g, \"&amp;\")\n\t\t.replace(/</g, \"&lt;\")\n\t\t.replace(/>/g, \"&gt;\")\n\t\t.replace(/\\x22/g, \"&quot;\")\n\t\t.replace(/\\x27/g, \"&#039;\");\n}\n\n_hyperscript.addLeafExpression(\"escape\", function (parser, runtime, tokens) {\n\tif (!tokens.matchToken(\"escape\")) return;\n\tvar escapeType = tokens.matchTokenType(\"IDENTIFIER\").value;\n\n\t// hidden! for use in templates\n\tvar unescaped = tokens.matchToken(\"unescaped\");\n\n\tvar arg = parser.requireElement(\"expression\", tokens);\n\n\treturn {\n\t\targs: [arg],\n\t\top: function (ctx, arg) {\n\t\t\tif (unescaped) return arg;\n\t\t\tif (arg === undefined) return \"\";\n\t\t\tswitch (escapeType) {\n\t\t\t\tcase \"html\":\n\t\t\t\t\treturn escapeHTML(arg);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unknown escape: \" + escapeType);\n\t\t\t}\n\t\t},\n\t\tevaluate: function (ctx) {\n\t\t\treturn runtime.unifiedEval(this, ctx);\n\t\t},\n\t};\n});\n","\nimport _hyperscript from \"./core\"\n\nfunction HDB(ctx, runtime, breakpoint) {\n\tthis.ctx = ctx;\n\tthis.runtime = runtime;\n\tthis.cmd = breakpoint;\n\tthis._hyperscript = _hyperscript;\n\n\tthis.bus = new EventTarget();\n} // See below for methods\n\n_hyperscript.addCommand(\"breakpoint\", function (parser, runtime, tokens) {\n\tif (!tokens.matchToken(\"breakpoint\")) return;\n\n\tvar hdb;\n\n\treturn {\n\t\top: function (ctx) {\n\t\t\tglobalThis.hdb = hdb = new HDB(ctx, runtime, this);\n\t\t\ttry {\n\t\t\t\treturn hdb.break(ctx);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e, e.stack);\n\t\t\t}\n\t\t},\n\t};\n});\n\nHDB.prototype.break = function(ctx) {\n\tvar self = this;\n\tconsole.log(\"=== HDB///_hyperscript/debugger ===\");\n\tself.ui();\n\treturn new Promise(function (resolve, reject) {\n\t\tself.bus.addEventListener(\n\t\t\t\"continue\",\n\t\t\tfunction () {\n\t\t\t\tif (self.ctx !== ctx) {\n\t\t\t\t\t// Context switch\n\t\t\t\t\tfor (var attr in ctx) {\n\t\t\t\t\t\tdelete ctx[attr];\n\t\t\t\t\t}\n\t\t\t\t\tObject.assign(ctx, self.ctx);\n\t\t\t\t}\n\t\t\t\tdelete globalThis.hdb;\n\t\t\t\tresolve(self.runtime.findNext(self.cmd, self.ctx));\n\t\t\t},\n\t\t\t{ once: true }\n\t\t);\n\t});\n};\n\nHDB.prototype.continueExec = function () {\n\tthis.bus.dispatchEvent(new Event(\"continue\"));\n};\n\nHDB.prototype.stepOver = function () {\n\tvar self = this;\n\tif (!self.cmd) return self.continueExec();\n\tvar result =\n\t\tself.cmd && self.cmd.type === \"breakpointCommand\"\n\t\t\t? self.runtime.findNext(self.cmd, self.ctx)\n\t\t\t: self.runtime.unifiedEval(self.cmd, self.ctx);\n\tif (result.type === \"implicitReturn\") return self.stepOut();\n\tif (result && result.then instanceof Function) {\n\t\treturn result.then(function (next) {\n\t\t\tself.cmd = next;\n\t\t\tself.bus.dispatchEvent(new Event(\"step\"));\n\t\t\tself.logCommand();\n\t\t});\n\t} else if (result.halt_flag) {\n\t\tthis.bus.dispatchEvent(new Event(\"continue\"));\n\t} else {\n\t\tself.cmd = result;\n\t\tself.bus.dispatchEvent(new Event(\"step\"));\n\t\tthis.logCommand();\n\t}\n};\n\nHDB.prototype.stepOut = function () {\n\tvar self = this;\n\tif (!self.ctx.meta.caller) return self.continueExec();\n\tvar callingCmd = self.ctx.meta.callingCommand;\n\tvar oldMe = self.ctx.me;\n\tself.ctx = self.ctx.meta.caller;\n\tconsole.log(\n\t\t\"[hdb] cstepping out into \" + self.ctx.meta.feature.displayName)\n\tif (self.ctx.me instanceof Element && self.ctx.me !== oldMe) {\n\t\tconsole.log(\"[hdb] me: \", self.ctx.me)\n\t}\n\tself.cmd = self.runtime.findNext(callingCmd, self.ctx);\n\tself.cmd = self.runtime.findNext(self.cmd, self.ctx);\n\tself.logCommand();\n\tself.bus.dispatchEvent(new Event(\"step\"));\n};\n\nHDB.prototype.logCommand = function () {\n\tvar hasSource = this.cmd.sourceFor instanceof Function;\n\tvar cmdSource = hasSource ? this.cmd.sourceFor() : '-- '+this.cmd.type;\n\tconsole.log(\"[hdb] current command: \" + cmdSource)\n}\n\nvar ui = `\n<div class=\"hdb\" _=\"\non load or step from hdb.bus send update to me\non continue from hdb.bus log 'done' then remove me.getRootNode().host\">\n\n<script type=\"text/hyperscript\">\n\ndef escapeHTML(unsafe)\n\tjs(unsafe) return unsafe\n\t\t.replace(/&/g, \"&amp;\")\n\t\t.replace(/</g, \"&lt;\")\n\t\t.replace(/>/g, \"&gt;\")\n\t\t.replace(/\\\\x22/g, \"&quot;\")\n\t\t.replace(/\\\\x27/g, \"&#039;\") end\n\treturn it\nend\n\ndef highlightDebugCode\n\tset start to hdb.cmd.startToken.start\n\tset end to hdb.cmd.endToken.end\n\tset src to hdb.cmd.programSource\n\tset beforeCmd to '<code>'+escapeHTML(src.substring(0, start))+'</code>'\n\tset cmd to escapeHTML(src.substring(start, end))\n\tset afterCmd to '<code>'+escapeHTML(src.substring(end))+'</code>'\n\treturn beforeCmd+\"<u class='current'><code>\"+cmd+\"</code></u>\"+afterCmd\nend\n\ndef truncate(str, len)\n\tif str.length <= len return str end\n\treturn str.substr(0, len) + ''\n\ndef prettyPrint(obj)\n\tif obj is null      return 'null'      end\n\tif Element.prototype.isPrototypeOf(obj)\n\t\tset rv to '&lt;<span class=\"token tagname\">' +\n\t\t\tobj.tagName.toLowerCase() + \"</span>\"\n\t\tfor attr in Array.from(obj.attributes)\n\t\t\tif attr.specified\n\t\t\t\tset rv to rv +\n\t\t\t\t\t' <span class=\"token attr\">' + attr.nodeName +\n\t\t\t\t\t'</span>=<span class=\"token string\">\"' + truncate(attr.textContent, 10) +\n\t\t\t\t\t'\"</span>'\n\t\t\tend\n\t\tend\n\t\tset rv to rv + '>'\n\t\treturn rv\n\telse if obj.call\n\t\tif obj.hyperfunc\n\t\t\tget \"def \" + obj.hypername + ' ...'\n\t\telse\n\t\t\tget \"function \"+obj.name+\"(...) {...}\"\n\t\tend\n\telse if obj.toString\n\t\tcall obj.toString()\n\tend\n\treturn escapeHTML((it or 'undefined').trim())\nend\n</script>\n\n<header _=\"\non pointerdown(clientX, clientY)\n\thalt the event\n\tcall event.stopPropagation()\n\tget closest .hdb\n\tmeasure its x, y\n\tset xoff to clientX - x\n\tset yoff to clientY - y\n\trepeat until event pointerup from document\n\t\twait for pointermove or pointerup from document\n\t\tadd {\n\t\t\tleft: \\${its clientX - xoff}px;\n\t\t\ttop:  \\${its clientY - yoff}px;\n\t\t} to .hdb\n\tend\n\">\n\t<h2 class=\"titlebar\">HDB</h2>\n\t<ul role=\"toolbar\" class=\"toolbar\" _=\"on pointerdown halt\">\n\t\t<li><button _=\"on click call hdb.continueExec()\">\n\t\t\t&#x23F5; Continue\n\t\t</button>\n\t\t<li><button _=\"on click call hdb.stepOver()\">\n\t\t\t&#8631; Step Over\n\t\t</button>\n\t</ul>\n</header>\n\n<section class=\"sec-code\">\n\n\t<div class=\"code-container\">\n\t\t<pre class=\"code language-hyperscript\" _=\"\n\t\t\ton update from .hdb if hdb.cmd.programSource\n\t\t\t\tput highlightDebugCode() into me\n\t\t\t\tif Prism\n\t\t\t\t\tcall Prism.highlightAllUnder(me)\n\t\t\t\tend\n\t\t\t\tscrollIntoView({ block: 'nearest' }) the\n\t\t\t\t\tfirst .current in me\"><code></code></pre>\n\t</div>\n</section>\n\n<section class=\"sec-console\" _=\"\n\t-- Print context at startup\n\tinit repeat for var in Object.keys(hdb.ctx) if var is not 'meta'\n\t\tsend hdbUI:consoleEntry(input: var, output: hdb.ctx[var]) to #console\">\n\n\t<ul id=\"console\" role=\"list\" _=\"\n\t\ton hdbUI:consoleEntry(input, output)\n\t\t\tif no hdb.consoleHistory set hdb.consoleHistory to [] end\n\t\t\tpush(input) on hdb.consoleHistory\n\t\t\tset node to #tmpl-console-entry.content.cloneNode(true)\n\t\t\tput the node at end of me\n\t\t\tset entry to my lastElementChild\n\t\t\tscrollIntoView({ block: 'end' }) the entry\n\t\t\tput escapeHTML(input) into .input in the entry\n\t\t\tif no output\n\t\t\t\tcall hdb._hyperscript.internals.runtime.parse(input)\n\t\t\t\tif its execute is not undefined then execute(hdb.ctx) it\n\t\t\t\telse evaluate(hdb.ctx) it\n\t\t\t\tend\n\t\t\t\tset output to it\n\t\t\tend\n\t\t\tput prettyPrint(output) as Fragment into .output in the entry\n\t\t\">\n\t\t<template id=\"tmpl-console-entry\">\n\t\t\t<li class=\"console-entry\">\n\t\t\t\t<kbd><code class=\"input\"></code></kbd>\n\t\t\t\t<samp class=\"output\"></samp>\n\t\t\t</li>\n\t\t</template>\n\t</ul>\n\n\t<form id=\"console-form\" data-hist=\"0\" _=\"on submit\n\t\t\tsend hdbUI:consoleEntry(input: #console-input's value) to #console\n\t\t\tset #console-input's value to ''\n\t\t\tset @data-hist to 0\n\t\t\tset element oldContent to null\n\t\t\thalt\n\t\ton keydown[key is 'ArrowUp' or key is 'ArrowDown']\n\t\t\tif no hdb.consoleHistory or exit end\n\t\t\tif element oldContent is null set element oldContent to #console-input.value end\n\t\t\tif event.key is 'ArrowUp' and hdb.consoleHistory.length > -@data-hist\n\t\t\t\tdecrement @data-hist\n\t\t\telse if event.key is 'ArrowDown' and @data-hist < 0\n\t\t\t\tincrement @data-hist\n\t\t\tend end\n\t\t\tset #console-input.value to hdb.consoleHistory[hdb.consoleHistory.length + @data-hist as Int]\n\t\t\t\tor oldContent\n\t\t\thalt default\n\t\ton input if @data-hist is '0' set element oldContent to #console-input.value\">\n\t\t<input id=\"console-input\" placeholder=\"Enter an expression&hellip;\"\n\t\t\tautocomplete=\"off\">\n\t</form>\n</section>\n\n<style>\n.hdb {\n\tborder: 1px solid #888;\n\tborder-radius: .3em;\n\tbox-shadow: 0 .2em .3em #0008;\n\tposition: fixed;\n\ttop: .5em; right: .5em;\n\twidth: min(40ch, calc(100% - 1em));\n\tmax-height: calc(100% - 1em);\n\tbackground-color: white;\n\tfont-family: sans-serif;\n\topacity: .9;\n\tz-index: 2147483647;\n\tcolor: black;\n\tdisplay: flex;\n\tflex-flow: column;\n}\n\n* {\n\tbox-sizing: border-box;\n}\n\nheader {\n\tdisplay: flex;\n\tjustify-content: space-between;\n\talign-items: center;\n\tpadding: .4em;\n}\n\n.titlebar {\n\tmargin: 0;\n\tfont-size: 1em;\n\ttouch-action: none;\n}\n\n.toolbar {\n\tdisplay: flex;\n\tgap: .35em;\n\n\tlist-style: none;\n\tpadding-left: 0;\n\tmargin: 0;\n}\n\n.toolbar a, .toolbar button {\n\tbackground: #2183ff;\n\tborder: 1px solid #3465a4;\n\tbox-shadow: 0 1px #b3c6ff inset, 0 .06em .06em #000;\n\tborder-radius: .2em;\n\tfont: inherit;\n\tpadding: .2em .3em;\n\tcolor: white;\n\ttext-shadow: 0 1px black;\n\tfont-weight: bold;\n}\n\n.toolbar a:hover .toolbar a:focus, .toolbar button:hover, .toolbar button:focus {\n\tbackground: #94c8ff;\n}\n\n.toolbar a:active, .toolbar button:active {\n\tbackground: #3465a4;\n}\n\n.sec-code {\n\tborder-radius: .3em;\n\toverflow: hidden;\n\tbox-shadow: 0 1px white inset, 0 .06em .06em #0008;\n\tbackground: #bdf;\n\tmargin: 0 .4em;\n\tborder: 1px solid #3465a4;\n}\n\n.hdb h3 {\n\tmargin: 0;\n\tfont-size: 1em;\n\tpadding: .2em .4em 0 .4em;\n}\n\n.code-container {\n\tdisplay: grid;\n\tline-height: 1.2em;\n\theight: calc(12 * 1.2em);\n\tborder-radius: 0 0 .2em .2em;\n\toverflow: auto;\n\tscrollbar-width: thin;\n\tscrollbar-color: #0003 transparent;\n}\n\n.code, #console, #console-input {\n\tfont-family: Consolas, \"Andale Mono WT\", \"Andale Mono\", \"Lucida Console\", \"Lucida Sans Typewriter\", \"DejaVu Sans Mono\", \"Bitstream Vera Sans Mono\", \"Liberation Mono\", \"Nimbus Mono L\", Monaco, \"Courier New\", Courier, monospace;\n}\n\n.code {\n\twidth: 0;\n\tmargin: 0;\n\tpadding-left: 1ch;\n\ttab-size: 2;\n\t-moz-tab-size: 2;\n\t-o-tab-size: 2;\n}\n\n.current {\n\tfont-weight: bold;\n\tbackground: #abf;\n}\n\n#console {\n\toverflow-y: scroll;\n\tscrollbar-width: thin;\n\tscrollbar-color: #afc2db transparent;\n\theight: calc(12 * 1.2em);\n\tlist-style: none;\n\tpadding-left: 0;\n\tmargin: 0 .4em .4em .4em;\n\tposition: relative;\n\tword-wrap: break-word;\n}\n\n#console>*+* {\n\tmargin-top: .5em;\n}\n\n.console-entry>* {\n\tdisplay: block;\n}\n\n.console-entry .input  { color: #3465a4; }\n.console-entry .output { color: #333; }\n\n.console-entry .input:before  { content: '>> ' }\n.console-entry .output:before { content: '<- ' }\n\n#console-form {\n\tmargin: 0 .4em .4em .4em;\n}\n\n#console-input {\n\twidth: 100%;\n\tfont-size: inherit;\n}\n\n.token.tagname { font-weight: bold; }\n.token.attr, .token.builtin, .token.italic { font-style: italic; }\n.token.string { opacity: .8; }\n.token.keyword { color: #3465a4; }\n.token.bold, .token.punctuation, .token.operator { font-weight: bold; }\n</style>\n</div>\n`;\nHDB.prototype.ui = function () {\n\tvar node = document.createElement(\"div\");\n\tvar shadow = node.attachShadow({ mode: \"open\" });\n\tnode.style = \"all: initial\";\n\tshadow.innerHTML = ui;\n\tdocument.body.appendChild(node);\n\t_hyperscript.processNode(shadow.querySelector(\".hdb\"));\n};\n","///=========================================================================\n/// This module provides the EventSource (SSE) feature for hyperscript\n///=========================================================================\n\nimport _hyperscript from \"./core\"\n\n_hyperscript.addFeature(\"eventsource\", function (parser, runtime, tokens) {\n\tif (tokens.matchToken(\"eventsource\")) {\n\t\tvar urlElement;\n\t\tvar withCredentials = false;\n\n\t\t// Get the name we'll assign to this EventSource in the hyperscript context\n\t\t/** @type {string} */\n\t\tvar name = parser.requireElement(\"dotOrColonPath\", tokens).evaluate();\n\t\tvar nameSpace = name.split(\".\");\n\t\tvar eventSourceName = nameSpace.pop();\n\n\t\t// Get the URL of the EventSource\n\t\tif (tokens.matchToken(\"from\")) {\n\t\t\turlElement = parser.requireElement(\"stringLike\", tokens);\n\t\t}\n\n\t\t// Get option to connect with/without credentials\n\t\tif (tokens.matchToken(\"with\")) {\n\t\t\tif (tokens.matchToken(\"credentials\")) {\n\t\t\t\twithCredentials = true;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {EventSourceStub} */\n\t\tvar stub = {\n\t\t\teventSource: null,\n\t\t\tlisteners: [],\n\t\t\tretryCount: 0,\n\t\t\topen: function (url) {\n\t\t\t\t// calculate default values for URL argument.\n\t\t\t\tif (url == undefined) {\n\t\t\t\t\tif (stub.eventSource != null && stub.eventSource.url != undefined) {\n\t\t\t\t\t\turl = stub.eventSource.url;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow \"no url defined for EventSource.\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Guard multiple opens on the same EventSource\n\t\t\t\tif (stub.eventSource != null) {\n\t\t\t\t\t// If we're opening a new URL, then close the old one first.\n\t\t\t\t\tif (url != stub.eventSource.url) {\n\t\t\t\t\t\tstub.eventSource.close();\n\t\t\t\t\t} else if (stub.eventSource.readyState != EventSource.CLOSED) {\n\t\t\t\t\t\t// Otherwise, we already have the right connection open, so there's nothing left to do.\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Open the EventSource and get ready to populate event handlers\n\t\t\t\tstub.eventSource = new EventSource(url, {\n\t\t\t\t\twithCredentials: withCredentials,\n\t\t\t\t});\n\n\t\t\t\t// On successful connection.  Reset retry count.\n\t\t\t\tstub.eventSource.addEventListener(\"open\", function (event) {\n\t\t\t\t\tstub.retryCount = 0;\n\t\t\t\t});\n\n\t\t\t\t// On connection error, use exponential backoff to retry (random values from 1 second to 2^7 (128) seconds\n\t\t\t\tstub.eventSource.addEventListener(\"error\", function (event) {\n\t\t\t\t\t// If the EventSource is closed, then try to reopen\n\t\t\t\t\tif (stub.eventSource.readyState == EventSource.CLOSED) {\n\t\t\t\t\t\tstub.retryCount = Math.min(7, stub.retryCount + 1);\n\t\t\t\t\t\tvar timeout = Math.random() * (2 ^ stub.retryCount) * 500;\n\t\t\t\t\t\twindow.setTimeout(stub.open, timeout);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Add event listeners\n\t\t\t\tfor (var index = 0; index < stub.listeners.length; index++) {\n\t\t\t\t\tvar item = stub.listeners[index];\n\t\t\t\t\tstub.eventSource.addEventListener(item.type, item.handler, item.options);\n\t\t\t\t}\n\t\t\t},\n\t\t\tclose: function () {\n\t\t\t\tif (stub.eventSource != undefined) {\n\t\t\t\t\tstub.eventSource.close();\n\t\t\t\t}\n\t\t\t\tstub.retryCount = 0;\n\t\t\t},\n\t\t\taddEventListener: function (type, handler, options) {\n\t\t\t\tstub.listeners.push({\n\t\t\t\t\ttype: type,\n\t\t\t\t\thandler: handler,\n\t\t\t\t\toptions: options,\n\t\t\t\t});\n\n\t\t\t\tif (stub.eventSource != null) {\n\t\t\t\t\tstub.eventSource.addEventListener(type, handler, options);\n\t\t\t\t}\n\t\t\t},\n\t\t};\n\n\t\t// Create the \"feature\" that will be returned by this function.\n\n\t\t/** @type {EventSourceFeature} */\n\t\tvar feature = {\n\t\t\tname: eventSourceName,\n\t\t\tobject: stub,\n\t\t\tinstall: function (target) {\n\t\t\t\truntime.assignToNamespace(target, nameSpace, eventSourceName, stub);\n\t\t\t},\n\t\t};\n\n\t\t// Parse each event listener and add it into the list\n\t\twhile (tokens.matchToken(\"on\")) {\n\t\t\t// get event name\n\t\t\tvar eventName = parser.requireElement(\"stringLike\", tokens, \"Expected event name\").evaluate(); // OK to evaluate this in real-time?\n\n\t\t\t// default encoding is \"\" (autodetect)\n\t\t\tvar encoding = \"\";\n\n\t\t\t// look for alternate encoding\n\t\t\tif (tokens.matchToken(\"as\")) {\n\t\t\t\tencoding = parser.requireElement(\"stringLike\", tokens, \"Expected encoding type\").evaluate(); // Ok to evaluate this in real time?\n\t\t\t}\n\n\t\t\t// get command list for this event handler\n\t\t\tvar commandList = parser.requireElement(\"commandList\", tokens);\n\t\t\taddImplicitReturnToCommandList(commandList);\n\t\t\ttokens.requireToken(\"end\");\n\n\t\t\t// Save the event listener into the feature.  This lets us\n\t\t\t// connect listeners to new EventSources if we have to reconnect.\n\t\t\tstub.listeners.push({\n\t\t\t\ttype: eventName,\n\t\t\t\thandler: makeHandler(encoding, commandList),\n\t\t\t});\n\t\t}\n\n\t\ttokens.requireToken(\"end\");\n\n\t\t// If we have a URL element, then connect to the remote server now.\n\t\t// Otherwise, we can connect later with a call to .open()\n\t\tif (urlElement != undefined) {\n\t\t\tstub.open(urlElement.evaluate());\n\t\t}\n\n\t\t// Success!\n\t\treturn feature;\n\n\t\t////////////////////////////////////////////\n\t\t// ADDITIONAL HELPER FUNCTIONS HERE...\n\t\t////////////////////////////////////////////\n\n\t\t/**\n\t\t * Makes an eventHandler function that can execute the correct hyperscript commands\n\t\t * This is outside of the main loop so that closures don't cause us to run the wrong commands.\n\t\t *\n\t\t * @param {string} encoding\n\t\t * @param {*} commandList\n\t\t * @returns {EventHandlerNonNull}\n\t\t */\n\t\tfunction makeHandler(encoding, commandList) {\n\t\t\treturn function (evt) {\n\t\t\t\tvar data = decode(evt[\"data\"], encoding);\n\t\t\t\tvar context = runtime.makeContext(stub, feature, stub);\n\t\t\t\tcontext.event = evt;\n\t\t\t\tcontext.result = data;\n\t\t\t\tcommandList.execute(context);\n\t\t\t};\n\t\t}\n\n\t\t/**\n\t\t * Decodes/Unmarshals a string based on the selected encoding.  If the\n\t\t * encoding is not recognized, attempts to auto-detect based on its content\n\t\t *\n\t\t * @param {string} data - The original data to be decoded\n\t\t * @param {string} encoding - The method that the data is currently encoded (\"string\", \"json\", or unknown)\n\t\t * @returns {string} - The decoded data\n\t\t */\n\t\tfunction decode(data, encoding) {\n\t\t\t// Force JSON encoding\n\t\t\tif (encoding == \"json\") {\n\t\t\t\treturn JSON.parse(data);\n\t\t\t}\n\n\t\t\t// Otherwise, return the data without modification\n\t\t\treturn data;\n\t\t}\n\n\t\t/**\n\t\t * Adds a \"HALT\" command to the commandList.\n\t\t * TODO: This seems like something that could be optimized:\n\t\t * maybe the parser could do automatically,\n\t\t * or could be a public function in the parser available to everyone,\n\t\t * or the command-executer-thingy could just handle nulls implicitly.\n\t\t *\n\t\t * @param {*} commandList\n\t\t * @returns void\n\t\t */\n\t\tfunction addImplicitReturnToCommandList(commandList) {\n\t\t\tif (commandList.next) {\n\t\t\t\treturn addImplicitReturnToCommandList(commandList.next);\n\t\t\t}\n\n\t\t\tcommandList.next = {\n\t\t\t\ttype: \"implicitReturn\",\n\t\t\t\top: function (/** @type {Context} */ _context) {\n\t\t\t\t\treturn runtime.HALT;\n\t\t\t\t},\n\t\t\t\texecute: function (/** @type {Context} */ _context) {\n\t\t\t\t\t// do nothing\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t}\n});\n"],"names":["_hyperscript","mergeObjects","obj1","obj2","key","hasOwnProperty","getOrInitObject","root","prop","value","newObj","varargConstructor","Cls","args","bind","apply","concat","globalScope","globalThis","ElementCollection","constructor","css","relativeToElement","this","_css","_runtime","escapeSelector","className","substr","id","Symbol","iterator","getRootNode","querySelectorAll","_lexer","OP_TABLE","$","isValidCSSClassChar","c","isAlpha","isNumeric","isValidCSSIDChar","isWhitespace","isNewline","isIdentifierChar","dollarIsOp","makeTokensObject","tokens","consumed","source","consumeWhitespace","_lastConsumed","token","type","push","shift","raiseError","error","_parser","raiseParseError","matchOpToken","currentToken","op","consumeToken","matchTokenType","type1","type2","type3","type4","indexOf","matchToken","follows","match","consumeUntil","tokenList","n","dontIgnoreWhitespace","i","pushFollow","str","popFollow","pop","clearFollow","tmp","restoreFollow","f","matchAnyToken","op1","op2","op3","arguments","length","opToken","matchAnyOpToken","requireOpToken","requireTokenType","JSON","stringify","requireToken","list","hasMore","lastMatch","consumeUntilWhitespace","lastWhitespace","sourceFor","substring","startToken","start","endToken","end","lineFor","split","line","isValidSingleQuoteStringStart","previousToken","tokenize","string","template","position","column","lastToken","templateBraceCount","inTemplate","currentChar","nextChar","consumeComment","possiblePrecedingSymbol","consumeAttributeReference","consumeShortAttributeReference","consumeIdentifier","consumeNumber","consumeOp","makeToken","consumeChar","Error","consumeString","consumeIdReference","consumeClassReference","classRef","attributeRef","idRef","identifier","number","makeOpToken","startChar","charAt","whitespace","GRAMMAR","COMMANDS","FEATURES","LEAF_EXPRESSIONS","INDIRECT_EXPRESSIONS","initElt","parseElement","programSource","elementDefinition","requireElement","message","result","parseAnyOf","types","expression","addGrammarElement","name","definition","lines","contextLine","repeat","createParserContext","commandStart","featureStart","parser","runtime","featureElement","featureDefinition","commandElement","commandDefinition","cmd","next","indirect","unless","context","conditional","execute","unifiedExec","parent","leaf","setParent","elt","commandBoundary","parseHyperScript","addCommand","keyword","commandGrammarType","commandDefinitionWrapper","meta","command","addFeature","featureGrammarType","featureDefinitionWrapper","addLeafExpression","addIndirectExpression","parseStringTemplate","returnArr","startingBrace","CONVERSIONS","dynamicResolvers","String","val","toString","Int","parseInt","Float","parseFloat","Number","console","log","Date","Array","from","Object","parse","matchesSelector","selector","matchesFunction","matches","msMatchesSelector","mozMatchesSelector","webkitMatchesSelector","oMatchesSelector","call","triggerEvent","eventName","detail","event","evt","Event","bubbles","cancelable","document","createEvent","initCustomEvent","makeEvent","dispatchEvent","isArrayLike","isArray","NodeList","shouldAutoIterate","forEach","func","isIterable","nth","ARRAY_SENTINEL","array_sentinel","unwrapAsyncs","values","asyncWrapper","j","valueElement","HALT","ctx","unifiedEval","e","registerHyperTrace","errorHandler","handlingError","errorSymmbol","reject","then","resolvedNext","catch","reason","async","wrappedAsyncs","argument","arr","element","evaluate","Promise","resolve","linearized","arg","linearize","all","valueArray","delinearize","_scriptAttrs","getScriptAttributes","config","attributes","replace","getScript","scriptAttribute","hasAttribute","getAttribute","HTMLScriptElement","innerText","hyperscriptFeaturesMap","WeakMap","getHyperscriptFeatures","hyperscriptFeatures","get","set","addFeatures","owner","parentElement","makeContext","feature","hyperscriptTarget","lexer","iterators","me","target","body","src","commandList","last","initElement","closest","disableSelector","internalData","getInternalData","initialized","script","hyperScript","setTimeout","hyperscript","stack","internalDataMap","getElementScope","scopeName","behavior","typeCheck","typeString","nullOk","prototype","slice","implicitLoop","x","processNode","getScriptSelector","HyperscriptModule","EventTarget","mod","super","module","map","attribute","join","resolveSymbol","fromMetaContext","fromContext","setSymbol","elementScope","findNext","resolveNext","convertValue","converted","dynamicResolver","undefined","converter","resolveProperty","property","component","componentValue","assignToNamespace","nameSpace","propertyName","newRoot","thrown","trace","caller","traceMap","Map","print","logger","maxLen","Math","max","displayName","traceElt","padEnd","getHyperTrace","nullCheck","isEmpty","node","rv","Document","ShadowRoot","hyperscriptUrl","import","url","expr","stringToken","rawValue","innerTokens","returnStr","tokenArr","t","numberToken","elementId","templateValue","getElementById","TemplatedQueryElementCollection","templateParts","elements","filter","Element","el","dataset","hsQueryId","removeAttribute","queryTokens","queryValue","outerVal","innerValue","beingTold","keyExpressions","valueExpressions","keys","returnVal","fields","_namedArgList_","symbolType","booleanLiteral","arg1","time","factor","_context","rootVal","childOfUrRoot","urRoot","propertyAccess","possessivesDisabled","apostrophe","query","targetElt","results","rootElt","conversion","functionCall","argExressions","rootRoot","hyperfunc","argVals","_ctx","andBefore","andAfter","firstIndex","secondIndex","arrayIndex","typeName","scanForwardArray","array","wrap","first","forwardSearch","thing","withinElt","inSearch","inElt","wrapping","operator","reverse","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","scanForwardQuery","DOCUMENT_POSITION_FOLLOWING","scanBackwardsQuery","rhs","rhsVal","children","floor","random","mathOp","initialMathOp","lhs","lhsVal","comparisonToken","hasRightValue","contains","logicalOp","initialLogicalOp","features","install","parseEventArgs","every","events","startCountToken","startCount","endCountToken","endCount","unbounded","intersectionSpec","mutationSpec","elsewhere","inExpr","debounceTime","throttleTime","execCount","on","queue","queueLast","queueFirst","queueNone","implicitReturn","onFeature","executing","queued","err","hypertrace","eventSpec","targets","MutationObserver","mutationList","observer","observe","IntersectionObserver","entries","entry","isIntersecting","addEventListener","listener","isConnected","removeEventListener","initialCtx","inElement","debounced","clearTimeout","lastExec","now","nameVal","funcName","errorSymbol","functionFeature","argumentVal","callingCommand","promise","theResolve","theReject","returned","returnValue","hypername","immediately","initFeature","path","formalParams","hs","innerArgs","installFeature","behaviorPath","behaviorNamespace","Function","jsSourceStart","jsLastToken","funcNames","expectFunctionDeclaration","peek","exposedFunctionNames","jsSource","jsBody","function","inputs","inp","input","actualResult","slot","tellCmd","index","originalBeingTold","lookahead","resolved","eventInfo","once","timeValue","separator","details","to","sendCmd","parseReturnFunction","returnAValue","returnCmd","keepExecuting","bubbling","haltDefault","exit","stopPropagation","preventDefault","exprs","withExpr","logCmd","throwCmd","parseCallOrGet","callCmd","tagname","classes","re","exec","trim","createElement","classList","add","functionName","pseudoCommand","makeSetter","symbolWrite","attributeWrite","setCmd","valueToSet","setAttribute","setter","defaultCmd","obj","objectLiteral","trueBranch","falseBranch","ifCmd","exprValue","parseRepeatExpression","startedWithForToken","innerStartToken","identifierToken","whileExpr","isUntil","times","forever","indexIdentifier","loop","waitATick","repeatCmd","until","whileValue","iteratorInfo","keepLooping","loopVal","eventFired","nextValFromIterator","done","repeatInit","innerHTML","amount","targetValue","newValue","fetchCmd","argExpressions","fetch","resp","json","text","scripts","res","code","fn","metaConfig","querySelector","jString","msg","parseJSON","content","documentElement","readyState","internals","defaultTransition","conversions","settleCommand","transitionStarted","r","cssDeclaration","classRefs","attrRef","style","cssText","stringParts","opencurly","tok","part","idx","elementExpr","removeChild","remove","between","classRef2","toggleCmd","toggle","HIDE_SHOW_STRATEGIES","display","visibility","opacity","parseShowHideTarget","currentTokenValue","resolveStrategy","configDefault","defaultHideShowStrategy","strategies","hideShowStrategies","putInto","valueToPut","HTMLDocument","firstChild","append","parsePseudopossessiveTarget","hideShowStrategy","triggerCmd","eventNameStr","forElt","takeCmd","eltColl","clazz","operationToken","operation","putCmd","before","after","prepend","properties","over","using","transition","promises","initialTransition","computedStyles","getComputedStyle","initialStyles","initalStyles","fromVal","toVal","propsToMeasure","rect","getBoundingClientRect","scroll","top","scrollTop","left","scrollLeft","topMax","scrollTopMax","leftMax","scrollLeftMax","height","scrollHeight","width","scrollWidth","y","right","bottom","bounds","parentSearch","closestExpr","back","newWindow","verticalPosition","horizontalPosition","smoothness","scrollOptions","block","inline","goCmd","window","history","open","location","href","scrollIntoView","getInputInfo","appendValue","info","checked","selected","toHTML","item","HTMLElement","outerHTML","frag","createDocumentFragment","temp","invocationIdCounter","workerCode","self","onmessage","data","importScripts","extraScripts","postMessage","blob","Blob","workerUri","URL","createObjectURL","genUUID","createSocket","WebSocket","workerName","extraScript","absoluteUrl","bodyStartIndex","bodyEndIndex","bodyTokens","worker","Worker","workerPromise","stubs","returnListener","PROXY_BLACKLIST","compileTemplate","p1","HDB","breakpoint","bus","socketName","defaultTimeout","jsonMessages","messageHandler","socket","rpcProxy","getProxy","timeout","Proxy","uuid","rpcInfo","iid","send","socketObject","raw","sentBy","rpc","socketFeature","dataAsJson","throw","return","urlElement","withCredentials","eventSourceName","stub","eventSource","listeners","retryCount","close","EventSource","CLOSED","min","handler","options","object","encoding","addImplicitReturnToCommandList","makeHandler","decode","template_","templateArgs","buf","assign","__ht_template_result","renderTemplate","escapeType","unescaped","hdb","break","ui","attr","continueExec","stepOver","stepOut","logCommand","halt_flag","callingCmd","oldMe","cmdSource","shadow","attachShadow","mode","appendChild"],"mappings":"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"}